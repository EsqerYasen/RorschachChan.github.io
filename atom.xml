<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-11T07:05:17.599Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用gdb去进入Too many connections的Mysql</title>
    <link href="http://yoursite.com/2019/03/11/%E4%BD%BF%E7%94%A8gdb%E5%8E%BB%E8%BF%9B%E5%85%A5Too-many-connections%E7%9A%84Mysql/"/>
    <id>http://yoursite.com/2019/03/11/使用gdb去进入Too-many-connections的Mysql/</id>
    <published>2019-03-11T06:17:36.000Z</published>
    <updated>2019-03-11T07:05:17.599Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天在登录mysql的时候，发现Too many connections的错误，如图：<br><img src="/images/mysql.png" alt="akb48"></p><p>很明显，连接数不够用了，在<code>my.cnf</code>里看到当前的最大链接是500。一般来说很多人就会修改<code>my.cnf</code>将<code>max_connections</code>改大然后重启mysql生效。但是我这个mysql是生产环境的，如果重启势必产生不小的影响，于是就需要不重启mysql还要能达到修改<code>max_connections</code>的目的。</p><p>那就用gdb，语句如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@db<span class="number">-02</span> data]<span class="comment"># gdb -p $(cat /opt/mysql/data/Storage.pid) -ex  "set max_connections=1024" -batch</span></span><br></pre></td></tr></table></figure></p><p>执行完毕之后，就可以正常登录到mysql的交互页面了：<br><img src="/images/mysql2.png" alt="akb48"></p><p>此时查询一下最大连接数：<br><img src="/images/mysql3.png" alt="akb48"></p><p>可见已经生效了，但是如果这个时候mysql有重启的话，还是会读取<code>my.cnf</code>里的<code>max_connections</code>配置，所以再手动改下<code>max_connections</code>即可。</p>]]></content>
    
    <summary type="html">
    
      一直都找不到一个好的识图网站，苦恼啊
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Centos7安装部署Hadoop集群</title>
    <link href="http://yoursite.com/2019/03/07/Centos6%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2Hadoop%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/03/07/Centos6安装部署Hadoop集群/</id>
    <published>2019-03-07T06:17:06.000Z</published>
    <updated>2019-03-08T02:52:39.940Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>目前大环境感觉不好，哪哪都是裁人的消息，所以这个时候更是要摆正心态、沉淀自己。</p><p>今年我个人的小目标是：Hadoop+k8s+python开发，这次就先写Hadoop的部署过程，可能会有一些名词看不懂，等下一篇再说名词解释。</p><p>先说环境：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.86</span>Master华为云Centos7<span class="number">.5</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.165</span>Salve华为云Centos7<span class="number">.5</span></span><br></pre></td></tr></table></figure></p><p>为了高可用，还要部署zookeeper来监视节点心跳情况，我这个例子里没有，如果有需要可以单独部署。</p><h2><span id="所有机器都要操作">所有机器都要操作</span></h2><font color="red" size="3">本段过程是所有的服务器都要一起操作的！</font><ol><li><p>先<code>yum update -y</code>，在等待的时候，我们就新开一个窗口，<code>wget http://apache.01link.hk/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz</code> 下载3.1.2版本的hadoop，下载完毕后，解压缩<code>hadoop-3.1.2.tar.gz</code>到<code>/opt</code>下，然后把hadoop-3.1.2改名叫hadoop。</p></li><li><p>在<code>yum update -y</code>完成之后，我们还要<code>yum install java-1.8.0-openjdk* -y</code>，安装完毕之后，执行<code>java -version</code>确认已经安装java 1.8成功。</p></li><li><p>在<code>/etc/hosts</code>文件里添加：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.86</span>master</span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.165</span>slave</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件，hadoop所有的配置文件都在<code>/opt/hadoop/etc/hadoop</code>路径下。<br>先修改<code>hadoop-env.sh</code>，添加一句<code>export JAVA_HOME=/usr</code>，因为我们直接用yum安装的，java默认就会安装到<code>/usr/bin/java</code>。所以这里写/usr即可，如果是另外方法安装需要写具体的路径而且要修改<code>/etc/profile</code>和<code>source /etc/profile</code>。</p></li></ol><p>在<code>core-site.xml</code>里的<code>configuration</code>里添加如下内容：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 指定hadoop运行时产生文件的存储目录,可以指定自己熟悉的目录，默认/tmp/hadoop-$&#123;user.name&#125; --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/opt/hadoop/tmp&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;!-- 指定hadoop使用的文件系统，HDFS的老大NameNode的地址 --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.default.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>hdfs-site.xml</code>里的<code>configuration</code>里添加如下内容：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">      &lt;!-- 指定HDFS副本数量，默认3 --&gt;</span><br><span class="line">      &lt;property&gt;</span><br><span class="line">         &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;2&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property&gt;</span><br><span class="line">         &lt;name&gt;dfs.name.dir&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;/opt/hadoop/dfs/name&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property&gt;</span><br><span class="line">         &lt;name&gt;dfs.data.dir&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;/opt/hadoop/dfs/data&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property&gt;</span><br><span class="line">         &lt;name&gt;dfs.permissions&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">      &lt;property&gt;</span><br><span class="line">         &lt;name&gt;dfs.http.address&lt;/name&gt;</span><br><span class="line">         &lt;value&gt;0.0.0.0:50070&lt;/value&gt;</span><br><span class="line">&lt;!-- 如果不加这句话，50070端口打不开 --&gt;</span><br><span class="line">      &lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>mapred-site.xml</code>里的<code>configuration</code>里添加如下内容：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 指定mapred运行时的框架：yarn，默认local --&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapred.job.tracker&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;master:49001&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapred.local.dir&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;/opt/hadoop/var&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p><p>在<code>yarn-site.xml</code>里的<code>configuration</code>里添加如下内容：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> &lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;master&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;description&gt;The address of the applications manager interface in the RM.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:8032&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;description&gt;The address of the scheduler interface.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:8030&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;description&gt;The http address of the RM web application.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:8088&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;description&gt;The https adddress of the RM web application.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.webapp.https.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:8090&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:8031&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;description&gt;The address of the RM admin interface.&lt;/description&gt;</span><br><span class="line">     &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;$&#123;yarn.resourcemanager.hostname&#125;:8033&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;1024&lt;/value&gt;</span><br><span class="line">     &lt;discription&gt;每个节点可用内存,单位MB,默认8182MB&lt;/discription&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;2.1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">     &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;1024&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></p><ol><li>把workers这个文件里的localhost替换成slave，2.X版本hadoop里的workers文件叫slaves。</li></ol><p>至此，所有机器操作的部分完毕，要确认两边的内容必须保持一致，不然启动的时候就会出现优先级出错的故障。</p><h2><span id="只有master操作">只有Master操作</span></h2><font color="red" size="3">以下操作只有master操作！</font><p>由于Master是namenode，slave是datanode，现在就需要对namenode进行一个初始化的操作，即是hdfs的一个初始化。</p><p>进入<code>/opt/hadoop/bin</code>里，执行<code>./hadoop namenode -format</code> ，格式化一个新的分布式文件系统，如果不报错那就说明成功。完毕之后，可以去<code>/opt/hadoop/dfs/name</code>这个目录下发现多了一个current文件夹。</p><h2><span id="配置普通用户免密码登录">配置普通用户免密码登录</span></h2><p>至此整个部署过程就完毕了，如果是root用户就可以直接去<code>/opt/hadoop/hadoop-2.8.0/sbin</code>下执行<code>./start-all.sh</code>了，但是为了安全，我们不要用root用户去启动hadoop，而是用普通用户去启动它。</p><p>于是我们先在两台机器上<code>adduser hadoop</code>，这里不设置密码。然后<code>chown -R /opt/hadoop</code>，把整个hadoop文件夹的权限都给hadoop用户。</p><p>然后执行<code>ssh-keygen -t rsa</code>，一顿回车之后发现在<code>/home/hadoop/.ssh</code>下有了<code>id_rsa</code>和<code>id_rsa.pub</code>这俩文件。这俩就是root用户的ssh公钥和私钥文件，<code>su hadoop</code>切换到hadoop用户上，同样的操作一遍，获取到hadoop用户的ssh公钥和私钥文件。</p><p>master和slave都在<code>/home/hadoop/.ssh</code>下新建一个文件叫<code>authorized_keys</code>，并且互相复制对方的hadoop的<code>id_rsa.pub</code>到自己的<code>authorized_keys</code>里，然后再复制自己的root的<code>id_rsa.pub</code>到自己的<code>authorized_keys</code>里。</p><p>修改<code>authorized_keys</code>的权限是600，此时无论是master还是salve的hadoop用户都应该可以无密码登录自己和对方，如图：<br><img src="/images/hadoop1.png" alt="akb48" title="在slave也要能互相登录和登录自己"></p><h2><span id="启动hadoop">启动Hadoop</span></h2><p>当前用户是hadoop，在master机器上执行<code>/opt/hadoop/sbin/start-all.sh</code>即启动hadoop，如图：<br><img src="/images/hadoop2.png" alt="akb48"></p><p>此时在slave机器上会看到有两个进程启动：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop   13552     1  2 10:35 ?        00:00:03 /usr//bin/java -Dproc_datanode -Djava.net.preferIPv4Stack=true -Dhadoop.security.logger=ERROR,RFAS -Dyarn.log.dir=/opt/hadoop/logs -Dyarn.log.file=hadoop-hadoop-datanode-slave.log -Dyarn.home.dir=/opt/hadoop -Dyarn.root.logger=INFO,console -Djava.library.path=/opt/hadoop/lib/native -Dhadoop.log.dir=/opt/hadoop/logs -Dhadoop.log.file=hadoop-hadoop-datanode-slave.log -Dhadoop.home.dir=/opt/hadoop -Dhadoop.id.str=hadoop -Dhadoop.root.logger=INFO,RFA -Dhadoop.policy.file=hadoop-policy.xml org.apache.hadoop.hdfs.server.datanode.DataNode</span><br><span class="line">hadoop   13670     1  3 10:35 ?        00:00:04 /usr//bin/java -Dproc_nodemanager -Djava.net.preferIPv4Stack=true -Dyarn.log.dir=/opt/hadoop/logs -Dyarn.log.file=hadoop-hadoop-nodemanager-slave.log -Dyarn.home.dir=/opt/hadoop -Dyarn.root.logger=INFO,console -Djava.library.path=/opt/hadoop/lib/native -Dhadoop.log.dir=/opt/hadoop/logs -Dhadoop.log.file=hadoop-hadoop-nodemanager-slave.log -Dhadoop.home.dir=/opt/hadoop -Dhadoop.id.str=hadoop -Dhadoop.root.logger=INFO,RFA -Dhadoop.policy.file=hadoop-policy.xml -Dhadoop.security.logger=INFO,NullAppender org.apache.hadoop.yarn.server.nodemanager.NodeManager</span><br></pre></td></tr></table></figure></p><p>或者使用jps命令在双方机器上查看启动的进程名：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@slave hadoop]<span class="comment"># jps</span></span><br><span class="line"><span class="number">13552</span> DataNode</span><br><span class="line"><span class="number">13670</span> NodeManager</span><br><span class="line"><span class="number">1543</span> WrapperSimpleApp</span><br><span class="line"><span class="number">13790</span> Jps</span><br></pre></td></tr></table></figure></p><p>在华为云的安全组里对这俩服务器打开50070端口和8088的公网访问端口，然后在浏览器里输入<code>http://master公网IP:50070</code>即可查看效果：<br><img src="/images/hadoop3.png" alt="akb48"></p><p>而输入<code>http://master公网IP:8088</code>就会看到cluster页面：<br><img src="/images/hadoop4.png" alt="akb48"></p><p>如果要关闭，就在master执行<code>/opt/hadoop/sbin/stop-all.sh</code>，至此一个简单的hadoop集群搭建和启动完毕。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.cnblogs.com/charlesblc/p/6030008.html" target="_blank" rel="noopener">https://www.cnblogs.com/charlesblc/p/6030008.html</a><br><a href="https://blog.wuwii.com/linux-hadoop.html" target="_blank" rel="noopener">https://blog.wuwii.com/linux-hadoop.html</a></p>]]></content>
    
    <summary type="html">
    
      如果服务器ifconfig命令屏蔽了外网网卡导致无法得到外网IP，可以尝试curl ifconfig.me获取，不过如果有路由可能会不准
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix出现数据库IIllegal mix of collations的报错</title>
    <link href="http://yoursite.com/2019/03/05/Zabbix%E5%87%BA%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93IIllegal-mix-of-collations%E7%9A%84%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2019/03/05/Zabbix出现数据库IIllegal-mix-of-collations的报错/</id>
    <published>2019-03-05T02:07:04.000Z</published>
    <updated>2019-03-05T02:22:10.338Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>接到新的私有云工作，登录到甲方爸爸的服务器一看是centos6.1，上面安装了zabbix-server但是仅仅做了<code>auto-discovery</code>，于是我就做<code>templates</code>，可见名称是中文的。但是发现在保存的时候，出现了这样的错误：<br><img src="/images/zabbix4.png" alt="akb48"></p><p>定眼一看，这是数据库的编码问题，整个database都是拉丁编码而不是utf8编码，所以无法输入中文。</p><p>要解决这个问题比较简单，毕竟zabbix刚启动而已，数据库里还没有数据。于是我就干脆把整个zabbix的database干掉，重建一个新的：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -uzabbix -p<span class="comment">#登录数据库</span></span><br><span class="line">drop databases zabbix;<span class="comment">#暴力全部删光</span></span><br></pre></td></tr></table></figure></p><p>此时的zabbix-server的web界面是如下的：<br><img src="/images/zabbix5.png" alt="akb48"></p><p>然后返回到mysql里：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database zabbix character set utf8;</span><br><span class="line"><span class="comment"># ctrl+c 退出数据库</span></span><br><span class="line">zcat /usr/share/doc/zabbix-server-mysql<span class="number">-3.4</span><span class="number">.15</span>/create.sql.gz  |mysql -uzabbix -p26e9p69r zabbix<span class="comment">#重新导入初始化表</span></span><br></pre></td></tr></table></figure></p><p>然后在web界面点击<code>retry</code>，然后重新登陆一下zabbix-server。再次尝试编辑带有中文的监控项，就能顺利保存了！</p>]]></content>
    
    <summary type="html">
    
      衷心恳请以后甲方别装centos6了，装7吧...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>不要轻易去打开tcp_tw_recycle！</title>
    <link href="http://yoursite.com/2019/03/04/%E4%B8%8D%E8%A6%81%E8%BD%BB%E6%98%93%E5%8E%BB%E6%89%93%E5%BC%80tcp-tw-recycle%EF%BC%81/"/>
    <id>http://yoursite.com/2019/03/04/不要轻易去打开tcp-tw-recycle！/</id>
    <published>2019-03-04T07:23:09.000Z</published>
    <updated>2019-03-04T09:06:56.666Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="挖坑过程">挖坑过程</span></h2><p>有时候，我们可能发现服务器里存在大量的<code>TIME_WAIT</code>，如图：<br><img src="/images/time4.png" alt="办公室"></p><p>其实这2000+的<code>TIME_WAIT</code>真的不算多，至少低于10000条都不算多。但是<code>TIME_WAIT</code>本身是一个占用内存和CPU的东西，所以很多人就想把它干掉。往往这个时候，就会看到这样的答案：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打开 sysctl.conf 文件，修改以下几个参数：</span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line">net.ipv4.tcp_timestamps = <span class="number">1</span><span class="comment">#只有打开这个，前俩才能生效</span></span><br></pre></td></tr></table></figure></p><p>修改完毕之后，再<code>/sbin/sysctl -p</code>一下，就会看到<code>TIME_WAIT</code>果然大量减少，效果立竿见影！但是不要高兴太早，其实你给自己埋下了一个大坑…</p><h2><span id="time_wait是干啥的">TIME_WAIT是干啥的</span></h2><font color="red">只有主动关闭连接的一方，才会转移到<code>TIME_WAIT</code>。只有被动断开连接的一方会出现<code>CLOSE_WAIT</code>，等待<code>close()</code>执行完毕之后，状态变成<code>LAST_ACK</code>。</font><p><code>TIME_WAIT</code>的主要目的有2个：</p><ol><li><p>避免误收延迟到达的报文：因为报文又快又慢，而若<code>TIME_WAIT</code>太短就会放弃原来的链接，生成新的链接，而新的链接此时接到迟到了报文，这就出现了数据错误的现象；</p></li><li><p>保证对端已经关闭了连接：由于<code>TIME_WAIT</code>的时间被缩短了，对端还处于<code>LAST_ACK</code>状态，本段发送的syn报文被直接RST掉了。</p></li></ol><h2><span id="再说结论">再说结论</span></h2><p>当配置了<code>net.ipv4.tcp_tw_recycle = 1</code>之后，<code>TIME_WAIT</code>这个阶段就几乎是不存在了，因为原本它的存活时间是<code>2MSL</code>时间，现在改成了一个<code>RTO</code>，这个RTO可以远远小于2MSL的。当一个socket连接进入<code>TIME_WAIT</code>状态后，内核里会记录包括该socket连接对应的五元组中的对方IP等在内的一些统计数据，当然也包括从该对方IP所接收到的最近的一次数据包时间。当有新的数据包到达，只要时间晚于内核记录的这个时间，数据包都会被统统的丢掉。</p><p>那怎么会影响具体业务呢？如果你所在的网络是NAT网络，即“多个客户端，但是同一个IP出口”这样的网络环境，这样很多人其实使用的是同一个IP。但是在服务器端它是始终在跟同一个host打交道，那么在一个RTO的时间内，只能有一个客户端和自己连接成功，而其他人要连接就会出现超时的现象。</p><p>抓包体现是<code>客户端发送了syn给服务端，但是服务端不会回复ack，然后客户端就一直处于等待，通畅以为服务器端此时卡死了，可是此时服务器的负载并不高</code>。</p><h2><span id="为什么tcp4次挥手时等待为2msl">为什么TCP4次挥手时等待为2MSL？</span></h2><p>MSL是<code>Maximum Segment Lifetime</code>,译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。TCP只有断开了才会释放占用端口等资源，新来的链接才能复用这个端口。若被动断开的一方一直收不到最后一个ACK,那就会等待retry times到了上限，会reset连接。</p><p>如果不等，释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的老的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，需要耐心等待网络老的TCP连接的活跃报文全部死翘翘，2MSL时间可以满足这个需求。</p><h2><span id="正确做法">正确做法</span></h2><p>解决办法就是不建议同时开启<code>tcp_timestamp</code>和<code>tcp_tw_recycle</code>。</p><p>正确的解决这个总是办法应该是：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_local_port_range = <span class="number">9000</span> <span class="number">6553</span> <span class="comment">#默认值范围较小</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = <span class="number">10000</span> <span class="comment">#默认值较小，还可适当调小</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span> <span class="comment">#</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = <span class="number">10</span> <span class="comment">#</span></span><br></pre></td></tr></table></figure></p><p>插播一句，<code>tcp_tw_recycle</code>这个参数已经在新的内核<code>kernel 4.12</code>里已经去掉了。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.cnxct.com/coping-with-the-tcp-TIME_WAIT-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/" target="_blank" rel="noopener">https://www.cnxct.com/coping-with-the-tcp-TIME_WAIT-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/</a><br><a href="https://ieevee.com/tech/2017/07/19/tcp-tw-recycle.html#TIME_WAIT%E6%98%AF%E5%B9%B2%E5%95%A5%E7%9A%84" target="_blank" rel="noopener">https://ieevee.com/tech/2017/07/19/tcp-tw-recycle.html#TIME_WAIT%E6%98%AF%E5%B9%B2%E5%95%A5%E7%9A%84</a><br><a href="https://www.jianshu.com/p/893b5d7e9f30" target="_blank" rel="noopener">https://www.jianshu.com/p/893b5d7e9f30</a><br><a href="https://www.zhihu.com/question/67013338" target="_blank" rel="noopener">https://www.zhihu.com/question/67013338</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&amp;mid=2650910938&amp;idx=2&amp;sn=8b0aa87b0f45b8465e3fe9a70f51c895&amp;chksm=f06a55d7c71ddcc120d49d4808ac471d6ae37c105cf37cbfdf142384a3bb2fb5b94ff76b904a&amp;mpshare=1&amp;scene=1&amp;srcid=0226ijYLsAmX7LdKO206NINd&amp;key=d98c1a7a91040c8d88006a294b27c49cb4fc4e200242db9cfabf2f4d98e420954e2210ce8d72d0ea778a548e2596bef617479a59cc23a4164f93cfd0cfa85a8d460c21de5501f934e13fd0fc2e50cbce&amp;ascene=1&amp;uin=MTE4NTkxNTEwMA%3D%3D&amp;devicetype=Windows+7&amp;version=62060720&amp;lang=zh_CN&amp;pass_ticket=RxcXlxUz8iYDMMdnmhYX6NfQJkTaZzim2gD9j8q74LaeYI8X1cSH0njnQZXJfH8g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&amp;mid=2650910938&amp;idx=2&amp;sn=8b0aa87b0f45b8465e3fe9a70f51c895&amp;chksm=f06a55d7c71ddcc120d49d4808ac471d6ae37c105cf37cbfdf142384a3bb2fb5b94ff76b904a&amp;mpshare=1&amp;scene=1&amp;srcid=0226ijYLsAmX7LdKO206NINd&amp;key=d98c1a7a91040c8d88006a294b27c49cb4fc4e200242db9cfabf2f4d98e420954e2210ce8d72d0ea778a548e2596bef617479a59cc23a4164f93cfd0cfa85a8d460c21de5501f934e13fd0fc2e50cbce&amp;ascene=1&amp;uin=MTE4NTkxNTEwMA%3D%3D&amp;devicetype=Windows+7&amp;version=62060720&amp;lang=zh_CN&amp;pass_ticket=RxcXlxUz8iYDMMdnmhYX6NfQJkTaZzim2gD9j8q74LaeYI8X1cSH0njnQZXJfH8g</a></p>]]></content>
    
    <summary type="html">
    
      说白了，大量的TIME_WAIT就是服务器里短连接太多。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="tcp链接" scheme="http://yoursite.com/tags/tcp%E9%93%BE%E6%8E%A5/"/>
    
      <category term="内核优化" scheme="http://yoursite.com/tags/%E5%86%85%E6%A0%B8%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维工程师笔试题第十八套</title>
    <link href="http://yoursite.com/2019/03/04/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E5%85%AB%E5%A5%97/"/>
    <id>http://yoursite.com/2019/03/04/Linux运维工程师笔试题第十八套/</id>
    <published>2019-03-04T03:52:02.000Z</published>
    <updated>2019-03-08T09:54:37.841Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="试题内容">试题内容</span></h2><p>1.docker的exec与attach命令有啥区别？<br><code>attach</code>开启一个和正在运行的进程交互的终端，如果该进程结束，原docker container的进程也会结束。<br><code>exec</code>可以开启多个终端实例，<code>exec -i /bin/bash</code>，由此可见exec其实是在运行中的容器中执行一个命令。</p><p>2.docker的CMD与ENTRYPOINT命令有啥区别？<br><code>CMD</code>的命令会被<code>docker run</code>里的命令覆盖，而<code>ENTRYPOINT</code>命令不会。<br>如果要覆盖<code>ENTRYPOINT</code>，则在<code>docker run</code>里添加<code>--entrypoint</code>标签来覆盖即可。<br>如果dockerfile里指定了<code>WORKDIR</code>，那么无论是<code>CMD</code>还是<code>ENTRYPOINT</code>命令都是在这个WORKDIR目录里执行。</p><p>3.docker的kill和stop命令有啥区别？<br>stop是“优雅退出”，先发送SIGTERM信号，在一段时间之后（10s）再发送SIGKILL信号。Docker内部的应用程序可以接收SIGTERM信号，然后做一些“退出前工作”，比如保存状态、处理当前请求等。<br>kill是“暴力退出”，即发送SIGKILL信号，应用程序直接退出。</p><p>4.假设有一个AAA的容器，现在需要备份它的挂载卷/DATA里的数据，请问如何操作？<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-form A -v /tmp:/backup --name BACKUP ubuntu tar cvf /backup/A.tar /DATA</span><br></pre></td></tr></table></figure></p><p>上面这个语句新建立一个叫BACKUP的容器，它与A容器挂载情况相同（即都是挂载/DATA），同时将本地的/tmp挂载到容器的/backup，在容器生成的时候，执行了<code>tar cvf /backup/A.tar /DATA</code>将DATA文件夹的内容进行了打包，又由于/tmp已经与/backup挂载，所以就可以直接从宿主机上的/tmp里得到A.tar了。</p><p>4.linux里删除某个用户的所有进程的语句？<br>ps -u username | grep -v PID | awk ‘{print$1}’| xargs kill -9<br>或者killall -u username</p><p>5.linux如何彻底删除一个用户？<br>userdel -r zhidao（前提是这个用户下已经没有程序运行了）</p><p>6.ps -ef |grep 进程名|awk “{print $2}”|xargs kill -9 </p><p>未完待续</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec" target="_blank" rel="noopener">https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec</a><br><a href="http://dockone.io/question/469" target="_blank" rel="noopener">http://dockone.io/question/469</a></p>]]></content>
    
    <summary type="html">
    
      这次是跟docker相关的题
    
    </summary>
    
      <category term="大牛之路" scheme="http://yoursite.com/categories/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>H5界面实现桌面推送通知</title>
    <link href="http://yoursite.com/2019/03/01/h5%E7%95%8C%E9%9D%A2%E5%AE%9E%E7%8E%B0%E6%A1%8C%E9%9D%A2%E6%8E%A8%E9%80%81%E9%80%9A%E7%9F%A5/"/>
    <id>http://yoursite.com/2019/03/01/h5界面实现桌面推送通知/</id>
    <published>2019-03-01T06:42:20.000Z</published>
    <updated>2019-03-01T10:16:04.871Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我们产品线的服务器告警模式是：“每十分钟执行一次脚本，脚本会使用zkclient获取当前服务器的CPU、内存、带宽、服务负载，然后以邮件的形式发送到运维人员的邮箱里”，每十分钟一次的频率可想而知，一天下来邮箱要有几百几千封邮件，看着就心烦。于是我就冒出了一个大胆的想法，重构这套土了吧唧的告警模式。</p><p>思路是这样的：“依旧是通过后台脚本结合crontab定时获取服务器的相关采集值，然后将值传入到Django的views.py里，呈现到某个页面上，这个页面也会定时自动刷新，每次刷新的时候也就顺便取到了新的采集值，如果有告警，那么页面对应的告警值红色标注，同时弹出通知。”</p><p>这么一看感觉高大上了很多，至少不用天天去outlook里清理垃圾邮件。</p><h2><span id="实现自动刷新">实现自动刷新</span></h2><p>页面自动刷新的方法很简单，有如下2种：<br>1.页面自动刷新：把如下代码加入<code>&lt;head&gt;</code>区域中<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"20"</span>&gt;<span class="comment">//其中20指每隔20秒刷新一次页面.</span></span><br></pre></td></tr></table></figure></p><p>这个功能也能结合页面自动跳转：把如下代码加入<code>&lt;head&gt;</code>区域中<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"20;url=http://www.webjx.com"</span>&gt;<span class="comment">//其中20指隔20秒后跳转到http://www.webjx.com页面</span></span><br></pre></td></tr></table></figure></p><p>我想，QQ好友生日祝福功能里10秒钟自动关闭就应该是这么做出来的。</p><p>2.页面自动刷新之js版<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">"JavaScript"</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myrefresh</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">window</span>.location.reload();</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(<span class="string">'myrefresh()'</span>,<span class="number">1000</span>); <span class="comment">//指定1秒刷新一次</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></p><p>这里多说一下<code>http-equiv</code>，<code>http-equiv</code>是响应头报文。它只能出现在<code>meta</code>标签里，用来代替<code>name</code>，它的值使用<code>content</code>属性描述，HTTP服务器通过此属性收集HTTP协议的响应头报文。</p><p>比如：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> Content=<span class="string">"text/html; Charset=gb2312″ /&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面代码告诉浏览器等设备，文件为html文件，且使用了utf8编码;<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Content-Language"</span> Content=<span class="string">"zh-CN"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>上面代码告诉浏览器等设备，语言使用了中文;<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">"Expires"</span> Content=<span class="string">"Wed, 26 Feb 1997 08:21:57 GMT"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>上面代码指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新调阅。<font color="red">注意：必须使用GMT的时间格式，或直接设为0(数字表示多少时间后过期)。</font></p><h2><span id="实现桌面通知">实现桌面通知</span></h2><p>桌面通知是一个比较优雅的功能，只要你后台打开网页，那么一旦网页里触发了通知，就会在windows桌面上弹出一个小窗口告诉我们页面发生了，如图：<br><img src="/images/notify1.png" alt="办公室"></p><p>它的实现关键词就是<code>Notification API</code>，这个动作的js代码如下：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"> <span class="comment">//判断浏览器是否支持Notification</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (<span class="built_in">window</span>.Notification) &#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> title;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> options;</span></span><br><span class="line"><span class="javascript">title = <span class="string">'服务器告警提醒'</span>;<span class="comment">//通知的标题</span></span></span><br><span class="line"><span class="javascript">options = &#123;<span class="comment">//通知的所有内容</span></span></span><br><span class="line"><span class="javascript">body: <span class="string">"机器千万台，稳定第一条，服务一瘫痪，运维泪两行。"</span>,<span class="comment">//通知主体内容</span></span></span><br><span class="line"><span class="javascript">tag: <span class="string">"custom"</span>,<span class="comment">//代表通知的一个识别标签，相同tag时只会打开同一个通知窗口</span></span></span><br><span class="line"><span class="javascript">icon: <span class="string">"http://img.mp.itc.cn/upload/20160723/a5953dc52c484834ab1ce924bb344da8_th.jpg"</span>,<span class="comment">//要在通知中显示的图标的URL</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// images: "https://xxx.jpg" //要在通知中显示的图像的URL</span></span></span><br><span class="line"><span class="javascript">requireInteraction: <span class="literal">false</span><span class="comment">//通知保持自动关闭</span></span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="javascript">Notification.requestPermission(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> notification = <span class="keyword">new</span> Notification(title, options);</span></span><br><span class="line"><span class="javascript">notificationEvents.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">eventName</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">notification[eventName] = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">alert(<span class="string">"你使用的浏览器不支持弹出提示，请更换Chrome内核浏览器！"</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>再结合上面的自动刷新语句，在浏览器打开的时候，首先会询问是够接受“通知”，如图：<br><img src="/images/notify2.png" alt="办公室"></p><p>同意了之后，浏览器每10秒钟自动刷新，同时弹出上面那个加菲猫弹窗。</p><p>而且<code>Notification API</code>只能对https的网站可用，详情可见： <a href="https://stackoverflow.com/questions/30542287/are-push-notifications-possible-in-html5-without-fully-https-site" target="_blank" rel="noopener">https://stackoverflow.com/questions/30542287/are-push-notifications-possible-in-html5-without-fully-https-site</a> 。</p><h2><span id="全部整合">全部整合</span></h2><p>现在就需要把上面两个功能全部整合到一起，实现<code>每10分钟自动刷新，同时判断传入数值，如果数值超标就发送桌面通知</code>。</p><p>首先，先在django的<code>url.py</code>里设定访问的路径和对应的函数:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views </span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line"><span class="comment"># 前面略</span></span><br><span class="line">path(<span class="string">r'test222/'</span>,views.ttt),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>然后在<code>views.py</code>里简单设置一下这个<code>ttt</code>函数：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ttt</span><span class="params">(request)</span>:</span></span><br><span class="line">    cpu = <span class="number">6.66</span></span><br><span class="line">    mem = <span class="number">66.6</span></span><br><span class="line">    disk = <span class="number">26</span></span><br><span class="line">    <span class="keyword">return</span> render_to_response(<span class="string">'test222.html'</span>,&#123;<span class="string">'CPU'</span>:cpu,<span class="string">'MEMORY'</span>:mem,<span class="string">'DISKUSED'</span>:disk&#125;)</span><br></pre></td></tr></table></figure></p><p>现在已经传入了三个数值，然后我们加工一下<code>test222.html</code>页面，如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">                &lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"60"</span>&gt;</span><br><span class="line">                &lt;title&gt;服务器监控页面&lt;/title&gt;</span><br><span class="line">                &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">                        var cpu=<span class="string">"&#123;&#123;CPU&#125;&#125;"</span>,mem=<span class="string">"&#123;&#123;MEMORY&#125;&#125;"</span>,disk=<span class="string">"&#123;&#123;DISKUSED&#125;&#125;"</span></span><br><span class="line">                                // alert(cpu+<span class="string">' '</span>+mem+<span class="string">' '</span>+disk)</span><br><span class="line">                        <span class="keyword">if</span> ( cpu &gt; <span class="number">80</span> || mem &gt; <span class="number">80</span> || disk &gt; <span class="number">80</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (window.Notification) &#123;</span><br><span class="line">                                        var title;</span><br><span class="line">                                        var options;</span><br><span class="line">                                        title = <span class="string">'服务器告警提醒'</span>;                       //通知的标题</span><br><span class="line">                                        options = &#123;                     //通知的所有内容</span><br><span class="line">                                                body: <span class="string">"机器千万台，稳定第一条，服务一瘫痪，运维泪两行。"</span>,               //通知主体内容                                                tag: <span class="string">"custom"</span>,          //代表通知的一个识别标签，相同tag时只会打开同一个通知窗口</span><br><span class="line">                                                icon: <span class="string">"http://img.mp.itc.cn/upload/20160723/a5953dc52c484834ab1ce924bb344da8_th.jpg"</span>    //要在通知中显示的图标的URL</span><br><span class="line">                                        &#125;;</span><br><span class="line">                                        Notification.requestPermission(function() &#123;</span><br><span class="line">                                                var notification = new Notification(title, options);</span><br><span class="line">                                                notificationEvents.forEach(function(eventName) &#123;</span><br><span class="line">                                                        notification[eventName] = function(event) &#123;</span><br><span class="line">                                                        &#125;;</span><br><span class="line">                                                &#125;);</span><br><span class="line">                                        &#125;);</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                alert(<span class="string">"你使用的浏览器不支持弹出提示，请更换Chrome内核浏览器！"</span>);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                &lt;/script&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line"></span><br><span class="line">        &lt;body&gt;</span><br><span class="line">                &lt;h3&gt;服务器名称是test-ooxx-001&lt;/h3&gt;</span><br><span class="line">                &lt;hr&gt;</span><br><span class="line">                &lt;h4&gt;CPU情况是：&#123;&#123; CPU &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;内存情况是：&#123;&#123; MEMORY &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;磁盘容量情况是：&#123;&#123; DISKUSED &#125;&#125;&lt;/h4&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>界面如下：<br><img src="/images/notify3.png" alt="办公室"></p><p>现在修改一下<code>views.py</code>里的三个值，只要有一个大于设定的标准值，就会触发桌面推送。</p><p>js里“a=空就判断b，b如果也是空再判断C，然后执行func()”的语句是：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a != null || b != null || c != null ) &#123;</span><br><span class="line">    fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/notification</a><br><a href="http://www.ptbird.cn/html5-notification-browser.html" target="_blank" rel="noopener">http://www.ptbird.cn/html5-notification-browser.html</a><br><a href="https://segmentfault.com/a/1190000011670082" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011670082</a></p>]]></content>
    
    <summary type="html">
    
      Notification API对浏览器的隐身模式使用是无效的。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>让Nginx鉴权功能保护Kibana网页</title>
    <link href="http://yoursite.com/2019/02/28/%E8%AE%A9Nginx%E9%89%B4%E6%9D%83%E5%8A%9F%E8%83%BD%E4%BF%9D%E6%8A%A4Kibana%E7%BD%91%E9%A1%B5/"/>
    <id>http://yoursite.com/2019/02/28/让Nginx鉴权功能保护Kibana网页/</id>
    <published>2019-02-28T07:55:27.000Z</published>
    <updated>2019-02-28T08:52:44.723Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Kibana本身是一个Web界面，但是出于安全和机密的考虑，我们肯定不会让互联网上所有的人都能随便看到Kibana里的内容，但是X-pack目前又不支持6.2以上的版本，于是我们可以使用Nginx的密码功能来保护Kibana的网页：要访问Kibana时需要先输入密码，正确就登陆到Kibana，如果错误就是403。</p><p>Kibana是容器安装的，安装过程可以去查看：<a href="https://rorschachchan.github.io/2019/01/21/%E5%B0%86kafka%E5%8A%A0%E5%85%A5%E5%88%B0Elk%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">https://rorschachchan.github.io/2019/01/21/%E5%B0%86kafka%E5%8A%A0%E5%85%A5%E5%88%B0Elk%E9%9B%86%E7%BE%A4/</a> </p><h2><span id="事前准备">事前准备</span></h2><p>Nginx也是容器安装，<code>docker pull nginx</code>拉取最新的nginx镜像，在下载的时候呢我们也别对着屏幕干巴巴的等。由于在nginx配置转发的时候，需要知道Kibana的容器IP，这是因为Kibana和正在下载的Nginx是两个不同的容器，Nginx是需要跨容器访问的。</p><p>默认的官方Kibana镜像登录是非root的，这种虽然安全，但是不能config也不能yum，于是我们首先要使用root账号登录进去，语句是：<br>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it --user root kibana容器ID /bin/bash</span><br><span class="line">yum update -y</span><br><span class="line">yum install -y net-tools#下载ifconfig</span><br></pre></td></tr></table></figure></p><p>使用ifconfig和netstat查看容器的IP和工作端口：<br><img src="/images/kibana20.png" alt="办公室"></p><p>可以确认Kibana的IP是<code>172.17.0.4</code>，端口是5601。这时候我们就可以写一个<code>kibana.conf</code>，让nginx容器用这个配置文件达到跳转的目的！</p><p><code>kibana.conf</code>全文如下：<br>    <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream kibana_server &#123;</span><br><span class="line">        server  172.17.0.3:5601 weight=1 max_fails=3  fail_timeout=60;#这里写的就是kibana的容器IP和端口，如果是多台kibana想要按权重访问，就写weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen *:33664;#nginx容器自己的端口</span><br><span class="line">        server_name _;</span><br><span class="line">        auth_basic "Restricted Access";      # 验证</span><br><span class="line">        auth_basic_user_file /etc/nginx/conf.d/htpasswd.users;             # 验证文件</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://kibana_server;#这个地方就是upstream</span><br><span class="line">                proxy_http_version 1.1;</span><br><span class="line">                proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                proxy_set_header Connection 'upgrade';</span><br><span class="line">                proxy_set_header Host $host;</span><br><span class="line">                proxy_cache_bypass $http_upgrade;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把这个文件保存在<code>/mnt/nginx</code>目录里。</p><h2><span id="配置nginx密码">配置nginx密码</span></h2><p>nginx要创建验证文件授权,需要先安装<code>httpd-tools</code>工具：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y  httpd-tools </span><br><span class="line">htpasswd -bc /mnt/nginx/htpasswd.users kibana password123 <span class="comment"># 创建验证文件</span></span><br><span class="line">Adding password <span class="keyword">for</span> user admin</span><br></pre></td></tr></table></figure></p><p>这时我们就创建了一个<code>/mnt/nginx/htpasswd.users</code>，里面的用户是kibana，密码是password123。这个密码在文件里是加密的，用cat命令无法正常查看到的。</p><h2><span id="启动nginx容器">启动nginx容器</span></h2><p>此时nginx镜像应该下载完毕了，那么就直接启动镜像，启动语句是：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --hostname Kngx -p <span class="number">80</span>:<span class="number">33664</span> --name Knginx -v /mnt/nginx/:/etc/nginx/conf.d/ -d nginx</span><br></pre></td></tr></table></figure></p><p>简单说一下这个命令：这个容器名叫Knginx，hostname是Kngx，做了宿主机80端口到此容器33664端口的转发，将宿主机的<code>/mnt/nginx/</code>挂载到容器里的<code>/etc/nginx/conf.d/</code>，同时直接启动nginx。</p><p>启动成功之后，我们看到刚刚建立的<code>htpasswd.users</code>和<code>kibana.conf</code>都已经成功被Knginx容器配置上，然后打开浏览器，看看效果：<br><img src="/images/kibana21.gif" alt="办公室" title="kibana加载比较慢"></p><p>这样就达到了密码访问页面的效果，如果想加IP白名单呢，也可以直接在<code>kibana.conf</code>里补充相关配置，修改完毕之后，重启Knginx容器即可。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.hugeserver.com/kb/how-secure-kibana-nginx-centos/" target="_blank" rel="noopener">https://www.hugeserver.com/kb/how-secure-kibana-nginx-centos/</a></p>]]></content>
    
    <summary type="html">
    
      阿里云SLB自带白名单功能，可以通过SLB端口跳转到Kibana的5601端口的时候指定某些IP访问
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="kibana" scheme="http://yoursite.com/tags/kibana/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维工程师笔试题第十七套</title>
    <link href="http://yoursite.com/2019/02/19/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E4%B8%83%E5%A5%97/"/>
    <id>http://yoursite.com/2019/02/19/Linux运维工程师笔试题第十七套/</id>
    <published>2019-02-19T03:22:07.000Z</published>
    <updated>2019-02-28T12:20:03.806Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="试题内容">试题内容</span></h2><p>如果网站配置了多域名，要根据不同的域名分别https访问，应该怎么配置？<br>在rewrite的时候使用$host，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name www.test.com www.test.com.cn;</span><br><span class="line">        index index.html index.htm index.php;</span><br><span class="line">root /home/wwwroot;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                rewrite ^/(.*)$ https://$host/$<span class="number">1</span> permanent;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果是要笨一点的方法就是：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server  </span><br><span class="line">   &#123;  </span><br><span class="line">       listen       <span class="number">80</span>;  </span><br><span class="line">       server_name www.test.com www.test.com.cn;  </span><br><span class="line">       index index.html index.htm index.php;  </span><br><span class="line">       root /home/wwwroot;  </span><br><span class="line"> </span><br><span class="line">       <span class="keyword">if</span> ($host = <span class="string">'www.test.com.cn'</span> ) &#123;  </span><br><span class="line">               rewrite ^/(.*)$ https://www.test.com.cn/$<span class="number">1</span> permanent;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">if</span> ($host = <span class="string">'www.test.com'</span> ) &#123;  </span><br><span class="line">               rewrite ^/(.*)$ https://www.test.com/$<span class="number">1</span> permanent;  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>ps.阿里云的SLB绑定多个HTTPS证书的文档：<a href="https://help.aliyun.com/document_detail/87023.html?spm=a2c4g.11186623.6.741.7e11301bVLBAJz" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/87023.html?spm=a2c4g.11186623.6.741.7e11301bVLBAJz</a></p><p>2.在Nginx中，如何使用未定义的服务器名称来阻止处理请求?<br>只需将请求删除的服务器就可以定义为：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Server &#123;</span><br><span class="line">listen <span class="number">80</span>;</span><br><span class="line">server_name <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里，服务器名被保留为一个空字符串，它将在没有“主机”头字段的情况下匹配请求，而一个特殊的Nginx的非标准代码444被返回，从而终止连接。</p><p>3.ajax是同步还是异步，怎么样实现同步?<br>ajax里async属性默认的设置值为<code>true</code>，这种情况为<code>异步方式</code>。即网页里有两个函数func(x)和func(y)，在打开网页的时候，后台会先去执行func(x)，然后等待server返回结果，同时还有一个线程会去执行func(y)。</p><p>当把async设为<code>false</code>时，这时ajax的请求是<code>同步</code>的，也就是说，这个时候ajax块发出请求后，他会等待在func(x)这个地方，不会去执行func(y)，直到func(x)部分执行完毕。</p><p>4.nginx如何实现http跳转https?<br>需要用到地址重写代码，用以下代码能让http强制跳转到https:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    listen [::]:<span class="number">80</span>;<span class="comment">#支持ipv6</span></span><br><span class="line">    server_name www.test.com;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6.如果某个网站做了两个域名，分别是<a href="https://www.aaa.com和https://www.bbb.com，如果做了www.aaa.com" target="_blank" rel="noopener">https://www.aaa.com和https://www.bbb.com，如果做了www.aaa.com</a> cname到www.bbb.com，那么浏览器打开www.aaa.com会是什么界面？<br>打开页面会出现“https证书不正确”的风险提示。</p><p>7.接着上面问题，在nginx里做了rewrite或者配置了显性URL，此时取消掉www.aaa.com本身的ip（即www.aaa.com没有ip,但是www.bbb.com有ip），浏览器里打开www.aaa.com会是什么界面？<br>会显示“无法找到www.aaa.com的IP地址”（第一步就失败了…）。</p><p>8.要求<code>a.com</code>和<code>www.a.com</code>都跳到<code>www.b.com</code>，而<code>www.a.com/123</code>不跳，如何配置？<br>配置如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen   <span class="number">80</span>;</span><br><span class="line">        server_name www.a.com a.com;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#根目录跳转</span></span><br><span class="line">        location / &#123;</span><br><span class="line">                rewrite .+ http://www.b.com/ permanent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#非根目录本地执行</span></span><br><span class="line">        location ~* /.+ &#123;</span><br><span class="line">            <span class="comment">#已省略余下通用配置内容</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>9.为了安全，Web服务器不要求启用所有可用的方法，只允许<code>GET</code>，<code>HEAD</code>和<code>POST</code>方法，其他的全部过滤掉。实现其功能的代码如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ($request_method !~ ^(GET|HEAD|POST)$ ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>10.对/download/目录做“最大下载速度20K，同时最多2个并发链接的限制”<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">        limit_zone my_zone $binary_remote_addr <span class="number">10</span>m;<span class="comment">#在 http 段配置定义一个limit_zone</span></span><br><span class="line">        server &#123;</span><br><span class="line">                 location /download/ &#123;</span><br><span class="line">                                       limit_conn my_zone <span class="number">2</span>;<span class="comment">#limit_conn和 limit_rate参数进行限速设置</span></span><br><span class="line">                                       limit_rate <span class="number">20</span>k;</span><br><span class="line">                                     &#125;</span><br><span class="line">               &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><ol><li><code>limit_zone</code>:针对每个 IP 定义一个存储 session 状态的容器。本例中定义了一个my_zone的10m大小的容器。</li><li><code>limit_conn my_zone 2</code>：限制在my_zone中记录状态的每个IP只能发起2个并发连接。本例中，客户端访问/download目录时，会限制2个并发连接。 </li><li><code>limit_rate 20k</code>：对每个连接限速20k。注意，这里是对连接限速，而不是对IP限速。如果一个IP允许2个并发连接，那么这个IP就是限速为<code>limit_rate*2</code>，在设置的时候要根据自己的需要做设置调整。</li></ol><p>11.简单说明nginx配置文件里面alias和root的区别<br>Nginx配置文件server中指定两个location执行，分别为root和alias指令：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /test/ &#123;</span><br><span class="line">           alias /www/test/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照上述配置，则访问/test/目录里面的文件时，nginx会去<code>/www/test/</code>目录找文件：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /test/ &#123;</span><br><span class="line">          root /www/test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照这种配置，则访问/test/目录下的文件时，nginx会去<code>/www/test/test/</code>目录下找文件。</p><p>另一个区别是alias后面必须要用<code>/</code>结束，否则会找不到文件，而root则对<code>/</code>可有可无。</p><p>12.CDN缓存命中率下降的因素有哪些？</p><ol><li>客户是否刷新过缓存？<br>答：如果刷新缓存，有可能会短时间表现命中率下降。特别说明下：CDN的url或者目录刷新是清除CDN缓存的动作（这个比较容易理解偏差）</li><li>带宽是否突增？并且访问的都是新的URL？<br>答：带宽突增或者访问的新URL较多，会导致CDN节点回源较多，命中率会表现有下降趋势。</li><li>源站是否有新内容发布？<br>答：CDN节点访问新内容，导致CDN节点回源较多，命中率会表现有下降趋势。</li><li>源站是否出现过异常导致5XX和4XX增加，由于5XX和4XX不缓存，会表现命中率下降。</li><li>源站的访问url的header参数，或者在CDN控制管理后台的缓存配置规则是否改变过？<br>答：缓存时长的调整，有可能会带来命中率的变化。</li></ol><p>13.如果判断url是否命中CDN缓存？<br>查看响应头信息中的<code>X-Cache</code>字段。</p><ol><li>显示<code>MISS</code>，说明没有命中CDN缓存，是回源的。</li><li>显示<code>HIT</code>，是命中了CDN缓存。</li></ol><p>除了<code>X-Cache</code>还有如下几个参数与CDN有关：<br><code>X-Swift-SaveTime</code>：内容开始在CDN上缓存的时间。由于系统时间是GMT时间，所以需要折算成北京时间。<br><code>X-Swift-CacheTime</code>：CDN的默认缓存时间，以秒为单位。<br><code>Age</code>：该内容在CDN上已经缓存了的时间。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://my.oschina.net/mrpei123/blog/1794001" target="_blank" rel="noopener">https://my.oschina.net/mrpei123/blog/1794001</a><br><a href="http://note.qidong.name/2017/09/nginx-https-hsts/" target="_blank" rel="noopener">http://note.qidong.name/2017/09/nginx-https-hsts/</a><br><a href="https://www.ssllabs.com/ssltest/index.html（测试ssl安全的网站）" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest/index.html（测试ssl安全的网站）</a></p>]]></content>
    
    <summary type="html">
    
      这次是nginx和CDN相关的题目
    
    </summary>
    
      <category term="大牛之路" scheme="http://yoursite.com/categories/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="面试笔试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Logstash的正则匹配日志格式</title>
    <link href="http://yoursite.com/2019/02/15/%E4%BD%BF%E7%94%A8Logstash%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/02/15/使用Logstash的正则匹配日志格式/</id>
    <published>2019-02-15T09:00:13.000Z</published>
    <updated>2019-02-21T09:02:31.153Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="牛刀小试">牛刀小试</span></h2><p>在ELK里经常需要写正则来匹配日志里的的具体信息，这样可以在<code>kibana</code>上更加直观的观看，<code>grok</code>就是Logstash最重要的插件。你可以在grok里预定义好命名正则表达式，在稍后(grok参数或者其他正则表达式里)引用它。</p><p>grok的格式是：<code>%{SYNTAX:SEMANTIC}</code>，如果需要转义就要加上<code>\</code>。具体的grok匹配规则可以在logstash查看<code>grok-patterns</code>这个文件，如图：<br><img src="/images/grok2.png" alt="akb48"></p><ol><li><code>SYNTAX</code>代表匹配值的类型，例如，<code>0.11</code>可以<code>NUMBER</code>类型所匹配，<code>10.222.22.25</code>可以使用<code>IP</code>匹配。</li><li><code>SEMANTIC</code>表示存储该值的一个变量声明，它会存储在<code>elasticsearch</code>当中方便<code>kibana</code>做字段搜索和统计，你可以将一个<code>IP</code>定义为客户端IP地址<code>client_ip_address</code>，eg:<code>%{IP:client_ip_address}</code>，所匹配到的值就会存储到<code>client_ip_address</code>这个字段里边，类似数据库的列名。</li></ol><p>而检测grok正则的网站：<a href="http://grokdebug.herokuapp.com/" target="_blank" rel="noopener">http://grokdebug.herokuapp.com/</a> 。</p><p>举个例子，如果日志里是：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100.97</span><span class="number">.73</span><span class="number">.142</span> - - [<span class="number">15</span>/Feb/<span class="number">2019</span>:<span class="number">16</span>:<span class="number">54</span>:<span class="number">24</span> +<span class="number">0800</span>]</span><br></pre></td></tr></table></figure></p><p>可以看到里面有IP、日期、时间、时区，那么对比刚才的<code>grok-patterns</code>文件，就知道要匹配IP这个字段，就是用<code>IP (?:%{IPV6}|%{IPV4})</code>，IP即包含了IPV6也有IPV4，那么具体的匹配就是<code>%{IP:client}</code>，client是自己定义名称。同理，<code>[15/Feb/2019</code>这部分是日期，可以使用如下的配置规则：<br><img src="/images/grok3.png" alt="akb48"></p><p>如法炮制，匹配结果就是<code>\[%{MONTHDAY:day}/%{MONTH:month}/%{YEAR:year}</code>。</p><p>拿到检测网站试一下结果：<br><img src="/images/grok4.png" alt="akb48"></p><p>上面那个例子比较简单，比如匹配下面这样的一个日志：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2019</span><span class="number">-02</span><span class="number">-01</span>T08:<span class="number">59</span>:<span class="number">59.124</span>] [INFO] default - [<span class="number">115.63</span><span class="number">.121</span><span class="number">.10</span> GET /wap/_nuxt/vendor<span class="number">.61</span>a8f274bce0acb0de6d.js <span class="number">200</span> <span class="number">97</span>s][https://www.lechange.com/wap/node/goodDetail/<span class="number">264</span> HTTP/<span class="number">1.1</span> Mozilla/<span class="number">5.0</span> (Linux; Android <span class="number">8.1</span>; V1818A Build/OPM1<span class="number">.171019</span><span class="number">.026</span>; wv) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Version/<span class="number">4.0</span> Chrome/<span class="number">57.0</span><span class="number">.2987</span><span class="number">.132</span> MQQBrowser/<span class="number">6.2</span> TBS/<span class="number">044409</span> Mobile Safari/<span class="number">537.36</span>]</span><br></pre></td></tr></table></figure></p><p>那么写法就是：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20%&#123;YEAR:year&#125;-%&#123;MONTHNUM:month&#125;-%&#123;MONTHDAY:day&#125;T%&#123;HOUR:hour&#125;:?%&#123;MINUTE:minutes&#125;(?::?%&#123;SECOND:second&#125;)] \[%&#123;LOGLEVEL:level&#125;\] default - \[%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:status&#125; %&#123;NUMBER:duration&#125;s\]\[%&#123;DATA:data&#125;\]</span><br></pre></td></tr></table></figure></p><p>效果如图:<br><img src="/images/grok1.png" alt="akb48"></p><p><font color="red">但是要注意!</font>在网站上的匹配可能是OK的，但是在logstash的grok里是不可以有<code>-、&#39;、&quot;</code>等这样的字符出现，比如下面这个日志：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100.97</span><span class="number">.73</span><span class="number">.232</span> - - [<span class="number">15</span>/Feb/<span class="number">2019</span>:<span class="number">16</span>:<span class="number">54</span>:<span class="number">24</span> +<span class="number">0800</span>] <span class="string">"GET /public/app/site/statics/favicon.ico HTTP/1.1"</span> <span class="number">200</span> <span class="number">4286</span> <span class="string">"https://www.lechange.com/wap/"</span> <span class="string">"Mozilla/5.0 (Linux; Android 7.1.1; OPPO R11 Build/NMF26X; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/044409 Mobile Safari/537.36 Imou"</span></span><br></pre></td></tr></table></figure></p><p>虽然下面的规则是可以正确匹配的：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;IP:client&#125; - - \[%&#123;MONTHDAY:day&#125;/%&#123;MONTH:month&#125;/%&#123;YEAR:year&#125;:%&#123;HOUR:hour&#125;:%&#123;MINUTE:minutes&#125;:%&#123;SECOND:second&#125; \+<span class="number">0800</span>] \<span class="string">"%&#123;WORD:method&#125; %&#123;URIPATH:request&#125; HTTP/%&#123;NUMBER:httpversion&#125;"</span> %&#123;NUMBER:status&#125; %&#123;NUMBER:bytes&#125; <span class="string">"%&#123;DATA:website&#125;"</span> <span class="string">"%&#123;DATA:data&#125;"</span></span><br></pre></td></tr></table></figure></p><p>但是当你把这个配置复制到logstash.conf里的时候，启动logstash就会有参数不合法的报错：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2019</span><span class="number">-02</span><span class="number">-18</span>T17:<span class="number">33</span>:<span class="number">52</span>,<span class="number">060</span>][FATAL][logstash.runner          ] The given configuration <span class="keyword">is</span> invalid. Reason: Expected one of <span class="comment">#, &#123;, -, ", ', &#125; at line 32, column 218 (byte 1226) 。</span></span><br></pre></td></tr></table></figure></p><p>应该改成这样：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;IPORHOST:client_ip&#125; %&#123;USER:ident&#125; %&#123;USER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] "(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:http_version&#125;)?|-)" %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-) %&#123;QUOTEDSTRING:domain&#125; %&#123;QUOTEDSTRING:data&#125;</span><br></pre></td></tr></table></figure></p><p>一般来说对于字符串，有双引号包含的用QS，没有的用DATA类型，如<code>%{DATA:request_body}</code>。</p><h2><span id="grok配置到logstash">grok配置到logstash</span></h2><p>假设这个服务的日志输入到kafka里的topic叫<code>lcshop-log</code>，那么对应的logstash如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">        kafka&#123;</span><br><span class="line">                bootstrap_servers=&gt;"172.31.0.84:9092"#这里写的是kafka的ip和端口</span><br><span class="line">                topics=&gt;["lcshop-log","lcshop-errorlog"]#这里是对应的topic</span><br><span class="line">                decorate_events=&gt;"true"</span><br><span class="line">                codec=&gt;plain</span><br><span class="line">        &#125;       </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line"><span class="keyword">if</span> [@metadata][kafka][topic] == <span class="string">"lcshop-log"</span> &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">         add_field =&gt; &#123;"[@metadata][index]" =&gt; "lcshop-log-%&#123;+YYYY-MM&#125;"&#125;</span><br><span class="line">      &#125;  </span><br><span class="line">      grok &#123;</span><br><span class="line">         match =&gt; &#123; "message" =&gt; "%&#123;IPORHOST:client_ip&#125; %&#123;USER:ident&#125; %&#123;USER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] \"(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:http_version&#125;)?|-)\" %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-) %&#123;QUOTEDSTRING:domain&#125; %&#123;QUOTEDSTRING:data&#125;"&#125;</span><br><span class="line">         remove_field =&gt; ["message"]</span><br><span class="line"><span class="comment">#这里对双引号增加了转义符</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> [@metadata][kafka][topic] == <span class="string">"lcshop-errorlog"</span> &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">         add_field =&gt; &#123;"[@metadata][index]" =&gt; "lcshop-errorlog-%&#123;+YYYY-MM&#125;"&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123;</span><br><span class="line">               codec =&gt; rubydebug#日志输出，这个看情况开启，生成日志量非常可观！</span><br><span class="line">       &#125;</span><br><span class="line">       elasticsearch &#123;</span><br><span class="line">               hosts=&gt;["172.31.0.76:9200"]#这里是es的ip和端口</span><br><span class="line">               index=&gt;"%&#123;[@metadata][index]&#125;"#这里对不同的topic分配不同的index</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后去kibana里查看结果,然而会发现这是失败的。</p><p>为什么明明在grok的测试网站里通过了，但是在实际的kibana里却失败？这是因为在kibana里会自动给双引号添加一个转义符！正式因为多了这个转义符，所以整段正则都不匹配了，自然grok无法生效了。</p><p>这个时候需要改成这样：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%&#123;IPORHOST:clientip&#125; - %&#123;NOTSPACE:remote_user&#125; \[%&#123;HTTPDATE:timestamp&#125;\] \\<span class="string">"%&#123;DATA:request&#125;\\"</span> %&#123;NUMBER:response&#125; %&#123;NUMBER:bytes&#125; %&#123;DATA:data&#125; \\<span class="string">"%&#123;DATA:detail&#125;\\"</span></span><br></pre></td></tr></table></figure></p><p>重启logstash之后，再去kibana里看结果：<br><img src="/images/grok5.png" alt="akb48"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/filter/date.html" target="_blank" rel="noopener">https://doc.yonyoucloud.com/doc/logstash-best-practice-cn/filter/date.html</a><br><a href="https://segmentfault.com/q/1010000003801260" target="_blank" rel="noopener">https://segmentfault.com/q/1010000003801260</a><br><a href="https://www.cnblogs.com/Orgliny/p/5592186.html" target="_blank" rel="noopener">https://www.cnblogs.com/Orgliny/p/5592186.html</a><br><a href="http://kuring.me/post/elk_nginx/" target="_blank" rel="noopener">http://kuring.me/post/elk_nginx/</a><br><a href="http://blog.51cto.com/seekerwolf/2106509" target="_blank" rel="noopener">http://blog.51cto.com/seekerwolf/2106509</a><br><a href="http://blog.51cto.com/liqingbiao/1928653" target="_blank" rel="noopener">http://blog.51cto.com/liqingbiao/1928653</a><br><a href="https://www.jianshu.com/p/d46b911fb83e" target="_blank" rel="noopener">https://www.jianshu.com/p/d46b911fb83e</a></p>]]></content>
    
    <summary type="html">
    
      grok里匹配的message其实是整个message这个field而不是里面message那个节点！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="elk" scheme="http://yoursite.com/tags/elk/"/>
    
      <category term="logstash" scheme="http://yoursite.com/tags/logstash/"/>
    
      <category term="正则表达式" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维工程师笔试题第十六套</title>
    <link href="http://yoursite.com/2019/02/13/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%AC%94%E8%AF%95%E9%A2%98%E7%AC%AC%E5%8D%81%E5%85%AD%E5%A5%97/"/>
    <id>http://yoursite.com/2019/02/13/Linux运维工程师笔试题第十六套/</id>
    <published>2019-02-13T04:13:20.000Z</published>
    <updated>2019-02-27T02:02:41.080Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="试题内容">试题内容</span></h2><p>1.Mysql的bin-log有几种形式？分析其特点<br><code>Statement Level</code>模式:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简介：每一条会修改数据的sql都会记录到master的bin-log中。Slave在复制的时候sql线程会解析成和原来master端执行过的相同语句来执行。</span><br><span class="line">优点：不需要记录每一行数据的变化，减少bin-log的日志量，节约IO，提高性能。因为他只记录在master上所执行语句的细节，以及执行语句时候的上下文的信息。</span><br><span class="line">缺点：很多新功能的加入在复制的时候容易导致出现问题。</span><br></pre></td></tr></table></figure></p><p><code>Row Level</code>模式:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简介:日志中会记录成每一行数据被修改的模式，然后再slave 端在对相同的数据进行修改。</span><br><span class="line">优点：在row level模式下，bin-log中可以不记录执行的sql语句的上下文相关的信息。仅仅只需要记录那一条记录被修改了。所以row level的日志内容会非常清楚记录下每一行数据修改的细节，非常容易理解。而且不会出现某些特点情况下的存储过程，或function 以及triggeer的调用和触发无法被正确复制的问题。</span><br><span class="line">缺点：所有执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，可能会产生大量的日志。</span><br></pre></td></tr></table></figure></p><p><code>Mixed</code>(前两种的混合模式):<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据执行的每一条具体的sql语句来区分对待记录日志的形式，即Mysql决定什么时候写statement格式的，什么时候写row格式的binlog。；</span><br></pre></td></tr></table></figure></p><p>2.如何在线正确清理MySQL的binlog？<br>手动删除方法如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#首先查看主从库正在使用的binlog文件名称 </span></span><br><span class="line">show master(slave) status\G</span><br><span class="line"><span class="comment">#删除之前一定要备份</span></span><br><span class="line">purge master logs before<span class="string">'2017-09-01 00:00:00'</span>; </span><br><span class="line"><span class="comment">#删除指定时间前的日志</span></span><br><span class="line">purge master logs to<span class="string">'mysql-bin.000001'</span>;</span><br></pre></td></tr></table></figure></p><p>自动删除的方法如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过设置binlog的过期时间让系统自动删除日志</span></span><br><span class="line"><span class="comment">#查看过期时间与设置过期时间</span></span><br><span class="line">show variables like <span class="string">'expire_logs_days'</span>; </span><br><span class="line">set <span class="keyword">global</span> expire_logs_days = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></p><p><code>binlog</code>记录了数据中的数据变动，便于对数据的基于时间点和基于位置的恢复。但是也要定时清理，不然越来越大。</p><p>3.简述MySQL主从复制原理及配置主从的完整步骤。<br>MySQL主从是一个异步过程（网络条件上佳的话，同步效果几乎是实时），原理就是从库得到主库的<code>binlog</code>，然后执行这个<code>binlog</code>的内容，达到两边数据库数据一致的目的。具体工作步骤如下：</p><ol><li>主mysql服务器将数据库更新记录到binlog中，使用自己的<code>log dump</code>线程将<code>binlog</code>先读取然后加锁，再发送到从库，在从库当读取完成，甚至在发动给从节点之前，锁会被释放；</li><li>当从库上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的<code>binlog</code>。I/O线程接收到主节点<code>binlog dump</code>进程发来的更新之后，保存在本地<code>relay log</code>中。</li><li>从库此时还有一个SQL线程，它负责读取<code>relay log</code>中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。<br><img src="/images/mysql-sock9.png" alt="akb48"></li></ol><font color="red">切记！</font>在从库上使用<code>show slave status\G；</code>看到结果里的<code>Slave_IO_Running:Yes</code>和<code>Slave_SQL_Running:Yes</code>，才算是同步成功，两个YES缺一不可。<br><br>注意！MySQL只读实例的Binlog日志是没有记录更新信息的，所以它的Binlog无法使用。<br><br>4.如何理解MySQL里最大连接数和请求数之间的关系<br>假设某个数据库的最大连接数是1000，并不是指最多只能支持1000个访问，因为数据库与应用之间肯定会隔着中间件，这个中间件的连接池会管理链接，一般如果代码写的好、事物控制得当，一个事物完成连接会被连接池收回重复利用，所以不是说一个用户登录你的系统或网站就一直占用着，一个连接也可以包含多次请求。<br><br>5.MySQL出现IOPS过高，应该如何处理？<br>IOPS (Input/Output Operations Per Second)，即每秒进行读写（I/O）操作的次数。IOPS是指存储每秒可接受多少次主机发出的访问，主机的一次IO需要多次访问存储才可以完成。IOPS过高比较普遍的原因是<code>实例内存满足不了缓存数据或排序等需要，导致产生大量的物理IO</code>或者是<code>查询执行效率低，扫描过多数据行</code>。<br><br>6.Sort_Buffer_Size是什么参数？设置它对服务器性能有何影响？<br><code>Sort_Buffer_Size</code>是一个connection级参数，在每个connection第一次需要使用这个buffer的时候，一次性分配设置的内存。<code>Sort_Buffer_Size</code>并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。<code>Sort_Buffer_Size</code>超过256KB的时候，MySQL就会使用<code>mmap()</code>而不是<code>malloc()</code>来进行内存分配，导致性能损耗、效率降低。<br><br>如果列长度大于<code>max_length_for_sort_data</code>的参数值的话，<code>iowait</code>会增加, 响应时间明显变长。此时通过<code>show processlist</code>查看,发现有很多session在处理sort操作,此时需要适当调大<code>max_length_for_sort_data</code>的参数值。<br><br>7.如何从MySQL全库备份中恢复某个库和某张表<br>主要用到的参数是–one-database简写-o的参数，举个例子：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">全库备份</span><br><span class="line">[root@HE1 ~]<span class="comment"># mysqldump -uroot -p --single-transaction -A --master-data=2 &gt;dump.sql</span></span><br><span class="line">只还原erp库的内容</span><br><span class="line">[root@HE1 ~]<span class="comment"># mysql -uroot -pMANAGER erp --one-database &lt;dump.sql</span></span><br></pre></td></tr></table></figure><br><br>从全库备份中抽取出t表的表结构:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -e<span class="string">'/./&#123;H;$!d;&#125;'</span> -e <span class="string">'x;/CREATE TABLE `t`/!d;q'</span> dump.sql</span><br></pre></td></tr></table></figure><br><br>从全库备份中抽取出t表的内容:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep<span class="string">'INSERT INTO `t`'</span> dump.sql</span><br></pre></td></tr></table></figure><br><br>8.随意举出一次解决Mysql故障的事例<br>Mysql反应很慢，发现服务器CPU飙升，出现僵尸进程但是连接数并不高，<code>show processlist</code>发现有大量的<code>unauthenticated user</code>。通过更改配置文件<code>/etc/my.cnf</code>里的在[mysqld]那一栏中添加<code>skip-name-resolve</code>，然后重启mysql即可解决。<br><br><font color="red">注意！</font> <code>skip-name-resolve</code>可以禁用dns解析，但是，这样不能在mysql的授权表中使用主机名了，只能使用IP。以前创建mysql用户是若用的是localhost现在则需要用127.0.0.1来代替在grant语句中执行一下添加该用户。<br><br>当然CPU飙升还有其他情况：查询以及大批量的插入或者是网络状态突然断了,导致一个请求服务器只接受到一半…<br><br>9.你们数据库是否支持emoji表情，如果不支持，如何操作？<br>如果是<code>utf8</code>字符集的话，需要升级至<code>utf8_mb4</code>方可支持。<br><br>10.mysqldump备份时，–master-data选项的作用是什么？还用过其他的参数么？<br><code>--master-data</code>选项的作用就是将二进制的信息写入到输出文件中，即写入备份的sql文件中。<br>1. <code>--master-data=2</code>表示在dump过程中记录主库的binlog和pos点，并在dump文件中注释掉这一行；<br>2. <code>--master-data=1</code>表示在dump过程中记录主库的binlog和pos点，并在dump文件中不注释掉这一行，即恢复时会执行；<br>3. <code>--dump-slave=2</code>表示在dump过程中，在从库dump，mysqldump进程也要在从库执行，记录当时主库的binlog和pos点，并在dump文件中注释掉这一行；<br>4. <code>--dump-slave=1</code>表示在dump过程中，在从库dump，mysqldump进程也要在从库执行，记录当时主库的binlog和pos点，并在dump文件中不注释掉这一行；<br><font color="red">注意!</font>在从库上执行备份时，即–dump-slave=2，这时整个dump过程都是stop io_thread的状态<br><br>加了<code>--single-transaction</code>就能保证innodb的数据是完全一致的，而myisam引擎无法保证（因为myisam压根就不支持事务），要保证myisam引擎数据一致必须加<code>--lock-all-tables</code>。<br><br>11.什么是数据库事务，事务有哪些特性？<br>一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</span><br><span class="line">当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</span><br></pre></td></tr></table></figure><br><br>它的特性如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</span><br><span class="line">一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</span><br><span class="line">隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</span><br><span class="line">持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。</span><br></pre></td></tr></table></figure><br><br><font color="red">事务的原子性与一致性缺一不可。</font><p>12.数据表student有id,name,score,city字段，其中name中的名字可有重复，需要消除重复行,请写sql语句<br>语句如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct name <span class="keyword">from</span> student</span><br></pre></td></tr></table></figure></p><p><font color="red">注意！</font>单独的<code>distinct</code>只能放在开头，否则就报语法错误。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.cnblogs.com/wajika/p/6718552.html" target="_blank" rel="noopener">https://www.cnblogs.com/wajika/p/6718552.html</a><br><a href="https://www.hollischuang.com/archives/898" target="_blank" rel="noopener">https://www.hollischuang.com/archives/898</a><br><a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50597960</a><br><a href="https://segmentfault.com/a/1190000008663001" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008663001</a><br><a href="https://segmentfault.com/a/1190000000616820" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000616820</a><br><a href="http://seanlook.com/2014/12/05/mysql_mysqldump_options_examples/" target="_blank" rel="noopener">http://seanlook.com/2014/12/05/mysql_mysqldump_options_examples/</a><br><img src="/images/赌博默示录.jpg" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      都是与数据库mysql相关的问题
    
    </summary>
    
      <category term="大牛之路" scheme="http://yoursite.com/categories/%E5%A4%A7%E7%89%9B%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>ES对应Kafka的topic生成不同的Index</title>
    <link href="http://yoursite.com/2019/01/30/ES%E5%AF%B9%E5%BA%94kafka%E7%9A%84topic%E7%94%9F%E6%88%90index/"/>
    <id>http://yoursite.com/2019/01/30/ES对应kafka的topic生成index/</id>
    <published>2019-01-30T08:57:45.000Z</published>
    <updated>2019-02-15T08:29:47.999Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>假设有两个模块分别叫shopauth和shoporder，日志文件也对应分别是<code>shopauth.log</code>和<code>shoporder.log</code>，现在需要把日志对应放到同个kafka里不同的topic里。</p><p>shopauth的<code>filebeat.yml</code>内容如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: true</span><br><span class="line">  paths:</span><br><span class="line">    - /mnt/shopauth/logs/shopauth.log#日志路径</span><br><span class="line">  tags: ["logmessages"]</span><br><span class="line">  encoding: utf-8</span><br><span class="line">  scan_frequency: 10s</span><br><span class="line">  harvester_buffer_size: 15000</span><br><span class="line">  tail_files: true</span><br><span class="line">  fields:</span><br><span class="line">    alilogtype: app_log</span><br><span class="line">    serverip: 172.16.0.201#本地IP地址</span><br><span class="line">log_topics: ecnode-log</span><br><span class="line"></span><br><span class="line">output.kafka:</span><br><span class="line">  enabled: true</span><br><span class="line">  hosts: ["172.31.0.84:9092"]#指定kafka的地址信息</span><br><span class="line">  topic: '%&#123;[fields][log_topics]&#125;'#自动识别topic</span><br></pre></td></tr></table></figure></p><p>如果只有一个log源输入日志（不是指paths只有一个路径，paths可以同时指定多个路径），那么<code>output.kafka</code>的topic当然可以写死。如果是多个log源写入日志，而且又要对应输入到kafka的topic里，可以使用<code>&#39;%{[fields][log_topics]}&#39;</code>，达到自动识别的目的。</p><p><font color="red">但是要注意！</font>如果加上了<code>fields_under_root: true</code>，那么<code>&#39;%{[fields][log_topics]}&#39;</code>是错误的，要改成<code>topic: &quot;%{[log_topic]}&quot;</code>才可以。</p><p>shoporder的<code>filebeat.yml</code>内容如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /mnt/shoporder/logs/shoporder.log#指定路径</span><br><span class="line">  tags: [<span class="string">"logmessages"</span>]</span><br><span class="line">  encoding: utf<span class="number">-8</span></span><br><span class="line">  scan_frequency: <span class="number">10</span>s</span><br><span class="line">  harvester_buffer_size: <span class="number">15000</span></span><br><span class="line">  tail_files: <span class="literal">true</span></span><br><span class="line">  fields:</span><br><span class="line">    alilogtype: app_log</span><br><span class="line">    serverip: 172.16.0.207#本地IP地址</span><br><span class="line"></span><br><span class="line">output.kafka:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  hosts: ["172.31.0.84:9092"]#指定kafka的地址信息</span><br><span class="line">  topic: 'shoporder-log'#指定topic</span><br></pre></td></tr></table></figure></p><p>启动filebeat和kafka，kafka的配置这里略过不表。在kafka里查看，发现已经生成对应的topic：<br><img src="/images/elk21.png" alt="akb48"></p><p>而<code>logstash.yml</code>内容如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">        kafka&#123;</span><br><span class="line">                bootstrap_servers=&gt;"172.31.0.84:9092"#指定kafka的IP和端口</span><br><span class="line">                topics=&gt;["shoporder-log","shopauth-log"]#说明从这两个topic里消费</span><br><span class="line">                decorate_events=&gt;"true"#这个很重要，等会细说</span><br><span class="line">                codec=&gt;plain</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter &#123;#利用kafka域的内容构建自定义的域</span><br><span class="line">   if [@metadata][kafka][topic] == "shopauth-log" &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">         add_field =&gt; &#123;"[@metadata][index]" =&gt; "shopauth-log-%&#123;+YYYY-MM&#125;"&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; else if [@metadata][kafka][topic] == "shoporder-log" &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">         add_field =&gt; &#123;"[@metadata][index]" =&gt; "shoporder-log-%&#123;+YYYY-MM&#125;"&#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">                hosts=&gt;["172.31.0.76:9200"]#指定es的IP和端口</span><br><span class="line">                index=&gt;"%&#123;[@metadata][index]&#125;"#对应生成各自的index</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说一下<code>decorate_events</code>，如果只用了单个logstash，订阅了多个主题，你肯定希望在es中为不同主题创建不同的索引，那么<code>decorate_events</code>就是你想要的配置项。这个值默认是<code>false</code>，当指定这个选项为<code>true</code>时，会附加kafka的一些信息到<code>logstash event</code>的一个名为kafka的域（<code>Metadata fields</code>）中，然后再通过filter进行判断，如果是从<code>shopauth-log</code>这个topic得到信息，就把index设定成<code>shopauth-log-%{+YYYY-MM}&quot;</code>。</p><p>启动logstash，待其正常之后，在es的控制台查看日志，发现index索引已经成功生成：<br><img src="/images/elk22.png" alt="akb48"></p><p>现在在kibana里就可以创建索引然后查找了！</p>]]></content>
    
    <summary type="html">
    
      如果MP4文件放到OSS云存储里，只有声音没有图像，那么需要将格式从mpeg4改成h264
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="elk" scheme="http://yoursite.com/tags/elk/"/>
    
      <category term="logstash" scheme="http://yoursite.com/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>解决html里单引号转义的问题</title>
    <link href="http://yoursite.com/2019/01/23/%E8%A7%A3%E5%86%B3html%E9%87%8C%E5%8D%95%E5%BC%95%E5%8F%B7%E8%BD%AC%E4%B9%89%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/23/解决html里单引号转义的问题/</id>
    <published>2019-01-23T08:45:08.000Z</published>
    <updated>2019-01-25T08:35:37.098Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="正文">正文</span></h2><p>在使用Django展现页面的时候，会出现这样的一个需求：</p><p>我们在<code>views.py</code>里获取到的一个数组，比如叫name，内容是：<code>[&#39;james&#39;,&#39;wade&#39;,&#39;bosh&#39;,&#39;yaoming&#39;]</code>，然后<code>return render_to_response(&#39;a.html&#39;,{&#39;names&#39;:name,})</code>，让<code>a.html</code>可以使用到这个name数组。若在<code>a.html</code>里需要对这个name数组进行for循环展示，正常思路的话，js如下：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function test()</span><br><span class="line">&#123;</span><br><span class="line">var name="&#123;&#123;names&#125;&#125;".split(",")</span><br><span class="line">alert(name)</span><br><span class="line">进行for循环，略过不表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么得到的会是如下效果：<br><img src="/images/django43.png" alt="akb48"></p><p>可见虽然name在<code>views.py</code>里是list，但是传入到html是一个字符串，对于字符串使用split按照逗号分隔。而html里会把单引号转义成了<code>&amp;#39;</code>，而<code>&amp;#39;</code>这个玩意儿比较恶心，它不能被<code>JSON.parse</code>加工成一个数组，进而不能被for循环。</p><p>那么遇到这种问题怎么办?改成这样：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test()</span><br><span class="line">&#123;</span><br><span class="line">var str="&#123;&#123;names&#125;&#125;".replace(/&amp;#39;/g,'"')</span><br><span class="line">   var name=JSON.parse(str)</span><br><span class="line">  alert(name)</span><br><span class="line">进行for循环，略过不表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行效果如下：<br><img src="/images/django44.png" alt="akb48"><br>上面代码首先先把所有的单引号replace成双引号，<font color="red">Html是不会转义双引号的</font>，所以就可以正常使用了。</p><p>当然如果<code>views.py</code>里提供的name直接是双引号的话，就不用这么折腾了。</p><h2><span id="数组如何使用双引号而不是单引号">数组如何使用双引号而不是单引号</span></h2><p>python默认生成数组是单引号的，也就是说是<code>[&#39;apple&#39;,&#39;banana&#39;,&#39;candy&#39;</code>]的样子，而不会自动生成<code>[&quot;apple&quot;,&quot;banana&quot;,&quot;candy&quot;]</code>，这一点是不能改变的。那么要获得到双引号的数组，比较好的办法是json：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>names = [<span class="string">'james'</span>,<span class="string">'wade'</span>,<span class="string">'bosh'</span>,<span class="string">'yaoming'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(names))</span><br><span class="line">[<span class="string">"james"</span>, <span class="string">"wade"</span>, <span class="string">"bosh"</span>,<span class="string">"yaoming"</span>]</span><br></pre></td></tr></table></figure></p><p>如果元素是中文的话，那么就要用<code>(json.dumps(names,ensure_ascii=False))</code>。</p><h2><span id="与正文内容无关的补充">与正文内容无关的补充</span></h2><p><code>Centos 7</code>修改中文字符集的方法：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localedef -c -f UTF<span class="number">-8</span> -i zh_CN zh_CN.UTF<span class="number">-8</span></span><br><span class="line"><span class="keyword">export</span> LC_ALL=zh_CN.UTF<span class="number">-8</span></span><br><span class="line">echo <span class="string">'LANG="zh_CN.UTF-8"'</span> &gt; <span class="regexp">/etc/</span>locale.conf</span><br></pre></td></tr></table></figure></p><p><img src="/images/里皮.gif" alt="akb48" title="冯潇霆失误后，气急败坏的里皮"></p>]]></content>
    
    <summary type="html">
    
      这样就不用把数据时刻都往数据库里塞了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>将本地时间转化成UTC时间</title>
    <link href="http://yoursite.com/2019/01/22/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E8%BD%AC%E5%8C%96%E6%88%90UTC%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2019/01/22/将本地时间转化成UTC时间/</id>
    <published>2019-01-22T05:56:46.000Z</published>
    <updated>2019-01-22T08:06:39.478Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="实际代码">实际代码</span></h2><p>在日常工作中，有些时候需要把本地时间转换成UTC时间，通常来说，最直接的方法就是把北京时间（<code>CST时间</code>）减去8小时，但是如果考虑到夏令时，那么这样简单的数学计算就会得到错误的结果。要解决这种涉及时区的问题，就要使用特殊的模块<code>pytz</code>。<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.6</span><span class="number">.4</span> (default, Sep  <span class="number">3</span> <span class="number">2018</span>, <span class="number">10</span>:<span class="number">11</span>:<span class="number">51</span>) </span><br><span class="line">[GCC <span class="number">4.8</span><span class="number">.5</span> <span class="number">20150623</span> (Red Hat <span class="number">4.8</span><span class="number">.5</span><span class="number">-28</span>)] on linux</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime,time,pytz    <span class="comment">#引入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)     <span class="comment">#得到当前时间</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line"><span class="string">'2019-01-22 14:03:03'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(now)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;     #此时类型是字符串</span></span><br><span class="line">&gt;&gt;&gt; now = datetime.datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.datetime(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">14</span>, <span class="number">4</span>, <span class="number">49</span>, <span class="number">707859</span>)     <span class="comment">#转换成datetime模式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(now)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">datetime</span>.<span class="title">datetime</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; utc_time = now.astimezone(pytz.utc)    #转换成了UTC时间就不要用担心夏令时等等麻烦事了</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(utc_time)</span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-22</span> <span class="number">06</span>:<span class="number">04</span>:<span class="number">49.707859</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(utc_time)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">datetime</span>.<span class="title">datetime</span>'&gt;     #还需要将<span class="title">datetime</span>格式转换成<span class="title">str</span></span></span><br><span class="line">&gt;&gt;&gt; utc_now = utc_time.strftime('%Y-%m-%d %H:%M:00')</span><br><span class="line"><span class="string">'2019-01-22 13:57:00'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(utc_now)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;     #此时返回了字符串</span></span><br></pre></td></tr></table></figure></p><p>上面的代码说明了过程，以及得到的东西的类型，其实精简下来只有三行：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> datetime,time,pytz</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_time = now.astimezone(pytz.utc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_now = utc_time.strftime(<span class="string">'%Y-%m-%dT%H:%M:00Z'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (utc_now)</span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-22</span>T06:<span class="number">46</span>:<span class="number">00</span>Z</span><br></pre></td></tr></table></figure></p><p>如果要查时区名称，可以使用<code>pytz.country_timezones</code>，如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pytz <span class="keyword">import</span> timezone </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pytz.country_timezones[<span class="string">'CN'</span>]</span><br><span class="line">[<span class="string">'Asia/Shanghai'</span>, <span class="string">'Asia/Urumqi'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pytz.country_timezones[<span class="string">'US'</span>]</span><br><span class="line">[<span class="string">'America/New_York'</span>, <span class="string">'America/Detroit'</span>, <span class="string">'America/Kentucky/Louisville'</span>, <span class="string">'America/Kentucky/Monticello'</span>, <span class="string">'America/Indiana/Indianapolis'</span>, <span class="string">'America/Indiana/Vincennes'</span>, <span class="string">'America/Indiana/Winamac'</span>, <span class="string">'America/Indiana/Marengo'</span>, <span class="string">'America/Indiana/Petersburg'</span>, <span class="string">'America/Indiana/Vevay'</span>, <span class="string">'America/Chicago'</span>, <span class="string">'America/Indiana/Tell_City'</span>, <span class="string">'America/Indiana/Knox'</span>, <span class="string">'America/Menominee'</span>, <span class="string">'America/North_Dakota/Center'</span>, <span class="string">'America/North_Dakota/New_Salem'</span>, <span class="string">'America/North_Dakota/Beulah'</span>, <span class="string">'America/Denver'</span>, <span class="string">'America/Boise'</span>, <span class="string">'America/Phoenix'</span>, <span class="string">'America/Los_Angeles'</span>, <span class="string">'America/Anchorage'</span>, <span class="string">'America/Juneau'</span>, <span class="string">'America/Sitka'</span>, <span class="string">'America/Metlakatla'</span>, <span class="string">'America/Yakutat'</span>, <span class="string">'America/Nome'</span>, <span class="string">'America/Adak'</span>, <span class="string">'Pacific/Honolulu'</span>]</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.cnblogs.com/cathouse/archive/2012/11/19/2777678.html" target="_blank" rel="noopener">https://www.cnblogs.com/cathouse/archive/2012/11/19/2777678.html</a><br><a href="https://blog.csdn.net/junli_chen/article/details/52999448" target="_blank" rel="noopener">https://blog.csdn.net/junli_chen/article/details/52999448</a><br>《Python cookbook》字符串如何转化成日期<br>《Python cookbook》处理设计到市区的日期问题</p>]]></content>
    
    <summary type="html">
    
      遇到转换时区的事情真是够蛋疼的！
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python3" scheme="http://yoursite.com/tags/python3/"/>
    
      <category term="UTC时间" scheme="http://yoursite.com/tags/UTC%E6%97%B6%E9%97%B4/"/>
    
      <category term="时区转换" scheme="http://yoursite.com/tags/%E6%97%B6%E5%8C%BA%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>较深入解析filebeat.yml各字段功能</title>
    <link href="http://yoursite.com/2019/01/21/%E8%BE%83%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90filebeat-yml%E5%90%84%E5%AD%97%E6%AE%B5%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2019/01/21/较深入解析filebeat-yml各字段功能/</id>
    <published>2019-01-21T12:31:46.000Z</published>
    <updated>2019-01-25T08:01:57.385Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>首先，6.0之后的版本的<code>filebeat</code>，已经不再支持<code>document_type</code>这个选项了。因为ES6不再支持自己在同一个index下定义多个type。 </p><h2><span id="常见的几个参数">常见的几个参数</span></h2><p>以下面这个<code>filebeat.yml</code>为例：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log#这个值可以是stdin(读入标准)、udp（通过udp读取事件）</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/messages#指定文件，可以使用通配符</span><br><span class="line">  tags: ["logmessages"]#lostash能区分不同目录发过来的日志，用tag区分</span><br><span class="line">  encoding: utf-8#设置字符编码</span><br><span class="line">  scan_frequency: 10s#每 10 秒钟扫描一次</span><br><span class="line">  harvester_buffer_size: 15000#实际读取文件时，每次读取15000字节</span><br><span class="line">  tail_files: true#是否从文件末尾开始读取</span><br><span class="line">  fields:  </span><br><span class="line">    alilogtype: usercenter_serverlog</span><br><span class="line">    serverip: <span class="number">172.16</span><span class="number">.0</span><span class="number">.207</span></span><br><span class="line">  fields_under_root: true #field 字段会放在根索引下，否则会放在 fields 字段下</span><br><span class="line"></span><br><span class="line">#这里添加第二个日志路径</span><br><span class="line">  - type: log</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - <span class="regexp">/tmp/</span>test.log</span><br><span class="line">  tags: [<span class="string">"test"</span>]</span><br><span class="line"></span><br><span class="line">output.kafka:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  hosts: [<span class="string">"172.31.0.84:9092"</span>]</span><br><span class="line">  topic: 'system-secure'#支持 topic: '%&#123;[fields][alilogtype]&#125;' 这种写法</span><br></pre></td></tr></table></figure></p><p>在kibana上看到的效果如图：<br><img src="/images/filebeat1.png" alt="akb48"></p><h2><span id="exclude和include">exclude和include</span></h2><p>而如果是这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- type: log</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - <span class="regexp">/tmp/</span>test.log</span><br><span class="line">  exclude_lines: ['^JAMES']#排除掉JAMES开头的行</span><br><span class="line">  include_lines: ['^HARDEN', '^CURRY']      #保留HARDEN或者CURRY开头的行        </span><br><span class="line">  tags: [<span class="string">"test"</span>]</span><br><span class="line"></span><br><span class="line">output.kafka:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  hosts: [<span class="string">"172.31.0.84:9092"</span>]</span><br><span class="line">  topic: <span class="string">'system-secure'</span></span><br></pre></td></tr></table></figure></p><p>效果如图：<br><img src="/images/filebeat2.png" alt="akb48"></p><p>注意！如果同时定义了<code>include_lines</code>和<code>exclude_lines</code>，则<code>Filebeat</code>首先执行<code>include_lines</code>，然后执行<code>exclude_lines</code>。 这两个选项的定义顺序无关紧要。 即使<code>exclude_lines</code>出现在配置文件中的<code>include_lines</code>之前，<code>include_lines</code>选项也会始终在<code>exclude_lines</code>选项之前执行。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.xiaot123.com/post/elk_filebeat1" target="_blank" rel="noopener">http://www.xiaot123.com/post/elk_filebeat1</a><br><a href="https://blog.csdn.net/u013613428/article/details/78665081" target="_blank" rel="noopener">https://blog.csdn.net/u013613428/article/details/78665081</a><br><a href="http://www.51niux.com/?id=204" target="_blank" rel="noopener">http://www.51niux.com/?id=204</a><br><a href="https://github.com/wangriyu/docker-elk/wiki/Filebeat-Kafka-ELK" target="_blank" rel="noopener">https://github.com/wangriyu/docker-elk/wiki/Filebeat-Kafka-ELK</a></p>]]></content>
    
    <summary type="html">
    
      未完待续...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="elk" scheme="http://yoursite.com/tags/elk/"/>
    
      <category term="filebeat" scheme="http://yoursite.com/tags/filebeat/"/>
    
  </entry>
  
  <entry>
    <title>将kafka加入到Elk集群</title>
    <link href="http://yoursite.com/2019/01/21/%E5%B0%86kafka%E5%8A%A0%E5%85%A5%E5%88%B0Elk%E9%9B%86%E7%BE%A4/"/>
    <id>http://yoursite.com/2019/01/21/将kafka加入到Elk集群/</id>
    <published>2019-01-21T07:08:31.000Z</published>
    <updated>2019-02-01T03:37:33.707Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="环境交代">环境交代</span></h2><p>架构如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（目标模块 ---&gt;filebeat） ---&gt;（kafka ---&gt;logstash） ---&gt;（es ---&gt;kibana）</span><br></pre></td></tr></table></figure></p><p>具体服务器信息如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">172.16</span><span class="number">.0</span><span class="number">.207</span>工作模块+filebeatCentOS <span class="number">7.4</span> <span class="number">64</span>位阿里云<span class="number">1</span>核<span class="number">2</span>G</span><br><span class="line"><span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>kafka+logstashCentOS <span class="number">7.4</span> <span class="number">64</span>位阿里云<span class="number">2</span>核<span class="number">4</span>G</span><br><span class="line"><span class="number">172.31</span><span class="number">.0</span><span class="number">.76</span>es+es-head+kibanaCentOS <span class="number">7.4</span> <span class="number">64</span>位阿里云<span class="number">2</span>核<span class="number">16</span>G</span><br><span class="line">安全组已经开放了elk相应的端口</span><br></pre></td></tr></table></figure></p><p>首先先执行<code>yum update -y &amp;&amp; yum install java-1.8.0-openjdk* -y</code>，在更新的时候不要闲着，在<code>https://www.elastic.co/downloads</code>网站下载所有的elk模块，然后上传到对应的服务器里。 </p><h2><span id="filebeat的部署-配置和启动">filebeat的部署、配置和启动</span></h2><p>filebeat与目标机器安装在一起，它是用<code>6.5.4</code>版本，先从官网上下载rpm包，然后上传到服务器里。<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#假设已经下载好了filebeat-6.5.4-x86_64.rpm</span><br><span class="line">rpm -ivh filebeat<span class="number">-6.5</span><span class="number">.4</span>-x86_64.rpm</span><br><span class="line">cd /etc/filebeat</span><br><span class="line">cp filebeat.yml filebeat.yml-default#备份模板配置文件</span><br></pre></td></tr></table></figure></p><p>修改<code>filebeat.yml</code>如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  paths:</span><br><span class="line">    - /var/log/messages#设定日志输入源</span><br><span class="line"></span><br><span class="line">output.kafka:</span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  hosts: ["172.31.0.84:9092"]#这里填入kafka的地址和端口</span><br><span class="line">  topic: 'system-secure'#指定一个topic</span><br></pre></td></tr></table></figure></p><p>配置文件说明了数据的来源和目的地，使用<code>/etc/init.d/filebeat start -e -c /etc/filebeat/filebeat.yml</code>启动filebeat，然后<code>ps -aux|grep filebeat</code>查看一下进程。而filebeat的日志地址是在<code>/var/log/filebeat</code>目录下。</p><h2><span id="logstash的部署-配置和启动">logstash的部署、配置和启动</span></h2><p>logstash是跟kafka在一台服务器里，首先是下载包并且解压缩：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//artifacts.elastic.co/downloads/logstash/logstash-6.5.4.tar.gz</span></span><br><span class="line">tar -zxvf logstash<span class="number">-6.5</span><span class="number">.4</span>.tar.gz -C /opt/</span><br><span class="line">cd /opt/logstash<span class="number">-6.5</span><span class="number">.4</span>/config</span><br></pre></td></tr></table></figure></p><p>新建一个配置文件，叫<code>logstash_kafka2ES.conf</code>：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">        kafka&#123;</span><br><span class="line">                bootstrap_servers=&gt;"172.31.0.84:9092"#kafka的地址和端口</span><br><span class="line">                topics=&gt;"system-secure"#topic要一致</span><br><span class="line">                codec=&gt;plain</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">                hosts=&gt;["172.31.0.76:9200"]#es的地址和端口</span><br><span class="line">                index=&gt;"system-secure-%&#123;+YYYY-MM&#125;"#规定es使用的索引，按月份分类</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>配置文件里规定数据来源是kafka的<code>system-secure</code>这个topic，再修改同目录下的<code>jvm.options</code>：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms512m#根据自己实际情况来</span><br><span class="line">-Xmx512m#根据自己实际情况来</span><br></pre></td></tr></table></figure></p><p>保存退出，<code>./bin/logstash -f ./config/logstash_kafka2ES.conf &amp;</code>启动之，日志是logstash目录<code>/logs/logstash-plain.log</code>。</p><p>kafka的配置和启动已经在<a href="https://rorschachchan.github.io/2019/01/16/%E6%90%AD%E5%BB%BAKakfa2-11%E4%B8%BAELK%E6%9C%8D%E5%8A%A1/" target="_blank" rel="noopener">https://rorschachchan.github.io/2019/01/16/%E6%90%AD%E5%BB%BAKakfa2-11%E4%B8%BAELK%E6%9C%8D%E5%8A%A1/</a> 里说过了，这里略过。</p><h2><span id="elasticsearch-654的部署-配置和启动">elasticsearch-6.5.4的部署、配置和启动</span></h2><p>登录到es的服务器上，首先先下载安装包并且解压缩：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.5.4.tar.gz</span></span><br><span class="line">tar -zxvf elasticsearch<span class="number">-6.5</span><span class="number">.4</span>.tar.gz -C /opt/</span><br><span class="line">cd  elasticsearch<span class="number">-6.5</span><span class="number">.4</span>/</span><br><span class="line">useradd elk#es不能用root启动，需要新建一个用户</span><br><span class="line">chown -R elk:elk elasticsearch-6.5.4/#整个文件夹都给elk了</span><br></pre></td></tr></table></figure></p><p>修改一下<code>elasticsearch.yml</code>：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#cluster.name: my-application#由于实验环境是一个es，就没写集群名称</span><br><span class="line">node.name: lcshopelk</span><br><span class="line">path.data: /opt/elasticsearch-6.5.4/data/#存数据的地方</span><br><span class="line">path.logs: /data/tmp/elklog#存日志的路径</span><br><span class="line">bootstrap.memory_lock: true#为了防止swapping，官方建议设定为true，阿里云的云服务器是没有swap，可以不写</span><br><span class="line">network.host: <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">http.port: <span class="number">9200</span></span><br><span class="line">http.cors.enabled: true#准许es-head</span><br><span class="line">http.cors.allow-origin: <span class="string">"*"</span></span><br></pre></td></tr></table></figure></p><p>保存之后修改同目录的<code>jvm.options</code>：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms2g#根据自己实际情况来</span><br><span class="line">-Xmx2g#根据自己实际情况来</span><br></pre></td></tr></table></figure></p><p>这里的配置，官网标准的建议是把50％的可用内存作为<code>Elasticsearch</code>的堆内存，保留剩下的50％。当然它也不会被浪费，<code>Lucene</code>会很乐意利用起余下的内存。查看node下是否开启了<code>Mem_lock</code>的语句是：<code>curl &#39;localhost:9200/_nodes?filter_path=**.mlockall&#39;</code>。</p><p>保存完毕，还没完,<code>vim /etc/security/limits.conf</code>，最后两行改成如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile <span class="number">65536</span></span><br><span class="line">* hard nofile <span class="number">65536</span></span><br><span class="line"># allow user 'elk' mlockall</span><br><span class="line">elk soft memlock unlimited</span><br><span class="line">elk hard memlock unlimited</span><br></pre></td></tr></table></figure></p><p>然后切换成elk用户，执行<code>./elasticsearch -d</code>就是后台启动了。</p><p>简单的几句es命令：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http:<span class="comment">//127.0.0.1:9200/_cat/allocation?v#查看本机node磁盘容量</span></span><br><span class="line">curl -XGET http:<span class="comment">//127.0.0.1:9200/_cat/nodes?v#能查看node的CPU和负载情况</span></span><br><span class="line">curl -XGET http:<span class="comment">//127.0.0.1:9200/_aliases#查看所有的索引</span></span><br><span class="line">curl 'http://localhost:9200/_search?pretty' #查看索引一些细节</span><br></pre></td></tr></table></figure></p><h2><span id="kibana和es-head的部署-配置和启动">kibana和es-head的部署、配置和启动</span></h2><p><code>es-head</code>是用docker部署的，语句如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#假设docker已经安装好了</span><br><span class="line">docker run --name es-head -p 9100:9100 tobias74/elasticsearch-head:6#这里必须安装6版本，不然的话，数据不会显示</span><br></pre></td></tr></table></figure></p><p>运行完之后，要进入到容器里修改一下对应的配置文件<code>Gruntfile.js</code>，修改一下<code>connect</code>段落：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">connect: &#123;</span><br><span class="line">server: &#123;</span><br><span class="line">options: &#123;</span><br><span class="line">port: <span class="number">9100</span>,</span><br><span class="line">base: <span class="string">'.'</span>,</span><br><span class="line">keepalive: <span class="literal">true</span>,</span><br><span class="line">hostname: '*'#新增加这样一句话</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存文件，<code>docker restart es-head</code>即可。在浏览器里访问<code>外网ip地址:9100</code>，如图：<br><img src="/images/elk19.png" alt="akb48"></p><p><code>Kibana</code>也是用docker部署的，语句如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#假设docker已经安装好了</span><br><span class="line">docker run --name kibana -p <span class="number">5601</span>:<span class="number">5601</span> docker.elastic.co/kibana/kibana:<span class="number">6.5</span><span class="number">.4</span></span><br></pre></td></tr></table></figure></p><p>运行完之后，要进入到容器里修改一下对应的配置文件<code>kibana.yml</code>：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"># Default Kibana configuration from kibana-docker.</span><br><span class="line"></span><br><span class="line">server.name: kibana</span><br><span class="line">server.host: "0.0.0.0"#准许任何人访问</span><br><span class="line">elasticsearch.url: http:<span class="comment">//47.96.94.124:9200#这里输入外网IP和es的端口</span></span><br><span class="line">xpack.monitoring.ui.container.elasticsearch.enabled: <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>修改完事之后，<code>docker restart kibana</code>，然后在浏览器里访问<code>外网ip地址:9100</code>就可以查看kibana了，然后先去<code>menagement</code> —&gt;<code>index pattern</code>填入刚刚生成的index，然后在<code>discover</code>页面里选择刚刚生成的index就能看到日志内容了：<br><img src="/images/elk20.png" alt="akb48"></p><p><code>X-pack</code>目前还不支持6.2以上的版本，故此先略。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://dzone.com/articles/just-say-no-swapping" target="_blank" rel="noopener">https://dzone.com/articles/just-say-no-swapping</a><br><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/cn/heap-sizing.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/cn/heap-sizing.html</a></p>]]></content>
    
    <summary type="html">
    
      elk6跟elk5有了很大的变化，很多文本格式都已经不识别了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="elk" scheme="http://yoursite.com/tags/elk/"/>
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>搭建Kakfa2.11为ELK服务</title>
    <link href="http://yoursite.com/2019/01/16/%E6%90%AD%E5%BB%BAKakfa2-11%E4%B8%BAELK%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/01/16/搭建Kakfa2-11为ELK服务/</id>
    <published>2019-01-16T13:20:51.000Z</published>
    <updated>2019-01-17T03:53:53.646Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>试验机器：阿里云<code>centos 7.5</code>，IP地址是<code>172.31.0.84</code>。</p><p>本文是单台<code>kafka+zookeeper</code>架构，如果土豪可以尝试3台zookeeper+3台kafka。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install java<span class="number">-1.8</span><span class="number">.0</span>-openjdk* -y</span><br><span class="line">wget http:<span class="comment">//apache.website-solution.net/kafka/2.1.0/kafka_2.11-2.1.0.tgz</span></span><br><span class="line">tar -zxvf kafka_2<span class="number">.11</span><span class="number">-2.1</span><span class="number">.0</span>.tgz -C /opt</span><br><span class="line">wget http:<span class="comment">//apache.website-solution.net/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</span></span><br><span class="line">tar -zxvf zookeeper<span class="number">-3.4</span><span class="number">.10</span>.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></p><p>其实最新的kafka里面已经包括zookeeper了，不过我习惯了单独启动zookeeper，还是单独下载单独配置单独启动。</p><h2><span id="启动zookeeper">启动zookeeper</span></h2><p>首先先去zookeeper下的conf文件夹里编写配置文件：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/zookeeper<span class="number">-3.4</span><span class="number">.10</span>/conf</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure></p><p>然后编辑<code>zoo.cfg</code>，把最下面几行改成这样：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">autopurge.snapRetainCount=3#保留3个文件</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to "0" to disable auto purge feature</span><br><span class="line">autopurge.purgeInterval=1#保留一小时以内的日志</span><br><span class="line">server.1=172.31.0.84:2888:3888#本机IP地址</span><br></pre></td></tr></table></figure></p><p>2888端口：表示的是这个服务器与集群中的Leader服务器交换信息的端口；<br>3888端口：表示的是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p><p>然后回到<code>/usr/local/zookeeper-3.4.10/bin</code>里，执行<code>./zkServer.sh start</code>，执行完毕之后，再用<code>./zkServer.sh status</code>检查一下状态，由于是单台，所以状态应该是<code>standalone</code>。</p><h2><span id="启动kafka">启动kafka</span></h2><p>同zookeeper一样，先去kafka的conf文件夹<code>/opt/kafka_2.11-2.1.0/config</code>里，在配置文件<code>zookeeper.properties</code>最下面加上如下几句话:<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tickTime=<span class="number">2000</span></span><br><span class="line">initLimit=<span class="number">20</span></span><br><span class="line">syncLimit=<span class="number">10</span></span><br><span class="line">server.1=172.31.0.84:2888:3888#zookeeper的地址，也就是本机地址</span><br></pre></td></tr></table></figure></p><p>tickTime:这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。</p><p>修改好了<code>zookeeper.properties</code>之后，才是正式的kafka配置文件<code>server.properties</code>：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">broker.id=<span class="number">1</span></span><br><span class="line">port=9092#broker监听的端口</span><br><span class="line">host.name=172.31.0.84#填服务器 IP</span><br><span class="line">log.dir = / data / kafka - logs    #  该目录可以不用提前创建，在启动时自己会创建</span><br><span class="line">zookeeper.connect = 172.31.0.84:2181  # 这个就是zookeeper的ip及端口</span><br><span class="line">num.partitions = 16          # 需要配置较大 分片影响读写速度</span><br><span class="line">log.dirs = /data/kafka-logs # 数据目录也要单独配置磁盘较大的地方</span><br><span class="line">log.retention.hours = 168    # 时间按需求保留过期时间,避免磁盘满</span><br></pre></td></tr></table></figure></p><p>确认zookeeper状态是启动之后，<code>./bin/kafka-server-start.sh ./config/server.properties &amp;</code>来启动Kafka服务，然后检查一下端口9092是否正常打开</p><h2><span id="kafka简单操作语句">kafka简单操作语句</span></h2><p>一些常用的操作语句如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建topic</span><br><span class="line">./kafka-topics.sh --create --zookeeper 172.31.0.84:2181 --replication-factor 1 --partitions 1 --topic chenshuotest#factor大小不能超过broker的个数</span><br><span class="line">#查看topic</span><br><span class="line">./kafka-topics.sh --list --zookeeper <span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>:<span class="number">2181</span></span><br><span class="line">#在topic里增加信息</span><br><span class="line">./kafka-<span class="built_in">console</span>-producer.sh --broker-list <span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>:<span class="number">9092</span> --topic chenshuotest</span><br><span class="line">#消费掉topic里的信息，需要在另外一个xshell窗口界面操作</span><br><span class="line">./kafka-<span class="built_in">console</span>-consumer.sh --bootstrap-server  <span class="number">172.31</span><span class="number">.0</span><span class="number">.84</span>:<span class="number">9092</span> --topic chenshuotest --<span class="keyword">from</span>-beginning</span><br></pre></td></tr></table></figure></p><h2><span id="参考文档">参考文档</span></h2><p><a href="http://www.cnblogs.com/JetpropelledSnake/p/10057545.html" target="_blank" rel="noopener">http://www.cnblogs.com/JetpropelledSnake/p/10057545.html</a> （zookeeper+kafka集群的配置，请看这里）</p><p><img src="/images/企鹅.gif" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      就是单纯的部署和启动
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>在Django里添加Celery让脚本异步在后台运行</title>
    <link href="http://yoursite.com/2019/01/16/%E5%9C%A8Django%E9%87%8C%E6%B7%BB%E5%8A%A0Celery%E5%81%9A%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/01/16/在Django里添加Celery做异步任务处理/</id>
    <published>2019-01-16T06:12:00.000Z</published>
    <updated>2019-01-16T11:52:15.550Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>当使用Django执行脚本的时候，经常遇到一种情况：跳转到某个url，结果是先在后台执行一个时间较长的脚本，然后才能打开这个url页面，这样用户体验就很不好。</p><p>比如说像这样的<code>views.py</code>配置：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用ansible执行远程命令</span></span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(request)</span>:</span></span><br><span class="line">    command = <span class="string">"ansible all -i /root/.ssh/hosts -m shell -a 'echo 'worinixianren' &gt;&gt; /tmp/xianren.txt'"</span>  <span class="comment">#设定ansible远程命令</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        id = request.POST.getlist(<span class="string">"ecs"</span>)<span class="comment">#通过html来获取id</span></span><br><span class="line">        num = []</span><br><span class="line">        num.append(len(id))     <span class="comment">#传递参数，给下一个页面用的</span></span><br><span class="line">        name = []<span class="comment">#传递参数，给下一个页面用的</span></span><br><span class="line">        db = pymysql.connect(<span class="string">"阿里云数据库"</span>,<span class="string">"数据库账号"</span>,<span class="string">"数据库密码"</span>,<span class="string">"databases名"</span>)<span class="comment">#根据上面获得的id去数据库里得到对应的内网IP</span></span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'/root/.ssh/hosts'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> id:</span><br><span class="line">                sql = <span class="string">'select * from createyaml_ecs where name = "'</span>+ i + <span class="string">'";'</span></span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">                ip = cursor.fetchall()[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">                name.append(cursor.fetchall()[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">                f.write(ip+<span class="string">" ansible_ssh_user=root"</span>+<span class="string">"\n"</span>)<span class="comment">#将得到的内网IP写入到一个文件里</span></span><br><span class="line">        db.close()<span class="comment">#关闭数据库</span></span><br><span class="line">        child = subprocess.Popen(command,stdout=subprocess.PIPE, stderr=subprocess.PIPE,shell=<span class="keyword">True</span>)<span class="comment">#执行ansible命令</span></span><br><span class="line">        stdout, stderr = child.communicate()</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'run_command.html'</span>,&#123;<span class="string">'data'</span>:num[<span class="number">0</span>],<span class="string">'name'</span>:name&#125;)<span class="comment">#将内容反馈到html页面里</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'homepage.html'</span>)</span><br></pre></td></tr></table></figure></p><p>像上面这段代码，要看到<code>run_command.html</code>页面就要先把整个ansible部署的脚本全跑完，如果是几百台机器批量操作的脚本，那就要等到海枯石烂水倒流。那遇到这样的情况怎么解决呢？根据不同的请求，有不同的对策：</p><ol><li>单纯的后台跑一个脚本，那么就可以使用<code>Celery</code>；</li><li>在后台跑脚本的同时，还需要不断的向后台发送请求（比如微信上的茶叶妹聊天机器人），那么就要使用<code>Channels</code>；</li></ol><p><code>Celery</code>原理部分和配置定时任务就不多说了，文末的参考资料里有网站，这里主要说的是如何配置<code>Celery</code>。</p><h2><span id="环境交代">环境交代</span></h2><p>存储后端:阿里云redis(需要支持<code>evalsha</code>命令，如果不支持，去控制台<code>升级小版本</code>即可)<br>Python:<code>3.6.5</code><br>Django:<code>2.1.1</code><br>django-celery:<code>3.2.2</code>，安装方法：<code>pip install django-celery</code><br>celery-with-redis：<code>3.0</code>，安装方法<code>pip install celery-with-redis</code><br>celery:<code>3.1.26.post2</code></p><h2><span id="具体配置">具体配置</span></h2><p>首先配置<code>setting.py</code>，全文最后添加这样几句话：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#celery配置信息</span><br><span class="line">#celery中间人 redis://:redis密码@redis服务所在的ip地址:端口/数据库号，我用的是254号</span><br><span class="line">#channels配置redis也是这样配置，如果没有密码，就可以把':redis密码@'省略</span><br><span class="line">BROKER_URL = <span class="string">'redis://:redis密码@阿里云redis地址:6379/254'</span></span><br><span class="line">#celery结果返回，可用于跟踪结果</span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://:redis密码@阿里云redis地址:6379/254'</span></span><br><span class="line"></span><br><span class="line">#celery内容等消息的格式设置</span><br><span class="line">CELERY_ACCEPT_CONTENT = [<span class="string">'application/json'</span>,]</span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'json'</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></span><br><span class="line"></span><br><span class="line">#celery时区设置，使用settings中TIME_ZONE同样的时区</span><br><span class="line">CELERY_TIMEZONE = TIME_ZONE</span><br></pre></td></tr></table></figure></p><p>在<code>setting.py</code>同级的文件夹里创建<code>celery.py</code>，内容如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment">#获取当前文件夹名，即为该Django的项目名</span></span><br><span class="line">project_name = os.path.split(os.path.abspath(<span class="string">'.'</span>))[<span class="number">-1</span>]</span><br><span class="line">project_settings = <span class="string">'%s.settings'</span> % project_name</span><br><span class="line"> </span><br><span class="line"><span class="comment">#设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, project_settings)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#实例化Celery</span></span><br><span class="line">app = Celery(project_name)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#使用django的settings文件配置celery</span></span><br><span class="line">app.config_from_object(<span class="string">'django.conf:settings'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#Celery加载所有注册的应用</span></span><br><span class="line">app.autodiscover_tasks(<span class="keyword">lambda</span>: settings.INSTALLED_APPS)</span><br></pre></td></tr></table></figure></p><p>还是在同样的文件夹里，编辑<code>__init__.py</code>：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"> </span><br><span class="line"><span class="comment">#引入celery实例对象</span></span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br></pre></td></tr></table></figure></p><p>然后在app（具体应用的文件夹里），创建一个叫<code>tasks.py</code>，这里面就是需要在后台执行的具体脚本：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> celery.decorators <span class="keyword">import</span> task</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="meta">@task#在原有的方法上加上celery装饰器task</span></span><br><span class="line"><span class="comment">#ansible批量部署命令</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_ansible</span><span class="params">()</span>:</span></span><br><span class="line">    command = <span class="string">"ansible all -i /root/.ssh/hosts -m shell -a 'echo 'worinixianren' &gt;&gt; /tmp/xianren.txt'"</span>  <span class="comment">#设定命令</span></span><br><span class="line">child = subprocess.Popen(command,stdout=subprocess.PIPE, stderr=subprocess.PIPE,shell=<span class="keyword">True</span>)</span><br><span class="line">    stdout, stderr = child.communicate()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"success!!!"</span>)<span class="comment">#执行成功！</span></span><br></pre></td></tr></table></figure></p><p>保存退出之后，修改原有的<code>views.py</code>，把原来涉及脚本的字段删除，改成:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        id = request.POST.getlist(<span class="string">"ecs"</span>)</span><br><span class="line">        num = []</span><br><span class="line">        num.append(len(id))     <span class="comment">#传递参数，给下一个页面用的</span></span><br><span class="line">        name = []</span><br><span class="line">        db = pymysql.connect(<span class="string">"阿里云数据库"</span>,<span class="string">"数据库账号"</span>,<span class="string">"数据库密码"</span>,<span class="string">"databases名"</span>)</span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'/root/.ssh/hosts'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> id:</span><br><span class="line">                sql = <span class="string">'select * from createyaml_ecs where name = "'</span>+ i + <span class="string">'";'</span></span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">                ip = cursor.fetchall()[<span class="number">0</span>][<span class="number">3</span>]</span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">                name.append(cursor.fetchall()[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">                f.write(ip+<span class="string">" ansible_ssh_user=root"</span>+<span class="string">"\n"</span>)</span><br><span class="line">        db.close()</span><br><span class="line">        run_ansible.delay()     <span class="comment">#celery异步执行后台ansible程序，使用delay函数</span></span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'run_command.html'</span>,&#123;<span class="string">'data'</span>:num[<span class="number">0</span>],<span class="string">'name'</span>:name&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> render(request,<span class="string">'homepage.html'</span>)</span><br></pre></td></tr></table></figure></p><p>返回到<code>manage.py</code>所在的目录，先正常启动django，然后再<code>/usr/local/python3/bin/celery -A project名称 worker -l info</code>启动celery，如图：<br><img src="/images/celery1.png" alt="akb48"></p><p>看到<code>tasks.py</code>已经成功被celery使用了，然后在页面上去执行原本的命令，就会看到celery页面有刷新：<br><img src="/images/celery2.png" alt="akb48"></p><p>此时再去redis里查看一下存储的效果：<br><img src="/images/celery3.png" alt="akb48"></p><p>可见tasks执行的状态已经被保存到了redis里。但是上面我们是在前台页面启动celery，如果想把celery作为一个后台守护进程，那么命令语句如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/python3/bin/celery multi start worker -A project名称 -l info</span><br></pre></td></tr></table></figure></p><p>效果如图：<br><img src="/images/celery4.png" alt="akb48"></p><p>停止或重启将上面的<code>start</code>换为<code>stop</code>或<code>restart</code>即可。</p><h2><span id="补充">补充</span></h2><p>如果<code>tasks.py</code>内容变化了，需要重启celery才能生效。</p><p>如果在启动celery的时候，日志有写<code>UserWarning: Using settings.DEBUG leads to a memory leak, never use this setting in production environments! warnings.warn(&#39;Using settings.DEBUG leads to a memory leak, never &#39;</code>，那么就在<code>settings.py</code>里把<code>DEBUG = True</code>改成<code>DEBUG = False</code>即可。</p><p>查看redis有几个库的命令：<code>config get databases</code>。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://yshblog.com/blog/163" target="_blank" rel="noopener">http://yshblog.com/blog/163</a> （对照代码做一遍就更有体会了）<br><a href="https://www.cnblogs.com/wdliu/p/9517535.html" target="_blank" rel="noopener">https://www.cnblogs.com/wdliu/p/9517535.html</a> (原理以及如何配置定时任务)<br><a href="https://www.cnblogs.com/wdliu/p/9530219.html" target="_blank" rel="noopener">https://www.cnblogs.com/wdliu/p/9530219.html</a><br><a href="http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html" target="_blank" rel="noopener">http://docs.celeryproject.org/en/latest/getting-started/brokers/redis.html</a></p>]]></content>
    
    <summary type="html">
    
      题外话：网站路由url不加斜杠，用户自己加斜杠之后访问404，但是不会出现重定向的问题；路由url加斜杠，用户访问的url无论加不加斜杠均可访问正常，但是不加斜杠的访问链接会做重定向，影响访问速度。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="celery" scheme="http://yoursite.com/tags/celery/"/>
    
      <category term="异步任务" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>大量任务冲击下的activeMQ报错&quot;GC overhead limit exceeded&quot;</title>
    <link href="http://yoursite.com/2019/01/14/%E5%A4%A7%E9%87%8F%E4%BB%BB%E5%8A%A1%E5%86%B2%E5%87%BB%E4%B8%8B%E7%9A%84activeMQ%E6%8A%A5%E9%94%99GC-overhead-limit-exceeded/"/>
    <id>http://yoursite.com/2019/01/14/大量任务冲击下的activeMQ报错GC-overhead-limit-exceeded/</id>
    <published>2019-01-14T11:54:19.000Z</published>
    <updated>2019-01-14T13:19:20.601Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>半夜阿里云的杭州可用B区出现了机房抖动，几乎所有的B区服务全部掉线。阿里云的技术人员捅咕了半个小时左右，在大约11点40左右恢复了正常。此时几百万的设备开始同时恢复上线，然而经过了1个小时左右，依旧有几十万设备无法上线，有的甚至上线后又掉线。</p><p>我们的架构是设备要先去“注册中心”注册，注册成功之后才会正常的工作。如果多次注册不成功，就会释放连接，把连接让给其他需要注册的设备。但是发现设备上线的速度很慢，扩容了几台“注册中心”模块，效果依旧不见好转。发现注册模块的CPU全部都达到了100%：<br><img src="/images/activemq4.png" alt="akb48"></p><p>登录到服务器里一看，日志不断的刷新这样的内容：<br><img src="/images/activemq1.png" alt="akb48"></p><p>模块与activemq的延迟特别大，此时activemq又有几百万的消息没有消费堆积在队列里。大约十分钟左右，就开始抛出<code>java.lang.OutOfMemoryError: GC overhead limit exceeded</code>的错误，如图：<br><img src="/images/activemq2.png" alt="akb48"></p><p>但是同一时间段里的activemq并没有出现内存吃紧的情况：<br><img src="/images/activemq3.png" alt="akb48"></p><p>没有办法，就先赌一下的重启了activemq，没想到问题就解决了…</p><p>奇怪，明明activemq没有内存的明显消耗，却报内存耗尽。先把结果记录下来，等下一次再有类似的情况，好好观察一下（也但愿不要再在放假的时候出现故障了…）</p>]]></content>
    
    <summary type="html">
    
      大半夜的出问题，我也是醉了...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="activemq" scheme="http://yoursite.com/tags/activemq/"/>
    
  </entry>
  
  <entry>
    <title>使用Zabbix的Python api去获取当前监控值</title>
    <link href="http://yoursite.com/2019/01/09/%E4%BD%BF%E7%94%A8Zabbix%E7%9A%84python-api%E5%8E%BB%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9B%91%E6%8E%A7%E5%80%BC/"/>
    <id>http://yoursite.com/2019/01/09/使用Zabbix的python-api去获取当前监控值/</id>
    <published>2019-01-09T07:24:49.000Z</published>
    <updated>2019-01-15T06:56:20.612Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="事前准备">事前准备</span></h2><p>有些时候我们需要在非zabbix的web界面里得到zabbix-server对某台服务器的实时监控值。但是有些值是zabbix-server加工过的，比如<code>eth0入网流量</code>，zabbix-server加工的方法如下：<br><img src="/images/zabbix1.png" alt="akb48"></p><p>可见是每秒的变量并且还乘了8，那么如果要得到这样加工过的值，想通过shell得到linux的指标无疑是十分麻烦的。那么对于这种需求，我们想到的第一个办法就是使用zabbix的api，通过api去获取值比爬网页要方便许多（而且zabbix-server的web页面不是那么好爬的）。</p><p>Zabbix 3.0的API官方文档：<a href="https://www.zabbix.com/documentation/3.0/manual/api" target="_blank" rel="noopener">https://www.zabbix.com/documentation/3.0/manual/api</a><br>Zabbix 3.0的python版API官方文档：<a href="https://github.com/gescheit/scripts/tree/master/zabbix" target="_blank" rel="noopener">https://github.com/gescheit/scripts/tree/master/zabbix</a><br>这里我更推荐用python版的api，因为使用<code>zabbix-api</code>这个python第三方库让开发变得更为简洁。</p><h2><span id="安装zabbix-api">安装zabbix-api</span></h2><p>安装<code>zabbix-api</code>最方便的方法就是pip安装。本文的python版本<code>2.7.15</code>，使用源码安装的，安装包并不带pip，那么安装pip的方法如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib-devel zlib openssl openssl-devel</span><br><span class="line">mv /usr/bin/pip /usr/bin/pip-bak<span class="comment">#备份原有的pip</span></span><br><span class="line">wget --no-check-certificate https://pypi.python.org/packages/source/s/setuptools/setuptools<span class="number">-12.0</span><span class="number">.3</span>.tar.gz<span class="comment">#md5=f07e4b0f4c1c9368fcd980d888b29a65</span></span><br><span class="line">tar -zxvf setuptools<span class="number">-12.0</span><span class="number">.3</span>.tar.gz</span><br><span class="line">cd setuptools<span class="number">-12.0</span><span class="number">.3</span></span><br><span class="line">python setup.py install<span class="comment">#这一步需要上面刚安装的zlib</span></span><br><span class="line">wget https://files.pythonhosted.org/packages/d0/<span class="number">92</span>/<span class="number">1e8406</span>c15d9372084a5bf79d96da3a0acc4e7fcf0b80020a4820897d2a5c/pip<span class="number">-7.1</span><span class="number">.2</span>.tar.gz</span><br><span class="line"><span class="comment">#或者去https://pypi.org/project/pip/7.1.2/#files页面下载pip-7.1.2.tar.gz </span></span><br><span class="line">tar -zxcf pip<span class="number">-7.1</span><span class="number">.2</span>.tar.gz</span><br><span class="line">cd pip<span class="number">-7.1</span><span class="number">.2</span></span><br><span class="line">sudo python setup.py install</span><br><span class="line">ln -s /usr/local/python27/bin/pip2<span class="number">.7</span> /usr/bin/pip<span class="comment">#做一个新的快捷方式</span></span><br></pre></td></tr></table></figure></p><p>有了pip之后，就可以安装<code>zabbix-api</code>，命令是：<code>pip install zabbix-api</code> 。在python的命令行里输入<code>from zabbix_api import ZabbixAPI</code>不报错就代表安装成功。</p><h2><span id="链接zabbix">链接zabbix</span></h2><p>通过zabbix-server鉴权的代码如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">#这个脚本是用来获取zabbix 定时流量值</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> zabbix_api <span class="keyword">import</span> ZabbixAPI</span><br><span class="line">zapi = ZabbixAPI(server=<span class="string">"http://网页地址/zabbix/api_jsonrpc.php"</span>)</span><br><span class="line">zapi.login("网页的用户名", "网页的密码")#鉴权</span><br></pre></td></tr></table></figure></p><p>如果没报错，就证明已经成功连接到zabbix-server了。</p><h2><span id="获取监控项">获取监控项</span></h2><p>还是以<code>eth0入网流量</code>为例，获取它的代码如下：<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="comment">#这个脚本是用来获取zabbix 定时流量值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> zabbix_api <span class="keyword">import</span> ZabbixAPI</span><br><span class="line">zapi = ZabbixAPI(server=<span class="string">"http://网页地址/zabbix/api_jsonrpc.php"</span>)</span><br><span class="line">zapi.login(<span class="string">"网页的用户名"</span>, <span class="string">"网页的密码"</span>)<span class="comment">#鉴权</span></span><br><span class="line"></span><br><span class="line">hostname = [<span class="string">"服务器1名称"</span>,<span class="string">"服务器2名称"</span>,<span class="string">"服务器3名称"</span>,<span class="string">"服务器4名称"</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> hostname:</span><br><span class="line">        list_item = zapi.item.get(&#123;<span class="string">"output"</span>: <span class="string">"extend"</span>,<span class="string">"filter"</span>:&#123;<span class="string">'host'</span>:name&#125;,<span class="string">"search"</span>:&#123;<span class="string">'key_'</span>:<span class="string">'net.if.in[eth0]'</span>&#125;&#125;)</span><br><span class="line">        eth0_value = list_item[<span class="number">0</span>][<span class="string">"lastvalue"</span>]</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Incoming traffic bandwidth is:"</span>+(eth0_value)</span><br></pre></td></tr></table></figure></p><p>可见多么简单！</p><p>上面代码里的hostname就是zabbix网页里的<code>Host name</code>，如图：<br><img src="/images/zabbix2.png" alt="akb48"></p><p>然后使用<code>zapi.item.get</code>方法通过<code>filter</code>来过滤，最后得到对应的key值。zapi下面还有很多方法，比如<code>zapi.hostgroup.get</code>、<code>zapi.host.get</code>、<code>zapi.application.get</code>等等等等，可以对于自己的需要，灵活运用。</p><h2><span id="参考文档">参考文档</span></h2><p><a href="https://blog.csdn.net/LYJ_viviani/article/details/70568434" target="_blank" rel="noopener">https://blog.csdn.net/LYJ_viviani/article/details/70568434</a><br><a href="https://segmentfault.com/a/1190000014241994" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014241994</a><br><a href="http://blog.51cto.com/xiaofengfeng/1907573" target="_blank" rel="noopener">http://blog.51cto.com/xiaofengfeng/1907573</a></p><p><img src="/images/东方三侠.gif" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      用zabbix-api获取值然后可以搭配微信通知脚本，这样就可以定时的知道当前服务器的监控值了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="api" scheme="http://yoursite.com/tags/api/"/>
    
  </entry>
  
  <entry>
    <title>Html制作progress进度条</title>
    <link href="http://yoursite.com/2019/01/07/Html%E5%88%B6%E4%BD%9Cprogress%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>http://yoursite.com/2019/01/07/Html制作progress进度条/</id>
    <published>2019-01-07T07:07:15.000Z</published>
    <updated>2019-01-24T11:32:15.749Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="简单介绍">简单介绍</span></h2><p>无论是下载还是上传，亦或者是执行脚本。进度条都是必不可少的环节，它能让人清晰直观的看到事情发展的进度。现在生成进度条有很多种方法，我选择的是<code>progress</code>，它的用法很简单：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">'70'</span> <span class="attr">max</span>=<span class="string">'100'</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>value</code>属性表示进度条已经完成的进度值，范围为<code>0~max</code>之间。如果没有设置<code>max</code>属性，那么<code>value</code>属性值的范围要在0~1之间。如果没有<code>value</code>值，那么完成进度是不确定的。那么整个进度条就是一个动态效果，就像一个加载中loading，中间的进度块来回游荡。如下图：<br><img src="/images/django42.gif" alt="akb48"></p><h2><span id="动态进度条">动态进度条</span></h2><p>有些时候，我们无法正常获取到后台脚本运行的进度，因为某些脚本无法反馈给前端一个值来衡量目前运行到什么阶段，于是这种情况我们只能预估一下这个脚本大约用多少时间，做一个假的进度条来展示进度。如果想做一个逐渐进行的进度条，比如2秒钟跑满的进度条，那么代码如下：<br>    <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>进度条：<span class="tag">&lt;<span class="name">progress</span> <span class="attr">value</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">progress</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"开始"</span> <span class="attr">onclick</span>=<span class="string">"goprogress()"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">goprogress</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> pro=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"progress"</span>)[<span class="number">0</span>];<span class="comment">//获取progress的第一行</span></span></span><br><span class="line"><span class="undefined">        gotoend(pro,0);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">gotoend</span>(<span class="params">pro,value</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> value=value+<span class="number">1</span>;</span></span><br><span class="line"><span class="undefined">        pro.value=value;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(value&lt;<span class="number">100</span>) &#123;</span></span><br><span class="line"><span class="javascript">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;gotoend(pro, value);&#125;,<span class="number">20</span>)<span class="comment">//这里是时间，20的意思是2秒完成</span></span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">"任务完成"</span>)&#125;,<span class="number">20</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>整个动态效果如下：<br><img src="/images/django41.gif" alt="akb48"></p><h2><span id="如何页面自动执行函数">如何页面自动执行函数</span></h2><p>上面的例子，需要手动点击button，如果不想把函数绑定点击按钮事件上，而是要页面加载出来后自动执行函数就出现此效果，那么有两种办法：</p><ol><li><p>直接把函数写到html的body标签里面</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"myfunction()"</span>&gt;</span></span><br><span class="line">//具体函数</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在JS语句里调用</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">　　<span class="function"><span class="keyword">function</span> <span class="title">myfun</span>(<span class="params"></span>)</span></span></span><br><span class="line"><span class="undefined">　　&#123;</span></span><br><span class="line"><span class="javascript">　　 alert(<span class="string">"this window.onload"</span>);</span></span><br><span class="line"><span class="undefined">　　&#125;</span></span><br><span class="line"><span class="javascript">　　<span class="comment">/*用window.onload调用myfun()*/</span></span></span><br><span class="line"><span class="javascript">　　<span class="built_in">window</span>.onload = myfun;<span class="comment">//不要括号</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>或者在JS语句里按以下方法调用：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">           func1();</span></span><br><span class="line"><span class="undefined">           func2();</span></span><br><span class="line"><span class="undefined">           func3();</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2><span id="a-href页面不刷新方法">a href页面不刷新方法</span></h2><p>使用<code>&lt;a href=&quot;#&quot;&gt;</code>页面是会原地刷新的，那么如何不让页面刷新呢？使用<code>&lt;a href=&#39;javascript:&#39;&gt;</code> 。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/qq965194745/article/details/80034993" target="_blank" rel="noopener">https://blog.csdn.net/qq965194745/article/details/80034993</a><br><a href="https://frontenddev.org/article/how-to-use-javascript-to-do-a-high-force-the-progress-bar.html" target="_blank" rel="noopener">https://frontenddev.org/article/how-to-use-javascript-to-do-a-high-force-the-progress-bar.html</a><br><a href="http://www.voidcn.com/article/p-crqmibur-a.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-crqmibur-a.html</a><br><a href="https://blog.csdn.net/Zhaky/article/details/50922613" target="_blank" rel="noopener">https://blog.csdn.net/Zhaky/article/details/50922613</a><br><a href="http://www.webfront-js.com/articaldetail/47.html" target="_blank" rel="noopener">http://www.webfront-js.com/articaldetail/47.html</a><br><a href="https://www.cnblogs.com/witchgogogo/p/5547258.html" target="_blank" rel="noopener">https://www.cnblogs.com/witchgogogo/p/5547258.html</a> （这个用bootstrap做的进度条更牛逼）</p>]]></content>
    
    <summary type="html">
    
      这个进度条主要是计时的，如果想要真实反映后台脚本的进度，那么需要ajax动态获取后台进度
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="进度条" scheme="http://yoursite.com/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    
  </entry>
  
</feed>
