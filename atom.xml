<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-17T08:41:35.268Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实战Kibana的日志关键词搜索和日志可视化</title>
    <link href="http://yoursite.com/2018/01/17/%E5%AE%9E%E6%88%98Kibana%E7%9A%84%E6%97%A5%E5%BF%97%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A2%E5%92%8C%E6%97%A5%E5%BF%97%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://yoursite.com/2018/01/17/实战Kibana的日志关键词搜索和日志可视化/</id>
    <published>2018-01-17T07:44:01.000Z</published>
    <updated>2018-01-17T08:41:35.268Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="准备工作">准备工作</span></h2><p>首先，先下载一个elastic网站上下载一个它提供的demo—莎翁的《亨利四世》，下载地址是<a href="https://download.elastic.co/demos/kibana/gettingstarted/shakespeare.json" target="_blank" rel="noopener">https://download.elastic.co/demos/kibana/gettingstarted/shakespeare.json</a> 。</p><p>打开这个json字符串，里面就是《亨利四世》的话剧剧本，长得是这个样子：<br><img src="/images/kibana1.png" alt="akb48"></p><p>可以看到里面有<code>play_name</code>、<code>speaker</code>、<code>speech_number</code>、<code>line_id</code>等等名称，每个名称后面都有一个对应的值。</p><p>然后启动elasticsearch，按照上面的文件格式生成索引。语句如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT http:<span class="comment">//localhost:9200/shakespeare -d '</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"mappings"</span> : &#123;</span><br><span class="line">  <span class="string">"_default_"</span> : &#123;</span><br><span class="line">   <span class="string">"properties"</span> : &#123;</span><br><span class="line">    "speaker" : &#123;"type": "string", "index" : "not_analyzed" &#125;,    #确定type是字符</span><br><span class="line">    <span class="string">"play_name"</span> : &#123;<span class="string">"type"</span>: <span class="string">"string"</span>, <span class="string">"index"</span> : <span class="string">"not_analyzed"</span> &#125;,</span><br><span class="line">    "line_id" : &#123; "type" : "integer" &#125;,    #确定type是数字</span><br><span class="line">    <span class="string">"speech_number"</span> : &#123; <span class="string">"type"</span> : <span class="string">"integer"</span> &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">';</span></span><br></pre></td></tr></table></figure></p><p>导入刚刚下载的那个json：<code>curl -XPOST &#39;localhost:9200/shakespeare/_bulk?pretty&#39; --data-binary @shakespeare.json</code></p><p>具体elasticsearch的增删改查语法可以参看阮大师的<a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html</a> ，个人建议将elasticsearch和mysql对比一下，这样更方便理解。</p><p>然后后台启动kibana，确认5601端口已经stand by，如图：<br><img src="/images/kibana2.png" alt="akb48"></p><p>然后在浏览器地址栏输入<code>服务器外网ip：5601</code>打开kibana。</p><p>导入数据结束之后，使用<code>curl &#39;localhost:9200/_cat/indices?v&#39;</code>，去查看一下效果，如果看到index里有shakespeare那一栏就是导入成功了，如图：<br><img src="/images/kibana3.png" alt="akb48"></p><p>在启动Kibana后，Kibana会自动在配置的es中创建一个名为<code>.kibana</code>的索引（上图第二个），这个索引用来存储数据，注意！不要删除了它。</p><h2><span id="kibana的界面搜索">Kibana的界面搜索</span></h2><p>如果此时的kibana里是第一次配置的话，那么第一步就是配置新索引，我们之前在生成索引的时候写的是<code>shakespeare</code>，那么现在也写<code>shakespeare</code>，然后点击<code>create</code>，如图：<br><img src="/images/kibana4.png" alt="akb48"></p><p>然后在菜单栏左侧的<code>discover</code>里选择刚刚建立的<code>shakespeare</code>，就会看到这样的东西：<br><img src="/images/kibana5.png" alt="akb48"></p><p>在Search上就可以进行搜寻，比如说我搜寻<code>freedom</code>，如图：<br><img src="/images/kibana6.png" alt="akb48"></p><p>如果我搜寻<code>KING HENRY IV</code>，他不分大小写的把所有king、henry、iv都搜索出来。</p><p>如果我想搜寻line_id的第一行到第三行，那么语句就是<code>line_id:[1 TO 3]</code>，如图：<br><img src="/images/kibana17.png" alt="akb48"></p><p>如果想在上面的基础上进一步细化，比如说要在line_id是从第一行到第三行，同时_type是scene的语句：<code>line_id:[1 TO 3] AND _type:scene</code>：<br><img src="/images/kibana18.png" alt="akb48"></p><p>假如不想要scene，那么就把<code>AND</code>改成<code>NOT</code>。</p><p>如果这个时候只想关注一些指定的字段，那么可以将鼠标移动到索引下面的字段上，然后选在add即可，同样的移动上面已经选择的字段选择remove进行移除，比如我们试一下这个<code>speaker</code>：<br><img src="/images/kibana19.png" alt="akb48"></p><p>add之后在点击右侧的具体的speaker，就会看到里面的细节，比如这位westmoreland（威斯摩兰伯爵）：<br><img src="/images/kibana7.png" alt="akb48"></p><p>这个时候就能看见这位伯爵大哥的台词细节，在第几场的第几节，说的是什么台词。再返回菜单左侧点击这个speaker，我们还会看到一个比重：<br><img src="/images/kibana8.png" alt="akb48"></p><p>从这里就很清晰的看到，FALSTAFF（法斯塔夫）这个哥们的台词最多，也符合书里塑造的那个嗜酒话痨的艺术形象。而我们的KING HENRY IV(亨利四世)的台词只是第四位，占比重11%而已…</p><p>这样具体的搭配搜索之后，可以点击界面右上侧的save进行保存搜寻结果，再搭配share分享搜索结果的url网址，如图：<br><img src="/images/kibana9.png" alt="akb48"></p><h2><span id="kibana的图像化展示">Kibana的图像化展示</span></h2><p>Kibana也能做到类似grafana那样的炫酷图象化展示，更加立体的表现日志情况，首先选择左侧菜单栏里的<code>Visualize</code>（可视化）：<br><img src="/images/kibana10.png" alt="akb48"></p><p>然后点击<code>Create a Visualization</code>,里面既有很多种图形供你选择，有饼型，有箭头的，有文字的，有仪表盘的，如图：<br><img src="/images/kibana11.png" alt="akb48"></p><p>我们这里先建立一个饼型的，还是上面那个台词多少的例子，首先选择<code>shakespeare</code>作为数据源，然后点击<code>split slices</code>，如图：<br><img src="/images/kibana12.png" alt="akb48"></p><p>然后在<code>Aggergation</code>里选择<code>Terms</code>，然后在<code>Field</code>里选择<code>Speaker</code>,size那里写8,最后点击上面的那个三角播放键，看看结果：<br><img src="/images/kibana13.png" alt="akb48"></p><p>这就很清晰的看出，亨利四世一共说了1086句话，占比11.11%。</p><p>如果我们再加一个<code>Split Slices</code>，这一次在原有的specker的基础上选择<code>play_name</code>，图象变成了一个同心圆，最外面的一层就是新增的“play_name”的情况，如图显示FALSTAFF的所有台词会在两个play_name里出现：<br><img src="/images/kibana14.png" alt="akb48"></p><p>如果这个盘子里不想统计FALSTAFF这个话包，就添加一个过滤器，选择<code>speaker is not</code>，后面写上FALSTAFF即可，如图：<br><img src="/images/kibana15.png" alt="akb48"></p><p>效仿刚才的方法也可以做一个仪表盘，如图：<br><img src="/images/kibana16.png" alt="akb48"></p><p>可视化的数据也可以save和share，同样在web界面的右上角。保存的数据是可以在左侧菜单栏里的Dashboard里展示，做成一个类似zabbix那样的展示！</p>]]></content>
    
    <summary type="html">
    
      Kibana那个界面做的还是挺好看的
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="elk" scheme="http://yoursite.com/tags/elk/"/>
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>工作所用的模块回滚脚本</title>
    <link href="http://yoursite.com/2018/01/17/%E5%B7%A5%E4%BD%9C%E6%89%80%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97%E5%9B%9E%E6%BB%9A%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/01/17/工作所用的模块回滚脚本/</id>
    <published>2018-01-17T04:25:25.000Z</published>
    <updated>2018-01-17T04:33:23.443Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言与脚本内容">前言与脚本内容</span></h2><p>部署中常备一个回滚脚本也是很有必要的，我所在公司的服务器模块名都是在初始化的时候写进<code>/etc/role_install</code>这个文件里，如下图的这个服务器就是fss服务器：<br><img src="/images/rollback1.png" alt="akb48"></p><p>再比如下面这个服务器，虽然包含nginx的组件但是httpproxy的服务器：<br><img src="/images/rollback2.png" alt="akb48"></p><p>那么有了这样的前提，整个回滚的脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#Written by ChrisChan @July-4th-2017</span><br><span class="line">#Desription:这是一个回滚的脚本。</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>=$(cat /etc/role_install |grep -v zkclient|grep -v nginx)</span><br><span class="line">echo -e <span class="string">'\033[31m现在将执行回滚操作，本次回滚只回滚普通模块，不包含nginx和zkclient!\033[0m'</span> </span><br><span class="line">echo <span class="string">"回滚的模块名称："</span>$<span class="built_in">module</span></span><br><span class="line">echo -e <span class="string">'\033[33m如果想取消回滚操作，请ctrl+c立即停止本脚本...\033[0m'</span></span><br><span class="line">sleep <span class="number">5</span></span><br><span class="line"></span><br><span class="line">cd /dxpbackup/hswx/$module &amp;&amp; zip $module.zip -x "*og*" -r .    #到备份的文件夹里去压缩</span><br><span class="line">mv /dxpbackup/hswx/$<span class="built_in">module</span>/$<span class="built_in">module</span>.zip /mnt/hswx    </span><br><span class="line">echo $<span class="built_in">module</span><span class="string">".zip文件已经生成！"</span></span><br><span class="line"> </span><br><span class="line">until [ <span class="string">"$decision"</span> == <span class="string">"Y"</span> -o <span class="string">"$decision"</span> == <span class="string">"y"</span> -o <span class="string">"$decision"</span> == <span class="string">"N"</span> -o <span class="string">"$decision"</span> == <span class="string">"n"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        read -p <span class="string">"请问是否用回滚的压缩包覆盖到/mnt/hswx下？(y/n)"</span> decision</span><br><span class="line">        echo <span class="string">"您的选择是："</span>$decision</span><br><span class="line">        <span class="keyword">if</span> [ $decision == Y -o $decision == y ]</span><br><span class="line">               then</span><br><span class="line">                       echo <span class="string">"现在已经开始覆盖..."</span></span><br><span class="line">                       rm -rf /mnt/hswx/$module    #先把原来的内容删除</span><br><span class="line">                       unzip /mnt/hswx/$module.zip -d /mnt/hswx/$module    #重新解压缩进去</span><br><span class="line">                       echo -e <span class="string">'\033[32m覆盖已经完成，可以直接执行/startall脚本!\033[0m'</span></span><br><span class="line">       elif [ $decision == N -o $decision == n ]</span><br><span class="line">               then</span><br><span class="line">                       echo -e <span class="string">'\033[32m生成的'</span>$<span class="built_in">module</span><span class="string">'.zip文件保存在/root文件夹里\033[0m'</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">               echo -e <span class="string">'\033[31m输入字符不符合!请重新输入!\033[0m'</span></span><br><span class="line">       fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2><span id="新的知识点">新的知识点！</span></h2><p>1）zip在压缩文件夹的时候要过滤掉某些文件使用“-x”参数，比如说要在AAA文件夹里面过滤掉abc和jqk这两个文件，那么语句就是<code>zip AAA.zip -x &quot;abc&quot; -x &quot;jqk&quot; -r .</code>或者是<code>zip -r -x=abc -x=jqk AAA.zip .</code> 这样两个语句。</p><p>如果你要过滤掉的是一个文件夹，比如那么就要在文件夹后面名字加上一个<em>，下图就是要压缩整个auc文件夹为456.zip但是又不想要lib这个文件夹，就使用了`zip 456.zip -x “lib</em>“ -r .`：<br><img src="/images/rollback3.png" alt="akb48"></p><p>不过如果文件夹里还有其他lib开头的文件夹也会被过滤掉，这一点要注意。</p><p>2）本shell里面涉及了逻辑判断，而<code>[[</code>和<code>[</code>的区别如下图：<br><img src="/images/rollback4.gif" alt="akb48"></p><p>3）如果if语句中出现报错“[: too many arguments”，很有可能就是字符串变量中可能存在空格，shell解析时将其认为是多个参数，再进行判断时，无法知道该获取哪个值，所以最好都用双引号括起来； </p><p>4）如果是“变量a等于aa且变量b等于bb  或者 变量c等于cc且变量d等于dd ” 这样的判断句怎么写？答曰：<br>    [ $a = “aa” -a $b = “bb” ] || [$c = “cc” -a $d = “dd” ]</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://zhangge.net/4776.html" target="_blank" rel="noopener">https://zhangge.net/4776.html</a></p>]]></content>
    
    <summary type="html">
    
      俗话说的好：“真男人从来不回滚”!
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Ansible的几个基本语句</title>
    <link href="http://yoursite.com/2018/01/17/Ansible%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9F%BA%E6%9C%AC%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2018/01/17/Ansible的几个基本语句/</id>
    <published>2018-01-17T03:43:52.000Z</published>
    <updated>2018-01-17T04:19:01.110Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="开篇的废话">开篇的废话</span></h2><p>批处理工具我最早接触的是pssh，因为它实在很简单粗暴，但是它由于太简单粗暴了，应付十台二十台机器还OK，应付五十台一百台服务器就心有余力不足了（而且xshell右键有一个“发送键入到所有会话”的功能，与pssh效果几乎一样），而且我还不太喜欢puppet，总觉得那玩意跟我八字不合，于是乎，在新头头的推荐下，我把目光放在了Ansible。</p><p>Ansible的安装很简单，在Redhat环境下直接<code>yum install -y ansible</code>就行。Redhat已经将Ansible公司收购了，所以在安装上提供了不小的便利。</p><p>Ansible在安装完毕之后，会在<code>/etc/ansible/</code>目录下看见一个叫hosts的文件，这里是所有你要控制的服务器的ip们，可以排列写，比如：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.122</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.133</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.1</span><span class="number">.144</span></span><br></pre></td></tr></table></figure></p><p>也可以分组写，比如：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[aliyun]</span><br><span class="line"><span class="number">10.22</span><span class="number">.33</span><span class="number">.44</span></span><br><span class="line"><span class="number">10.22</span><span class="number">.33</span><span class="number">.45</span></span><br><span class="line">[jinshanyun]</span><br><span class="line"><span class="number">121.23</span><span class="number">.45</span><span class="number">.66</span></span><br><span class="line"><span class="number">121.23</span><span class="number">.45</span><span class="number">.67</span></span><br><span class="line"><span class="number">121.23</span><span class="number">.45</span><span class="number">.68</span>:<span class="number">2222</span>  （这个不是使用ssh默认的<span class="number">22</span>端口，就需要特别指出）</span><br></pre></td></tr></table></figure></p><p>默认情况下，Ansible会把命令全用于这个hosts文件，比如<br>    ansible all -m ping  -u ashin<br>这句话意思是整个hosts里的机器以ashin账户启动，而且都要ping 一下当前本机。</p><h2><span id="具体语句">具体语句</span></h2><p>怎么连接主机与要控制的远程机器请按之前写的“<a href="http://chenx1242.blog.51cto.com/10430133/1763978”一文进行操作，这里先说几个命令语句：" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1763978”一文进行操作，这里先说几个命令语句：</a></p><p>1)<code>ansible all -m shell -a &quot;/bin/echo hello&quot;</code><br>对hosts里所有的机器一起使用”输出hello这个文字”。-m shell可以忽略不写，但是不是shell而是其他的模块就要写出来；</p><p>2)<code>ansible aliyun -m copy -a &quot;src=~/projects/tests/t.py dest=~&quot;</code><br>把hosts里aliyun组的机器的/projects/tests/t.py复制到~目录下；<br>[注意！]copy模块不支持变量路径，也就是说如果目标服务器的部署路径不同，copy不会很智能的去访问.bash_profile来得到用户的自定义变量，写变量替换路径是不会达到目的的。</p><p>3)<code>ansible jinshanyun[0:9] -i -m file -a &quot;dest=~/tests state=absent&quot;</code><br>把hosts里jinshanyun组中从0~9这十台机器的/tests文件夹删除掉，absent是“缺席，不在”的意思；</p><p>4)<code>ansible 192.168.1.133 -m ping</code><br>这句话=<code>ping 192.168.1.133</code>；</p><p>5)<code>ansible v1 -m service -a &quot;name=mysql state=started&quot; -u ashin --sudo -K</code><br>以用户名为ashin登陆hosts里所有v1组的机器，然后检查mysql是否是started状态，若不是就start，同时要输入root的密码作为确认；</p><p>6)<code>ansible 10.11.22.* -m user -a &quot;name=foo password=foo&quot; --sudo -K</code><br>hosts文件里所有10.11.22开头的机器，都要添加一个新的用户名foo，同时密码是foo，并且输入root密码确认身份；</p><p>7)<code>ansible v1:!v2 -m apt -a &quot;name=git state=latest&quot;</code><br>检查所有属于v1组同时还不属于v2组的机器里的git文件是否是最新版本；</p><p>8)<code>ansible webservers:&amp;dbservers -a &quot;/sbin/reboot&quot; -f 10 --sudo -K</code><br>重新启动既是webservers组又是dbservers组的所有机器；</p><p>9)<code>ansible webservers -m raw -a &#39;yum -y install python-simplejson&#39;</code><br>用ansible去链接低版本的centos时，就乎出现“ansible requires a json module, none found! ”的错误，需要远程机安装samplejson包。raw模块是靠底层ssh的通讯，不依靠python的模块，所以如果碰到低版本的系统，如果command和shell模块无法使用，可以先用这条命令安装完需要的包。</p><p>10)<code>ansible all -m synchronize -a &quot;src=/chenshuo/1.sh dest=/chenshuo delete=yes&quot;</code><br>synchronize原意是“同步”，而这个模块是分发模块，这句话的意思是把控制端的/chenshuo/1.sh分发给host文件里的所有ip服务器，delete=yes意思是以控制端服务器的文件为准。</p><p>11)<code>ansible 10.168.194.89 -m synchronize -a &quot;mode=pull src=/chenshuo/nba.txt dest=/chenshuo/a.txt&quot;</code><br>将10.168.194.89这台服务器上的/chenshuo/nba.txt拉到控制服务器的/chenshuo文件夹下，顺便改名叫a.txt。</p><p>12)<code>ansible all -m get_url -a &quot;url=https://pypi.python.org/packages/56/2b/9c9c113fb88082950067a42cc99e3c61f1df72035f89bb0bdf0a60308ca0/pexpect-4.1.0.tar.gz#md5=562a1a21f2a60b36dfd5d906dbf0943e dest=/chenshuo&quot;</code><br>把那一大串网址的下载连接下载到host文件里的所有ip的/chenshuo文件夹下。</p><p>13)<code>ansible 10.117.14.37 -m script -a &quot;/chenshuo/free.sh&quot;</code><br>在10.117.14.37上执行操作端的free.sh，注意操作端必须要有free.sh这个脚本，而10.117.14.37这台机器上并不一定要有。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://blog.csdn.net/iloveyin/article/details/46982023" target="_blank" rel="noopener">http://blog.csdn.net/iloveyin/article/details/46982023</a></p>]]></content>
    
    <summary type="html">
    
      Ansible的基础用法
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Ansible" scheme="http://yoursite.com/tags/Ansible/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix用户密码忘记怎么办</title>
    <link href="http://yoursite.com/2018/01/17/Zabbix%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E5%BF%98%E8%AE%B0%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <id>http://yoursite.com/2018/01/17/Zabbix用户密码忘记怎么办/</id>
    <published>2018-01-17T03:12:57.000Z</published>
    <updated>2018-01-17T03:30:19.415Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>zabbix的超级用户也是人，人就难免会忘记密码（或者清除了当前浏览器的缓存），忘记密码不要怕，因为zabbix所有的用户数据都是保存在server机器上的mysql里，只要打开<code>zabbix_server.conf</code>，就会查得到mysql的登录账号密码以及zabbix对应的数据库。（这里多说一句，zabbix自带的guest基本就是一个废物，forget it~）</p><p>在zabbix_server机器上输入mysql的账号密码来到mysql里，<code>USE zabbix</code>，然后<code>SELECT * FROM users</code>,就会看到笔者的画面。<br><img src="/images/zabbix_user1.png" alt="akb48"></p><p>这个时候就可以使用数据库的update命令去更改密码，比如说新的密码是“woshitiancai”，就可以写<code>update  users set passwd=md5(&quot;woshitiancai&quot;) where userid=&#39;1&#39;;</code><br>然后就可以用woshitiancai来登陆啦~</p><p>但是！！！你以为这就结束了吗？nononono！！！</p><p>很多人即使更改了密码还是登陆不上去，很简单，那就是你连用户名都忘记了！或者是用户名你记得但是你手贱在zabbix的administration里的users对原来的设定增加了新东西，而且这些东西还特么的是中文！！！于是就像我上面图那样出现了???的字样。</p><p>那些？？？很重要吗？当然了！！！因为那些才是zabbix的登录用户名！！！看见了吗，zabbix使用蛋疼的alias作为真正的登录名而不是用name or surname，这真是一个蛋疼的事儿！</p><p>那么剩下的问题很简单了，就是把???改变成中文，使用语句<code>set names utf8;</code> 然后界面就成了这样：<br><img src="/images/zabbix_user2.png" alt="akb48"></p><p>这次再使用“主管理员”搭配新的密码就可以华丽的登录了！~~我他妈当时都差点要把这个user表格删掉然后重拽一个表格进来，但是终于还是被我识破了，啊哈哈哈哈，我真是个天才！！！</p>]]></content>
    
    <summary type="html">
    
      忘记密码不要怕!
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Docker出现客户端与服务端有差的错误...</title>
    <link href="http://yoursite.com/2018/01/16/Docker%E5%87%BA%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%9C%89%E5%B7%AE%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/01/16/Docker出现客户端与服务端有差的错误/</id>
    <published>2018-01-16T00:36:32.000Z</published>
    <updated>2018-01-16T00:42:01.519Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天用docker搞redis镜像的的时候，出现了这样的错误提示：<code>Error response from daemon: client is newer than server (client API version: 1.24, server API version: 1.22)</code>，如图：<br><img src="/images/docker1.png" alt="akb48"></p><p>可见使用了<code>docker version</code>的时候也有提示：当前docker客户端比服务端版本更新。这样是无法创建镜像的，遇到这个问题很简单，那就是重启一下docker，命令如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></p><p>然后我们再<code>docker version</code>看一下效果：<br><img src="/images/docker2.png" alt="akb48"></p><p>我做这个的时候，docker升级了也一样可以读到原先的镜像，但是出于保险起见我们也应该学会如何保存和导入镜像，比如现在我现在有这个叫<code>docker.io/ubuntu</code>的镜像，如图：<br><img src="/images/docker3.png" alt="akb48"></p><p>如果要备份它的话，语句就是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save docker.io/ubuntu &gt; <span class="regexp">/root/u</span>buntu.image</span><br></pre></td></tr></table></figure></p><p>这里备份后的文件名就是ubuntu.image。</p><p>如果要导入的话，语句就是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; <span class="regexp">/root/u</span>buntu.image</span><br></pre></td></tr></table></figure></p><p>这样导入的话，images create时间是不变的。</p>]]></content>
    
    <summary type="html">
    
      一不小心手欠，执行了一下yum -y update...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>记录日志系统ELKB 5.6.4的搭建过程</title>
    <link href="http://yoursite.com/2018/01/16/%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9FELKB-5-6-4%E7%9A%84%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/16/记录日志系统ELKB-5-6-4的搭建过程/</id>
    <published>2018-01-15T23:59:43.000Z</published>
    <updated>2018-01-16T00:43:18.881Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>ELK是最近比较流行的免费的日志系统解决方案，注意，ELK不是一个软件名，而是一个结局方案的缩写，即<code>Elasticsearch+Logstash+Kibana（ELK Stack）</code>。这哥几个都是java系的产品，但是众所周知，java的东西很吃内存和CPU，Logstash在当作为收集日志的Agent时，就显得太过臃肿了。听说直播平台“斗鱼”团队很为logstash占用资源的情况很而苦恼，后来为了解决这个问题，他们自己写了一个agent。不过后来官方在logstash-forwarder的基础上推出了beat系列，里面包括四个兄弟，分别是：Packetbeat（搜集网络流量数据）；Topbeat（搜集系统、进程和文件系统级别的 CPU 和内存使用情况等数据）；Filebeat（搜集文件数据）；Winlogbeat（搜集 Windows 事件日志数据）。而Filebeat也就这样加入了“日志收集分析”的团队里，所以虽然大家还是习惯性的叫ELK，其实准确的说法已经是ELKB了。</p><p>ELKB这几个哥们的分工如下：</p><ol><li>Elasticsearch：分布式搜索和分析引擎，具有高可伸缩、高可靠和易管理等特点。基于 Apache Lucene 构建，能对大容量的数据进行接近实时的存储、搜索和分析操作。通常被用作某些应用的基础搜索引擎，使其具有复杂的搜索功能；</li><li>Logstash：数据收集额外处理和数据引擎。它支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储到用户指定的位置；</li><li>Kibana：数据分析和可视化平台。通常与 Elasticsearch 配合使用，对其中数据进行搜索、分析和以统计图表的方式展示；</li><li>Filebeat：ELK 协议栈的新成员，在需要采集日志数据的 server 上安装 Filebeat，并指定日志目录或日志文件后，Filebeat 就能读取数据，迅速发送到 Logstash 进行解析，亦或直接发送到 Elasticsearch 进行集中式存储和分析。</li></ol><h2><span id="设计架构">设计架构</span></h2><p><img src="/images/elk1.png" alt="办公室"></p><p>本文的设计结构就是这样，其中红色的redis/RebbitMQ部分可以省略（我这个例子里暂省略），让日志直接传递到logstash，如果日志量较大，最好还是添加上redis，同时再横向扩容Elasticsearch，搞成一个集群。</p><p>对于这几个模块服务器多说几句：<br>1）Logstash要选择计算能力强的，CPU和内存比较丰满的；<br>2）Elasticsearch要选择磁盘容量大的，同时CPU和内存也比较丰满的；</p><h2><span id="实验软件版本">实验软件版本</span></h2><p>Elasticsearch 5.6.4<br>Logstash 5.6.4<br>Kibana 5.6.4<br>Filebeat 5.6.4<br>Java 1.8+，安装方法：<code>http://blog.51cto.com/chenx1242/2043924</code><br>由于ELKB这几个东西都是墙外的，墙内的下载可能会比较费劲。所以我稍后会把所有ELKB的5.6.4程序都放在51CTO的存储空间里，需要的朋友可以去下载，还是那话，虽然ELK升级频率很快，但是5.6.4已经足够稳定了。</p><h2><span id="实验服务器情况">实验服务器情况</span></h2><p><img src="/images/elk2.png" alt="办公室"></p><h2><span id="安装elasticsearch-564以下所有操作都是root下进行的">安装Elasticsearch 5.6.4（以下所有操作都是root下进行的）</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https:<span class="comment">//artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.6.4.rpm</span></span><br><span class="line">rpm -ivh elasticsearch<span class="number">-5.6</span><span class="number">.4</span>.rpm</span><br></pre></td></tr></table></figure></code></pre><p>然后编辑<code>/etc/elasticsearch/elasticsearch.yml</code>，不然的话logstash无法与之相连：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: my-application  #如果是集群的es就把这个打开，Elasticsearch 启动时会根据配置文件中设置的集群名字（cluster.name）自动查找并加入集群，端口是9300</span><br><span class="line">network.host: 0.0.0.0    #取消注释，并且改成0.0.0.0</span><br><span class="line">http.port: 9200    #取消注释</span><br></pre></td></tr></table></figure></p><p>保存之后，启动并且添加开机启动：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start elasticsearch     </span><br><span class="line">systemctl enable elasticsearch</span><br></pre></td></tr></table></figure></p><p>使用<code>curl localhost:9200</code>能看到这样的情景就证明已经成功启动了：<br><img src="/images/elk3.png" alt="办公室"></p><h2><span id="安装kibana-564-以下所有操作都是root下进行的">安装kibana 5.6.4 (以下所有操作都是root下进行的)</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https:<span class="comment">//artifacts.elastic.co/downloads/kibana/kibana-5.6.4-linux-x86_64.tar.gz</span></span><br><span class="line">tar xzvf kibana<span class="number">-5.6</span><span class="number">.4</span>-linux-x86_64.tar.gz</span><br><span class="line">cd kibana<span class="number">-5.6</span><span class="number">.4</span>-linux-x86_64/</span><br><span class="line">vim config/kibana.yml</span><br></pre></td></tr></table></figure></code></pre><p>把kibana.yml里的<code>server.host: localhost</code>改成<code>server.host: 0.0.0.0</code>，然后保存退出，在kibana的bin文件夹里执行<code>./kibana</code>即可。如果要后台启动就是<code>nohup /kibana安装路径/bin/kibana &amp;</code>。</p><p>启动之后，如图：<br><img src="/images/elk4.png" alt="办公室"></p><h2><span id="安装logstash-564以下所有操作都是root下进行的">安装Logstash 5.6.4（以下所有操作都是root下进行的）</span></h2><pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https:<span class="comment">//artifacts.elastic.co/downloads/logstash/logstash-5.6.4.rpm </span></span><br><span class="line">rpm -ivh logstash<span class="number">-5.6</span><span class="number">.4</span>.rpm</span><br></pre></td></tr></table></figure></code></pre><p>如果安装的时候爆错：<code>/usr/share/logstash/vendor/jruby/bin/jruby: line 388: /usr/bin/java: No such file or directory</code>。那么就先<code>which java</code>查看一下java的文件，然后做一个软连接过去，然后重装logstash即可，如图：<br><img src="/images/elk5.png" alt="办公室"></p><p><img src="/images/elk6.png" alt="办公室"></p><p>用户可以使用TLS双向认证加密Filebeat和Logstash的连接，保证Filebeat只向可信的Logstash发送加密的数据（如果你的logstash和filebeat是内网通信，而且你认可当前内网的安全度，这一步可以省略）。同样的，Logstash也只接收可信的Filebeat发送的数据。这个功能默认是关闭的，要开启的话需要先<code>vim /etc/pki/tls/openssl.cnf</code>，如图：<br><img src="/images/elk7.png" alt="办公室"></p><p>找到<code>[ v3_ca ]</code>的字段，在底下添加<code>subjectAltName = IP:logstash的内网IP</code>字段，保存退出来到/etc/pki/tls/，执行下面命令：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -days <span class="number">365</span> -batch -nodes -newkey rsa:<span class="number">2048</span> -keyout private/logstash-forwarder.key -out certs/logstash-forwarder.crt</span><br></pre></td></tr></table></figure></p><p>来生成一个期限为365天的IP SAN证书对，如果想生成一个十年的证书，就把365改成3650即可，如图：</p><p>安装完毕之后，<code>vim /etc/logstash/logstash.yml</code>，编辑成如下的样子：<br><img src="/images/elk8.png" alt="办公室"></p><p>然后在<code>/etc/logstash/</code>下手动建立一个目录conf.d，在conf.d里新建一个<code>logstash.conf</code>的文件，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ cat /usr/local/logstash/config/conf.d/logstash.conf</span><br><span class="line">#在输入部分，配置Logstash通信端口以及添加SSL证书，从而进行安全通信。</span><br><span class="line">input &#123;</span><br><span class="line"> beats &#123;</span><br><span class="line">   port =&gt; <span class="number">5044</span></span><br><span class="line">   ssl =&gt; <span class="literal">true</span></span><br><span class="line">   ssl_certificate =&gt; <span class="string">"/etc/pki/tls/certs/logstash-forwarder.crt"</span></span><br><span class="line">   ssl_key =&gt; <span class="string">"/etc/pki/tls/private/logstash-forwarder.key"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#在过滤器部分，我们将使用Grok来解析这些日志，然后将其发送到Elasticsearch。以下grok过滤器将查找“syslog”标记的日志，并尝试解析它们，以生成结构化索引。</span><br><span class="line">filter &#123;</span><br><span class="line"> <span class="keyword">if</span> [type] == <span class="string">"syslog"</span> &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      match =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"%&#123;SYSLOGTIMESTAMP:syslog_timestamp&#125; %&#123;SYSLOGHOST:syslog_hostname&#125; %&#123;DATA:syslog_program&#125;(?:\[%&#123;POSINT:syslog_pid&#125;\])?: %&#123;GREEDYDATA:syslog_message&#125;"</span> &#125;</span><br><span class="line">      add_field =&gt; [ <span class="string">"received_at"</span>, <span class="string">"%&#123;@timestamp&#125;"</span> ]</span><br><span class="line">      add_field =&gt; [ <span class="string">"received_from"</span>, <span class="string">"%&#123;host&#125;"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">    syslog_pri &#123; &#125;</span><br><span class="line">    date &#123;</span><br><span class="line">      match =&gt; [ <span class="string">"syslog_timestamp"</span>, <span class="string">"MMM  d HH:mm:ss"</span>, <span class="string">"MMM dd HH:mm:ss"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#输出部分，我们将定义要存储的日志位置</span><br><span class="line">output &#123;</span><br><span class="line">elasticsearch &#123;</span><br><span class="line"> hosts =&gt; [ "10.162.80.192:9200" ]                #这个地址是elasticsearch的内网地址</span><br><span class="line">index =&gt; "filebeat-%&#123;+YYYY.MM.dd&#125;"#设定这个是索引</span><br><span class="line">   #index =&gt; "auclogstash-%&#123;+YYYY.MM.dd&#125;"    #这行是后来作实验的，可以忽视            </span><br><span class="line">user =&gt; elastic                    #这个是为了将来装x-pack准备的</span><br><span class="line">password =&gt; changeme                #同上</span><br><span class="line">      &#125;</span><br><span class="line">stdout &#123;</span><br><span class="line">   codec =&gt; rubydebug</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后就是启动并且添加开机自启动:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start logstash        </span><br><span class="line">systemctl enable logstash</span><br></pre></td></tr></table></figure></p><h2><span id="安装filebeat以下所有操作都是root下进行的">安装filebeat（以下所有操作都是root下进行的）</span></h2><p>在模块服务器上安装filebeat的方法如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https:<span class="comment">//artifacts.elastic.co/downloads/beats/filebeat/filebeat-5.6.4-x86_64.rpm </span></span><br><span class="line">rpm -ivh filebeat<span class="number">-5.6</span><span class="number">.4</span>-x86_64.rpm</span><br></pre></td></tr></table></figure></p><p>之前在logstash上生成了一个IP SAN证书，现在需要把这个证书传递给filebeat的机器里，使用scp语句如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -pr root@10.162.80.171:/etc/pki/tls/certs/logstash-forwarder.crt /etc/ssl/certs/        #10.162.80.171就是logstash的内网IP</span><br></pre></td></tr></table></figure></p><p>输入logstash的密码，并且密钥文件复制完毕之后，需要修改filebeat.yml，于是#vim /etc/filebeat/filebeat.yml：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@func-auc-001 log]# grep -iv '#' /etc/filebeat/filebeat.yml | grep -iv '^$'</span><br><span class="line">filebeat.prospectors:</span><br><span class="line">- input_type: log</span><br><span class="line">  paths:</span><br><span class="line">    -  <span class="regexp">/mnt/</span>hswx/auc/logs<span class="comment">/*.log        #这个是那个auc模块的路径</span></span><br><span class="line"><span class="comment">    -    /第二个日志路径/*.log                   #如果有第二个文件路径的话</span></span><br><span class="line"><span class="comment">  tail_files: true                                 #从文件末尾开始读取</span></span><br><span class="line"><span class="comment">  document_type: "newnginx-api"                    #logstash那里已经设定了index，如果要使用了document_type，那么在logstash的index就要这么写："%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line"><span class="comment">  # 以下是规避数据热点的优化参数：</span></span><br><span class="line"><span class="comment">    spool_size: 1024         # 积累1024条消息才上报</span></span><br><span class="line"><span class="comment">    idle_timeout: "5s"        # 空闲5s上报</span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">output.logstash:</span></span><br><span class="line"><span class="comment">  hosts: ["10.162.80.171:5044"]            #这个地方要写logstash的内网地址</span></span><br><span class="line"><span class="comment">  ssl.certificate_authorities: ["/etc/ssl/certs/logstash-forwarder.crt"]    #这里就是刚刚复制的那个密钥文件路径</span></span><br><span class="line"><span class="comment">  #注意上面是ssl而不是tls，1.0版本才是tls，如果这个写错了，启动的时候会出现“read: connection reset by peer”的错误</span></span><br></pre></td></tr></table></figure></p><p>注意！Filebeat的配置文件采用YAML格式，这意味着缩进非常重要！请务必使用与这些说明相同数量的空格。</p><p>保存之后，使用<code>/etc/init.d/filebeat start</code>启动filebeat，如图：<br><img src="/images/elk10.png" alt="办公室"></p><h2><span id="故障解决">故障解决</span></h2><p>ELK几个部件现在都已经启动了，并且互相telnet端口都是通的，在elasticsearch的服务器上使用<code>curl -XGET &#39;http://elasticsearch内网IP:9200/filebeat-*/_search?pretty&#39;</code>却出现这样的情况：<br><img src="/images/elk9.png" alt="办公室"></p><p>而使用<code>tailf /var/log/filebeat/filebeat</code>去查看filebeat的日志是这样的：<br><img src="/images/elk11.png" alt="办公室"></p><p>再看看logstash-plain.log，里面的情况是这样的：<br><img src="/images/elk12.png" alt="办公室"></p><p>从此可见，filebeat与logstash的联系是error状态，那么停止filebeat的进程，改用<code>/etc/init.d/filebeat start -c /etc/filebeat/filebeat.yml</code>，重新在elasticsearch的服务器上使用<code>curl -XGET &#39;http://elasticsearch内网IP:9200/filebeat-*/_search?pretty&#39;</code>发现已经成功读到了我们之前配置的目录“/mng/hswx/auc/log”，如图：<br><img src="/images/elk13.png" alt="办公室"></p><h2><span id="配置kibana">配置kibana</span></h2><p>在浏览器输入<code>kibana服务器外网IP：5601</code>打开kibana的web界面，把<code>idenx pattern</code>的地方改成<code>filebeat-*</code>(同之前配置的index索引一致)，然后点击<code>create</code>，如图：<br><img src="/images/elk14.png" alt="办公室"></p><p>然后就得到了细节的web界面，如图：<br><img src="/images/elk15.png" alt="办公室"></p><p>点击左侧框的<code>Discover</code>，就会看到梦寐以求的日志web界面，如图：<br><img src="/images/elk16.png" alt="办公室"></p><p>看一下红色框的内容里面有时间，有host主机，有source来源，还有具体的日志信息，我们再去func-auc-001这个日志源主机上查询一下日志：<br><img src="/images/elk17.png" alt="办公室"></p><p>两个日志是一样的，可见实现了预期的日志展示的目标！</p><p>最后一步，就是把kibana与nginx联系起来（也可以把kibana做阿里云负载均衡的后端服务器），这样通过nginx/负载均衡来访问kibana的界面，对kibana来说更安全。配置端口监听如图，再把kibana服务器挂在负载均衡后面即可。<br><img src="/images/elk18.png" alt="办公室"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-elk-filebeat/index.html</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-elk/</a><br><a href="http://www.jinsk.vip/2017/05/24/elksetup/" target="_blank" rel="noopener">http://www.jinsk.vip/2017/05/24/elksetup/</a><br><a href="https://renwole.com/archives/661" target="_blank" rel="noopener">https://renwole.com/archives/661</a><br><a href="https://www.zybuluo.com/dume2007/note/665868" target="_blank" rel="noopener">https://www.zybuluo.com/dume2007/note/665868</a><br><a href="https://www.elastic.co/guide/en/beats/libbeat/5.6/getting-started.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/libbeat/5.6/getting-started.html</a><br><a href="https://discuss.elastic.co/search?q=ERR%20Failed%20to%20publish%20events%20caused%20by%3A%20read%20tcp" target="_blank" rel="noopener">https://discuss.elastic.co/search?q=ERR%20Failed%20to%20publish%20events%20caused%20by%3A%20read%20tcp</a><br><a href="http://jaminzhang.github.io/elk/ELK-config-and-use-Filebeat/" target="_blank" rel="noopener">http://jaminzhang.github.io/elk/ELK-config-and-use-Filebeat/</a> （这个博主很好，但是就是博客无法留言，这点比较坑）</p>]]></content>
    
    <summary type="html">
    
      从搭建ELK开始日志分析之路
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="ELK" scheme="http://yoursite.com/tags/ELK/"/>
    
      <category term="大数据分析" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>从“No space left on device”到删除海量文件</title>
    <link href="http://yoursite.com/2018/01/16/%E4%BB%8E%E2%80%9CNo-space-left-on-device%E2%80%9D%E5%88%B0%E5%88%A0%E9%99%A4%E6%B5%B7%E9%87%8F%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/01/16/从“No-space-left-on-device”到删除海量文件/</id>
    <published>2018-01-15T16:48:39.000Z</published>
    <updated>2018-01-15T16:56:02.479Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>开发发现某个云服务器无法启动进程，提示“No space left on device”，但是使用<code>df -h</code>查看容量的时候，明明还有很多的空间。于是使用<code>df -i</code>，发现inode节点已经全部用光了，所以现在不能建立任何新的文件。如图：<br><img src="/images/df1.png" alt="办公室"></p><p>既然如此就要查出来是哪个文件夹里会有如此多的文件来占用这些inode,使用一个小脚本：<code>for i in /*; do echo $i; find $i | wc -l; done</code>，获取到/mnt下有一个文件占用了绝大多数的inode，如图：<br><img src="/images/df2.png" alt="办公室"></p><p>于是就进入到mnt这个文件夹里，慢慢找寻到底是哪个文件夹，用上面那个语句一点一点缩小范围，最后确定文件夹原来就是data文件夹，如图：<br><img src="/images/df3.png" alt="办公室"></p><p>现在如果要<code>rm -rf data/*</code>的话，是没有效果的，有效果的话也很慢。而且很有可能报<code>-bash: /bin/rm: Argument list too long</code>的错，因为这个文件夹里面的小文件实在太多了，有足足两百五十多万个，那么怎么样处理这样的情况？</p><p>用find搭配-type f -exec rm {} \;可能会引起内存溢出，用文件夹重置命令搭配”–reference” 也没什么效果。</p><p>这时最好的方法就是使用<code>rsync</code>!</p><p>先<code>yum install rsync</code>，当然了现在inode是饱和的状态，yum install是会报错的：<br><img src="/images/df4.png" alt="办公室"></p><p>那么就需要手动删除一些文件，腾出来一部分inode供yum使用，安装完毕rsync之后，找到一个空文件夹，如果没有空文件夹，就手动建立一个。 </p><p>使用命令：<code>rsync --delete-before -a -H -v --progress --stats /空文件夹的路径/ /海量小文件的路径/</code></p><pre><code>–delete-before 接收者在传输之前进行删除操作–progress 在传输时显示传输过程-a 归档模式，表示以递归方式传输文件，并保持所有文件属性-H 保持硬连接的文件-v 详细输出模式-stats 给出某些文件的传输状态</code></pre><p>如果你开了这个服务器的两个窗口，一个是执行上面的命令，另一个是在海量文件夹里执行<code>ls</code>，这个时候ls命令是卡死的，过了大约2分钟，就会看到<code>ls</code>展示的文件喷涌而出，整个电脑屏幕好比黑客帝国一样，异常壮观。</p><p>静等大约20分钟，整个文件夹删除干净，inode也释放了97%，世界恢复了清静。<br><img src="/images/df5.png" alt="办公室"></p>]]></content>
    
    <summary type="html">
    
      当吃的比拉的快...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>使用Google Authenticator给ssh进行登录验证</title>
    <link href="http://yoursite.com/2018/01/16/%E4%BD%BF%E7%94%A8Google-Authenticator%E7%BB%99ssh%E8%BF%9B%E8%A1%8C%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/"/>
    <id>http://yoursite.com/2018/01/16/使用Google-Authenticator给ssh进行登录验证/</id>
    <published>2018-01-15T16:39:26.000Z</published>
    <updated>2018-01-15T16:49:15.002Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>普通情况下的服务器登录，是“服务器+密码”这种直白的验证方式，但是这种方式太过简单，一旦密码泄露，服务器就有危险，于是为了安全我们就要在登录上再加一把锁，那就是使用Google Authenticator（谷歌身份验证器）这个工具，在登录的时候进行一次验证，只有“验证通过了”+“密码正确”才能登陆服务器。</p><h2><span id="安装前准备">安装前准备</span></h2><p>1）关闭Selinux ：<code>setenforce 0</code><br>2）安装依赖：<code>yum -y install gcc make pam-devel libpng-devel libtool wget git</code><br>3）添加阿里云epel 源：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RHEL <span class="number">6</span>/Centos <span class="number">6</span></span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http:<span class="comment">//mirrors.aliyun.com/repo/epel-6.repo</span></span><br><span class="line">RHEL <span class="number">7</span>/Centos <span class="number">7</span></span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http:<span class="comment">//mirrors.aliyun.com/repo/epel-7.repo</span></span><br></pre></td></tr></table></figure></p><p>4）安装Qrencode，谷歌身份验证器需要调用该程序生成二维码并显示：<code>yum install -y qrencode</code></p><h2><span id="安装谷歌身份验证器">安装谷歌身份验证器</span></h2><p>这个时候很多教程会让你去执行<code>git clone https://github.com/google/google-authenticator.git</code>，然而现在这个git里面已经不再含有libpam这个文件夹了，下载下来是一个错误的包，那么这个时候你可以使用<code>yum install google-authenticator</code>，不过yum安装的身份验证器的版本很老，这个时候可以执行<code>wget https://github.com/google/google-authenticator-libpam/archive/1.04.tar.gz</code>。</p><p>下载下来1.0.4版本的然后拆包解压缩，里面是这样几个文件：<br><img src="/images/google1.png" alt="办公室"></p><p>然后就<code>./bootstrap.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install</code>进行编译和安装。</p><p>安装过程完毕之后，还要复制google身份验证器pam模块到系统下，命令是：<code>cp /usr/local/lib/security/pam_google_authenticator.so /lib64/security/</code>。</p><h2><span id="调整登陆方式">调整登陆方式</span></h2><p>1）编辑<code>/etc/pam.d/sshd</code>这个文件，我这个centos的版本是7.0的，里面的内容可能跟centos 6.x的优点不同，不过没关系，就需要插入黄色框内的<code>auth required pam_google_authenticator.so</code>，如图：<br><img src="/images/google2.png" alt="办公室"></p><p>修改完毕之后，保存退出。</p><p>注意！修改了这步之后，服务器千万不能断开连接，否则再连是需要google验证码的，而我们现在还没有生成码，所以肯定是无法连接服务器，如果是云服务器，可以通过登陆控制台的方式把这个文件修改回来，如果是实体服务器，那就呵呵呵了。</p><p>2）编辑<code>/etc/ssh/sshd_config</code>，就修改一个地方：<code>ChallengeResponseAuthentication yes</code><br>3）保存退出之后，重启一下ssh服务：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RHEL6 /Centos6：Service sshd restart</span><br><span class="line">RHEL7 /Centos7：Systemctl resart sshd</span><br></pre></td></tr></table></figure></p><h2><span id="生成登陆验证码">生成登陆验证码</span></h2><p>这次以root用户为例，那么切换成root用户执行下面的过程。<br>1）执行<code>google-authenticator</code>，由于我们之前已经安装了<code>qrencode</code>，那么这个时候会生成一个超级超级巨大的二维码，给各位感受一下：<br><img src="/images/google3.png" alt="办公室"></p><p>红色内容是生成的密钥，很重要。绿色的内容是备用的紧急救助码，紧急救助码就是当你无法获取认证码时（比如手机丢了），可以当做认证码来用，每用一个少一个，但其实可以手动添加的，建议如果 root 账户使用 Google Authenticator 的话一定要把紧急救助码另外保存一份。</p><pre><code>Do you want me to update your &quot;/home/test/.google_authenticator&quot; file? (y/n) y</code></pre><p>是否更新用户的 Google Authenticator 配置文件，选择 y 才能使上面操作对当前用户生效，其实就是在对应用户的 Home 目录下生成了一个 .google_authenticator 文件，如果你想停用这个用户的 Google Authenticator 验证，只需要删除这个用户 Home 目录下的 .google_authenticator 文件就可以了。</p><pre><code>Do you want to disallow multiple uses of the same authentication token? This restricts you to one login about every 30s, but it increases your chances to notice or even prevent man-in-the-middle attacks (y/n) y</code></pre><p>每次生成的认证码是否同时只允许一个人使用？这里选择 y。</p><pre><code>By default, tokens are good for 30 seconds. In order to compensate for possible time-skew between the client and the server, we allow an extra token before and after the current time. If you experience problems with poor time synchronization, you can increase the window from its default size of +-1min (window size of 3) to about +-4min (window size of 17 acceptable tokens). Do you want to do so? (y/n) n</code></pre><p>是否增加时间误差？这里随便选择， ny都可以。</p><pre><code>If the computer that you are logging into isn&apos;t hardened against brute-force login attempts, you can enable rate-limiting for the authentication module. By default, this limits attackers to no more than 3 login attempts every 30s. Do you want to enable rate-limiting (y/n) y</code></pre><p>是否启用次数限制？这里选择 y，默认每 30 秒最多尝试登录 3 次。</p><p>如果想要写成脚本的话，那么上面交互式的设置也可用通过参数一次性设置：<code>google-authenticator -t -f -d -l test@chen.super -i MR.chen -r 3 -R 30 -W</code>。</p><p>-I和-i是可以随便写的，但是-i后期可以改，-I不能改。</p><h2><span id="搭配手机端">搭配手机端</span></h2><p>如果手机是ios，就去apple store里搜索“Google Authenticator”，如果是安卓，就去应用商店搜索“谷歌动态口令”。</p><p>安装完后，打开App，点击“开始设置”，选择“扫描条形码”扫描上面google-authenticator命令生成的二维码，或者是选择“输入密钥”，然后手机上就能看到对应的六位数认证码了。</p><p>最后一步，返回xshell，修改登陆方式，设置登陆方法为<code>Keyboard Interactive</code>，如图：<br><img src="/images/google4.png" alt="办公室"></p><p>这个时候，推荐各位保留原有的ssh不要动，在另外一个xshell窗口登陆一下看看效果，如果正常的话，这个时候会看到系统会让你先输入一个<code>Verification code</code>。这个值就是手机里的那个六位数，然后再输入密码，只有两个都是正确的，才能登陆！</p><p>至此整个配置完成，如果登陆时遇到问题，请查看日志文件<code>/var/log/secure</code>。</p><h2><span id="更改存储位置">更改存储位置</span></h2><p>在生成二维码那一步的时候，如果你错过了记住密钥也不要怕，系统会自动把密钥和紧急救助码保存在<code>~/.google_authenticator</code>这个文件里。</p><p>如果想要改变密钥存储位置，请使用–secret参数:<code>google-authenticator --secret=&quot;/文件路径/用户名&quot;</code>。</p><p>然后更改/etc/pam.d/sshd内的路径配置:<code>auth required pam_google_authenticator.so user=root secret=/PATH_FOLDER/${USER}</code>。</p><p>上面那句话里“user=root” 用于强制PAM使用root用户权限来搜索文件。</p><p>另外请注意，由于我们当时切换成了root用户，所以密钥文件的所有者是root，生成文件的用户只能读取文件(chmod: 400)：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown root.root /PATH_FILE/SECRET_KEY_FILES</span><br><span class="line">chmod <span class="number">400</span> /PATH_FILE/SECRET_KEY_FILES</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      给Linux服务器再加一把锁
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>记录一次处理https监听不正确的过程</title>
    <link href="http://yoursite.com/2018/01/12/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86https%E7%9B%91%E5%90%AC%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/01/12/记录一次处理https监听不正确的过程/</id>
    <published>2018-01-12T11:58:54.000Z</published>
    <updated>2018-01-12T12:08:18.111Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天开发反馈在测试金山云设备的时候遇到了这样的一个现象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8 </span></span><br><span class="line">-<span class="number">-2017</span><span class="number">-07</span><span class="number">-26</span> <span class="number">11</span>:<span class="number">49</span>:<span class="number">26</span>--  https:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8  </span></span><br><span class="line">Resolving funchlscdn.lechange.cn... <span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span> </span><br><span class="line">Connecting to funchlscdn.lechange.cn|<span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span>|:<span class="number">443.</span>.. connected. </span><br><span class="line">OpenSSL: error:<span class="number">140770</span>FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol </span><br><span class="line">Unable to establish SSL connection.</span><br></pre></td></tr></table></figure></p><p>爆“error:140770FC:SSL routines:SSL23_GET_SERVER_HELLO:unknown protocol”的错误，就是在当向只提供http的服务发送https请求造成的。</p><p><code>ping funchlscdn.lechange.cn</code>，获得了这个域名对应的IP之后，返回到金山云的控制台查询这个IP，发现这个IP是一个负载均衡，但是这个负载均衡配置的时候对80端口是http协议，而对443端口还是http协议，于是更改成https，重新测试之后，发现错误变成了这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@js-develop ~]# wget https://funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8 </span><br><span class="line">-<span class="number">-2017</span><span class="number">-07</span><span class="number">-26</span> <span class="number">16</span>:<span class="number">08</span>:<span class="number">15</span>--  https:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8</span></span><br><span class="line">Resolving funchlscdn.lechange.cn... <span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span></span><br><span class="line">Connecting to funchlscdn.lechange.cn|<span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span>|:<span class="number">443.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">502</span> Bad Gateway</span><br><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-26</span> <span class="number">16</span>:<span class="number">08</span>:<span class="number">15</span> ERROR <span class="number">502</span>: Bad Gateway.</span><br></pre></td></tr></table></figure></p><p>在浏览器打开效果如图：</p><p>502 Bad Gateway<br>The proxy server received an invalid response from an upstream server. </p><hr><p>KSYUN ELB 1.0.0 </p><p>同时发现金山云负载均衡里对nginx的8000健康检查是“异常”。但是使用http访问却是可以的，效果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@js-develop ~]# wget http://funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8 </span><br><span class="line">-<span class="number">-2017</span><span class="number">-07</span><span class="number">-26</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">55</span>--  http:<span class="comment">//funchlscdn.lechange.cn/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8</span></span><br><span class="line">Resolving funchlscdn.lechange.cn... <span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span></span><br><span class="line">Connecting to funchlscdn.lechange.cn|<span class="number">120.92</span><span class="number">.158</span><span class="number">.134</span>|:<span class="number">80.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">302</span> Found</span><br><span class="line">Location: http:<span class="comment">//120.92.133.76:8090/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8 [following]</span></span><br><span class="line">-<span class="number">-2017</span><span class="number">-07</span><span class="number">-26</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">55</span>--  http:<span class="comment">//120.92.133.76:8090/LCLR/2K02135PAK01979/0/0/20170726085033/dev_20170726085033_lpxh73ezzb92xxa8.m3u8</span></span><br><span class="line">Connecting to <span class="number">120.92</span><span class="number">.133</span><span class="number">.76</span>:<span class="number">8090.</span>.. connected.</span><br><span class="line">HTTP request sent, awaiting response... <span class="number">200</span> OK</span><br><span class="line">Length: <span class="number">66</span> [application/x-mpegURL]</span><br><span class="line">Saving to: “dev_20170726085033_lpxh73ezzb92xxa8.m3u8”</span><br><span class="line"><span class="number">100</span>%[========================================================================================================================================================&gt;] <span class="number">66</span>          --.-K/s   <span class="keyword">in</span> <span class="number">0</span>s      </span><br><span class="line"><span class="number">2017</span><span class="number">-07</span><span class="number">-26</span> <span class="number">15</span>:<span class="number">31</span>:<span class="number">55</span> (<span class="number">3.02</span> MB/s) - “dev_20170726085033_lpxh73ezzb92xxa8.m3u8” saved [<span class="number">66</span>/<span class="number">66</span>]</span><br></pre></td></tr></table></figure></p><p>于是就叫来开发问一下http和https详细的流程，开发说在http里，设计路线如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http(<span class="number">80</span>)-&gt;开发模块(<span class="number">9001</span>)</span><br></pre></td></tr></table></figure></p><p>而在https里，设计路线如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https(<span class="number">443</span>)-&gt;nginx(<span class="number">8000</span>)-&gt;开发模块(<span class="number">9001</span>)</span><br></pre></td></tr></table></figure></p><p>这时候就发现了问题，原来最早的时候金山云是没有配置https证书的，于是开发们就用nginx的8000端口去监听ssl这样达到https证书的效果，但是后来金山云控制台添加了https证书，就不再需要nginx去配置ssl证书了，再去https监听8000这一步也就是错误的了，于是在负载均衡那里改成了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https(<span class="number">443</span>)-&gt;开发模块(<span class="number">9001</span>)</span><br></pre></td></tr></table></figure></p><p>同时关闭了nginx，这时候再来测试一下https请求，就成功了！<br><img src="/images/ksslb.png" alt="7牛云存储" title="https返回OK"></p><p>其实如果非要用nginx的ssl证书的话，那么的套路就是：开启nginx，但是在负载均衡那里使用tcp协议去监听nginx的8000端口，这样一样能达到效果。</p>]]></content>
    
    <summary type="html">
    
      什么是人，欲望满身。
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Next主题添加音乐和将侧栏移动到左边</title>
    <link href="http://yoursite.com/2018/01/12/next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90%E5%92%8C%E4%BE%A7%E6%A0%8F%E5%B7%A6%E7%A7%BB/"/>
    <id>http://yoursite.com/2018/01/12/next主题添加音乐和侧栏左移/</id>
    <published>2018-01-12T07:56:38.000Z</published>
    <updated>2018-01-12T11:49:54.752Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>玩Github博客也有一个多月的时间了，现在这个博客也被我折腾的有点样子了，目前博客里添加了如下功能：<br>1.支持头像图片旋转，同时点击头像可以返回主页；<br>2.背景图片随机出现，而且墙内用户也可以顺利访问；<br>3.增加文章打分系统，觉得好可以给五星好评；<br>4.开放评论系统，无需注册直接评论；<br>5.添加了可视加载栏和公益404页面；<br>6.添加桌面小宠物和访客统计；<br>7.添加博客运行时间和代码橙色高亮；</p><p>目前欠缺的功能一个是“相册”，还有一个就是博客标题的加载方式希望更加高逼格。至于SEO和单独域名，我暂时还没有想去做，等将来再加上吧。而这篇文章里主要说的就是“博客添加音乐”和“侧栏左移”这两个事儿。</p><h2><span id="博客添加音乐">博客添加音乐</span></h2><p>Next主题添加网易云音乐不是一个很难的事儿，但是我发现对于非大陆的IP地址（比如我用的是公司VPN，香港IP），侧栏的网易云音乐就无法播放，而且打开博客页面就自动播放音乐这点对来访的用户来说，体验感觉是见仁见智。所以我打算把侧栏的网易云音乐撤掉，在“关于我”里单独放进音乐歌单。</p><p>若单独配置音乐同时不想被IP地址打扰的话可以使用由DIYgod所制作的APlayer。官方材料在这里：<a href="https://aplayer.js.org/docs/#/?id=options" target="_blank" rel="noopener">https://aplayer.js.org/docs/#/?id=options</a> 。</p><p>要使用APlayer需要先在hexo根目录里安装插件：<code>npm install aplayer --save</code></p><p>安装插件OK了后，具体在文章里添加的语法就是：<br><img src="/images/aplayer2.png" alt="7牛云存储" title="好像跟aplayer的语句都会引发错误啊"></p><p>注意：如果lrc用的是这种URL形式，<code>hexo g</code>时请保持网络通畅，如果没有歌词，可以不用添加。</p><p>现在的世面上很少有在线提供歌曲MP3地址的网站了，很多都是下载mp3到本地，这里我推荐一个免费下载MP3的网站：<a href="https://www.tikitiki.cn" target="_blank" rel="noopener">https://www.tikitiki.cn</a> 。里面有QQ音乐、网易云音乐和酷狗的资源，基本上大陆没有被封杀的艺人作品都能在里面找到（抱歉了，陈升先生和黄耀明先生）。然后再搭配七牛云，把下载的MP3和封面图片上传到七牛云存储里，然后搭配提供的外网域名就可以填写MP3地址和封面地址了。如图：<br><img src="/images/7cow.png" alt="7牛云存储" title="MP3上传到七牛云存储"></p><p>如果想做一个歌单，也很简单，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% aplayerlist %&#125;</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">"autoplay"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"showlrc"</span>: <span class="number">3</span>,</span><br><span class="line">   <span class="string">"mutex"</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="string">"music"</span>: [</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="string">"title"</span>: <span class="string">"歌曲名"</span>,</span><br><span class="line">           <span class="string">"author"</span>: <span class="string">"歌手名"</span>,</span><br><span class="line">           <span class="string">"url"</span>: <span class="string">"https://具体地址.mp3"</span>,</span><br><span class="line">           <span class="string">"pic"</span>: <span class="string">"https://封面图.jpg"</span>,</span><br><span class="line">          "lrc": "https://歌词.lrc"#不愿意加歌词可以不写，注意逗号</span><br><span class="line">        &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"歌曲名"</span>,</span><br><span class="line">            <span class="string">"author"</span>: <span class="string">"歌手名"</span>,</span><br><span class="line">            <span class="string">"url"</span>: <span class="string">"https://具体地址.mp3"</span>,</span><br><span class="line">            <span class="string">"pic"</span>: <span class="string">"https://封面图.jpg"</span>,</span><br><span class="line">           <span class="string">"lrc"</span>: <span class="string">"https://歌词.lrc"</span></span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br><span class="line">  &#125;</span><br><span class="line">&#123;% endaplayerlist %&#125;</span><br></pre></td></tr></table></figure></p><p>不过我这个七牛云的账号比较挫，没有做https，只好用http了…</p><h2><span id="把侧栏移动到左边">把侧栏移动到左边</span></h2><p>博客自从安装了宠物之后，发现小宠物与侧栏重叠，看上去感觉很不友好，但是很奇怪，默认的宠物即使调整了botton依旧无法移动，所以我就想那就把整个侧栏移动到了左边，但是发现更改next主题的<code>_config.xml</code>里的“sidebar的position属性”发现并没有效果，后来经过一顿查找，找到了改成左侧栏的方法(适用于next 5.1.3版本)。</p><p>首先，先更改<code>\themes\next\source\css\_common\components\sidebar\sidebar.styl</code>，把第三行的<code>right</code>改成<code>left</code>,如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.sidebar &#123;</span><br><span class="line">  position: fixed;</span><br><span class="line">  left: <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>保存之后，打开<code>\themes\next\source\js\src\motion.js</code>，把101行和167行的<code>paddingRight</code>全改成<code>paddingLeft</code>,同时找到类似如下的代码，并替换成如下代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sidebarToggleLine1st = <span class="keyword">new</span> SidebarToggleLine(&#123;</span><br><span class="line">  el: <span class="string">'.sidebar-toggle-line-first'</span>,</span><br><span class="line"> status: &#123;</span><br><span class="line">   arrow: &#123;<span class="attr">width</span>: <span class="string">'50%'</span>, <span class="attr">rotateZ</span>: <span class="string">'45deg'</span>, <span class="attr">top</span>: <span class="string">'2px'</span>, <span class="attr">left</span>: <span class="string">'5px'</span>&#125;,</span><br><span class="line">   close: &#123;<span class="attr">width</span>: <span class="string">'100%'</span>, <span class="attr">rotateZ</span>: <span class="string">'45deg'</span>, <span class="attr">top</span>: <span class="string">'5px'</span>, <span class="attr">left</span>: <span class="number">0</span>&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sidebarToggleLine2nd = <span class="keyword">new</span> SidebarToggleLine(&#123;</span><br><span class="line">   el: <span class="string">'.sidebar-toggle-line-middle'</span>,</span><br><span class="line"> status: &#123;</span><br><span class="line">   arrow: &#123;<span class="attr">width</span>: <span class="string">'90%'</span>&#125;,</span><br><span class="line">   close: &#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> sidebarToggleLine3rd = <span class="keyword">new</span> SidebarToggleLine(&#123;</span><br><span class="line">   el: <span class="string">'.sidebar-toggle-line-last'</span>,</span><br><span class="line"> status: &#123;</span><br><span class="line">   arrow: &#123;<span class="attr">width</span>: <span class="string">'50%'</span>, <span class="attr">rotateZ</span>: <span class="string">'-45deg'</span>, <span class="attr">top</span>: <span class="string">'-2px'</span>, <span class="attr">left</span>: <span class="string">'5px'</span>&#125;,</span><br><span class="line">   close: &#123;<span class="attr">width</span>: <span class="string">'100%'</span>, <span class="attr">rotateZ</span>: <span class="string">'-45deg'</span>, <span class="attr">top</span>: <span class="string">'-5px'</span>, <span class="attr">left</span>: <span class="number">0</span>&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>保存完毕之后，<code>hexo clean</code>和<code>hexo d -g</code>。刷新一下页面，就大功告成了！</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#hcm=1515719347596232" target="_blank" rel="noopener">https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#hcm=1515719347596232</a> （这篇文章强烈推荐！）<br><a href="http://www.lmnsyunhao.cn/2017/03/29/hexo-next-themes-left-sidebar/" target="_blank" rel="noopener">http://www.lmnsyunhao.cn/2017/03/29/hexo-next-themes-left-sidebar/</a><br><a href="http://mashirosorata.vicp.io/HEXO-NEXT主题个性化配置.html" target="_blank" rel="noopener">http://mashirosorata.vicp.io/HEXO-NEXT主题个性化配置.html</a></p>]]></content>
    
    <summary type="html">
    
      让博客看起来更加舒服更加贴心
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://yoursite.com/tags/Next/"/>
    
      <category term="博客美化" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix监控ActiveMQ队列数以及结合Grafana展示</title>
    <link href="http://yoursite.com/2018/01/11/Zabbix%E7%9B%91%E6%8E%A7ActiveMQ%E9%98%9F%E5%88%97%E6%95%B0%E4%BB%A5%E5%8F%8A%E7%BB%93%E5%90%88Grafana%E5%B1%95%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/01/11/Zabbix监控ActiveMQ队列数以及结合Grafana展示/</id>
    <published>2018-01-11T13:43:01.000Z</published>
    <updated>2018-01-16T00:51:28.820Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="在zabbix上监控mq队列">在ZABBIX上监控MQ队列</span></h2><p>众所周知，Zabbix是可以自定义监控项的，那么就代表只要能获得到的数字都可以进入Zabbix的监控范围内。作为消息队列，Activemq里的“消息堆积数”是监控的重点项目之一。</p><p>获取消息堆积数并不是一个很难的事儿，浏览器里登陆MQ的web网页控制台，输入账号密码之后，在Queues的网页里就能看到如下的界面：<br><img src="/images/mqinfo.png" alt="akb48" title="MQ的界面"></p><p>其中Pending Messages就是“等待消息”，Consumers是“消费者”，Enqueued是“入队”，Dequeued是“出队”。<code>入队数=出队数+等待数</code>。</p><p>现在我们要获取到图中的队列叫AggregateQueue里的那个23596，很简单，shell语句是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -u网站用户名:网站密码 http:<span class="comment">//网站外网IP地址:8161/admin/queues.jsp | grep -A 5 "具体的队列名&lt;/a&gt;&lt;/td&gt;"|awk -F '&lt;' '&#123;print $2&#125;'|sed 's/td&gt;//g'|head -2|tail -1</span></span><br></pre></td></tr></table></figure></p><p>这里curl 有一个“-s”的参数，不然会显示curl的状态。如图：<br><img src="/images/curl+s.png" alt="akb48" title="curl -s的效果"></p><p>语句在此，写脚本就很easy了。不过我这里就直接监控具体数字了，没有写脚本，如果要写python脚本的话，我推荐各位移步：<a href="http://blog.51cto.com/sfzhang88/1316789" target="_blank" rel="noopener">http://blog.51cto.com/sfzhang88/1316789</a> ，看一下这篇文章。</p><p>现在把这个监控项添加到具体的zabbix_agentd.conf里吧，具体添加过程可以参看 <a href="http://blog.51cto.com/chenx1242/1839829" target="_blank" rel="noopener">http://blog.51cto.com/chenx1242/1839829</a> ，由于是curl网站，那么直接把这个监控项加到Zabbix-server里就好，然后使用zabbix_get检查一下。有的zabbix 3.x里没有zabbix_get，安装zabbix_get方法：<code>yum install zabbix-get.x86_64</code>。</p><p>zabbix_get检查情况和具体的trigger情况如下：<br><img src="/images/getMQ.png" alt="akb48" title="zabbix_get检查情况"><br><img src="/images/mqtrigger.png" alt="akb48" title="zabbix_get检查情况"></p><h2><span id="配置zabbix结合grafana">配置Zabbix结合Grafana</span></h2><p>我使用的Grafana版本是4.3.2，下载地址：<a href="https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.3.2-1.x86_64.rpm" target="_blank" rel="noopener">https://s3-us-west-2.amazonaws.com/grafana-releases/release/grafana-4.3.2-1.x86_64.rpm</a>  ，下载完毕之后，直接<code>yum install /路径/grafana-4.3.2-1.x86_64.rpm</code>，由于Grafana使用的是AWS的云存储，可能在墙内的下载会比较吃力，有断开的情况就多试几次。话说Grafana的升级是比较频繁的，半年不到的时间升级了三次，现在最新版本已经是4.6.2。所以说这玩意，其实选择一个稳定的就好。</p><p>启动grafana的方法就是：<code>systemctl start grafana-server.service</code>，配置开机自启动的方法：<code>chkconfig grafana-server on</code>。然后在浏览器里输入<code>grafana外网ip地址：3000</code>就能看到grafana的界面，默认密码：<code>admin/admin</code>，grafana默认的日志存储路径是<code>/var/log/grafana/</code>。</p><p>Grafana与ZABBIX联系的插件下载方式：<code>grafana-cli plugins install alexanderzobnin-zabbix-app</code>，安装之后，重启一下grafana-server，在web界面就会看到插件已经成功安装，如图：<br><img src="/images/grafana1.png" alt="akb48" title="grafana插件web界面"></p><p>其他更多的插件下载可以在grafana的官方网站查看到：<a href="https://grafana.com/plugins" target="_blank" rel="noopener">https://grafana.com/plugins</a> ，用<code>grafana-cli</code>都能搞定，还是那话，墙里的同学速度要慢一点。</p><p>现在配置Zabbix作为Grafana的数据源，首选点击网站上面的红色漩涡标志，选择<code>zabbix</code>，点击<code>Plugin Config</code>，点击<code>Enable</code>，启动Zabbix插件。如图：<br><img src="/images/grafana2.png" alt="akb48" title="启动Zabbix插件"></p><p>再次点击红色漩涡，这次选择<code>Data Sources</code>，点击<code>Add data source</code>，如果插件启动成功，那么在Type里是可以选择<code>zabbix</code>的，然后就是填各种东西，如图：<br><img src="/images/grafana3.png" alt="akb48" title="添加数据源"></p><p>这里有一些要额外说明：<br>1）url这个是zabbix的API地址”<a href="http://ip/zabbix/api_jsonrpc.php&quot;，这个可以在zabbix服务端上可查找&quot;find" target="_blank" rel="noopener">http://ip/zabbix/api_jsonrpc.php&quot;，这个可以在zabbix服务端上可查找&quot;find</a> / -name api_*.php”；<br>2）username和passwd是zabbix WEB界面的登录用户名和密码，有读的权限即可；<br>3）alerting选择启动，min severity选择high；</p><p>然后点击<code>save &amp; test</code>，如果都正确的话，就会出现success，如图：<br><img src="/images/grafana4.png" alt="akb48" title="保存zabbix资料"></p><h2><span id="在grafana展示趋势图">在Grafana展示趋势图</span></h2><p>点击左上方红色漩涡，<code>Dashboards</code>的地方点击<code>+new</code>，然后在小齿轮的地方选择<code>Templating</code>,如图：<br><img src="/images/grafana5.png" alt="akb48" title="趋势图"></p><p>在Templating里要建立4个模板，其中group的添加方法如下，如果Query正确的话，在点击<code>Include All option</code>的时候，就会有“组”显示出，而且和zabbix里完全一致：<br><img src="/images/grafana6.png" alt="akb48" title="添加模板"></p><p>group添加完了，还有host、application、iteams，添加的大同小异，需要注意的是Query的不同：<br>host的Query：<code>$group.*</code><br>application的Query: <code>$group.$host.*</code><br>iterm的Query:<code>$group.$host.$application.*</code></p><p>以上四个template都搞定之后，应该是这个样子：<br><img src="/images/grafana7.png" alt="akb48" title="搞定templage"></p><p>模板搞定了，下面就是图形展示，选择对应的hosts、application和items就自动有图像生成了！<br><img src="/images/grafana8.png" alt="akb48" title="大功告成！"></p><p>最后说一下页面自动刷新，点击右上角“Last 6 hours”, 在弹出的下拉框中，选择Time range下的Refreshing every选项，点击下拉框按钮，默认应该有“off”和“1m”两个选项。点击“1m” 然后Apply设置，即为每一分钟刷新一次数据的意思。设置成功后，在原来Last 6 hours的后面会出现Refresh every 1m的橙色文字！</p><h2><span id="参考资料">参考资料</span></h2><p>《实践MQ的小demo》<a href="http://www.jianshu.com/p/3a39c8dd4f29" target="_blank" rel="noopener">http://www.jianshu.com/p/3a39c8dd4f29</a></p>]]></content>
    
    <summary type="html">
    
      用了Grafana，图像高大上！
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="grafana" scheme="http://yoursite.com/tags/grafana/"/>
    
  </entry>
  
  <entry>
    <title>在Python使用yaml的几个例子</title>
    <link href="http://yoursite.com/2018/01/11/%E5%9C%A8Python%E4%BD%BF%E7%94%A8yaml%E7%9A%84%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2018/01/11/在Python使用yaml的几个例子/</id>
    <published>2018-01-11T02:11:17.000Z</published>
    <updated>2018-01-11T02:43:57.121Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>python版本：<code>2.7.5</code><br>安装方法：<code>pip install PyYaml</code></p><p>“把变量写进yaml做配置文件，然后python脚本从yaml文件里面取到变量”的方法最近是在python编程里比较流行的配置项方法。yaml更加易读，而且通过缩进表示结构，这一点与python不谋而合。</p><p>Yaml有四个比较常用的用法，分别是<code>load()</code>、<code>dump()</code>、<code>load_all()</code>、<code>dump_all()</code>。这篇文章主要就是了解一下这四个方法。</p><p>首先我们先写一个很简单的test.py：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">yaml_str = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">name: Gakki</span></span><br><span class="line"><span class="string">age: 29</span></span><br><span class="line"><span class="string">job: Actress</span></span><br><span class="line"><span class="string">relationship: Wife</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"> </span><br><span class="line">aaa = yaml.load(yaml_str)</span><br><span class="line">print aaa</span><br></pre></td></tr></table></figure></p><p>执行的话，看到的效果就是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">&#123;<span class="string">'job'</span>: <span class="string">'Actress'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'relationship'</span>: <span class="string">'Wife'</span>, <span class="string">'name'</span>: <span class="string">'Gakki'</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这个aaa的类型是一个<code>字典（dict）</code>，如果要得到里面那个”Gakki”，那么就是aaa[‘name’]。通过load方法，一个字符串变成了一个字典。</p><p>现在把test.py换成如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">yaml_dict = &#123;<span class="string">"name"</span>: <span class="string">"Gakki"</span>,</span><br><span class="line">         <span class="string">"age"</span>: <span class="number">29</span>,</span><br><span class="line">         <span class="string">"job"</span>: <span class="string">"Actress"</span>,</span><br><span class="line">         <span class="string">"relationship"</span>: <span class="string">"Wife"</span></span><br><span class="line">              &#125;</span><br><span class="line">aaa = yaml.dump(yaml_dict, default_flow_style=False)</span><br><span class="line">print aaa</span><br><span class="line">print (type(aaa))</span><br></pre></td></tr></table></figure></p><p>执行后的效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">age: <span class="number">29</span></span><br><span class="line">job: Actress</span><br><span class="line">name: Gakki</span><br><span class="line">relationship: Wife</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>可见，通过dump方法，把一个dict变成了一个字符串。</p><p>现在写一个配置文件，假如它叫test.yaml:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Gakki</span><br><span class="line">- <span class="number">29</span></span><br><span class="line">- Actress</span><br><span class="line">- Wife</span><br></pre></td></tr></table></figure></p><p>再来一个test.py，内容如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"> </span><br><span class="line">aaa = yaml.load(file(<span class="string">'test.yaml'</span>, <span class="string">'r'</span>))</span><br><span class="line">print aaa</span><br><span class="line">print (type(aaa))</span><br></pre></td></tr></table></figure></p><p>执行这个test.py：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">[<span class="string">'Gakki'</span>, <span class="number">29</span>, <span class="string">'Actress'</span>, <span class="string">'Wife'</span>]</span><br><span class="line">&lt;type 'list'&gt;    #得到了一个列表</span><br></pre></td></tr></table></figure></p><p>如果把那个test.yaml升级成字典和列表的混合结构，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- name: Chris</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line"> job: OM Engineer</span><br><span class="line">- name: Gakki</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line"> job: Actress</span><br><span class="line"> relationship: Wife</span><br></pre></td></tr></table></figure></p><p>执行test.py的效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">[&#123;<span class="string">'job'</span>: <span class="string">'OM Engineer'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'name'</span>: <span class="string">'Chris'</span>&#125;, &#123;<span class="string">'job'</span>: <span class="string">'Actress'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'relationship'</span>: <span class="string">'Wife'</span>, <span class="string">'name'</span>: <span class="string">'Gakki'</span>&#125;]</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>既然获得的结果是一个包含字典的列表，那么如果要获得“Gakki”就是aaa[1][‘name’]</p><p>如果想要复制和引用，那么要用&amp;和*，比如把test.yaml改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: &amp;name Gakki</span><br><span class="line">wife: *name</span><br></pre></td></tr></table></figure></p><p>执行test.py的效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Gakki'</span>, <span class="string">'wife'</span>: <span class="string">'Gakki'</span>&#125;</span><br><span class="line">&lt;type <span class="string">'dict'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>在同一个yaml文件中，可以用 — 来分段，这样可以将多个文档写在一个文件中：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> name: Chris</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line"> job: OM Engineer</span><br><span class="line">---</span><br><span class="line"> name: Gakki</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line"> job: Actress</span><br><span class="line"> relationship: Wife</span><br></pre></td></tr></table></figure></p><p>再写一个新的test.py如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line">ys = yaml.load_all(file('gakki.yaml', 'r'))    #load_all() 方法会生成一个迭代器，可以用for输出出来</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> ys:</span><br><span class="line">   print y</span><br></pre></td></tr></table></figure></p><p>执行这个py的效果：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">&#123;<span class="string">'job'</span>: <span class="string">'OM Engineer'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'name'</span>: <span class="string">'Chris'</span>&#125;</span><br><span class="line">&#123;<span class="string">'job'</span>: <span class="string">'Actress'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'relationship'</span>: <span class="string">'Wife'</span>, <span class="string">'name'</span>: <span class="string">'Gakki'</span>&#125;</span><br></pre></td></tr></table></figure></p><p>参考文档：<a href="https://huilansame.github.io/huilansame.github.io/archivers/recommond-case-file-type-yaml" target="_blank" rel="noopener">https://huilansame.github.io/huilansame.github.io/archivers/recommond-case-file-type-yaml</a></p><p><img src="/images/todalaugh.gif" alt="抱光妹" title="Toda马笑"></p>]]></content>
    
    <summary type="html">
    
      以后要多用yaml格式做配置文件...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用Zabbix去监控Redis</title>
    <link href="http://yoursite.com/2018/01/10/%E4%BD%BF%E7%94%A8Zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7Redis/"/>
    <id>http://yoursite.com/2018/01/10/使用Zabbix去监控Redis/</id>
    <published>2018-01-10T14:49:04.000Z</published>
    <updated>2018-01-10T15:15:46.273Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="了解redis的info">了解Redis的info</span></h2><p>要获得Redis的当前情况，使用<code>info</code>命令即可。具体用法：<code>redis-cli -h 127.0.0.1 -p 6379 -a redis_passwd info [参数]</code> 。针对不同的参数就会看到具体的数字，如果没有带参数，那么就会把默认情况写出来，如果带上<code>all</code>参数，那么就会把所有情况都写出来。比如：<code>redis-cli -h 127.0.0.1 -p 6379 -a redis_passwd info server</code>，就会看到redis关于server的一些数据，如下：<br><img src="/images/redisinfo.png" alt="抱光妹" title="redis的info内容"><br>可以看出，从server里可以查询到的是版本号、pid号、配置文件路径等等东西。</p><p>如果参数是client，记录了是客户端的相关信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info clients</span><br><span class="line"># Clients</span><br><span class="line">connected_clients:64    #已连接客户端的数量（不包括通过从属服务器连接的客户端）</span><br><span class="line">client_longest_output_list:0    #当前连接的客户端当中，最长的输出列表</span><br><span class="line">client_biggest_input_buf:0    #当前连接的客户端当中，最大输入缓存</span><br><span class="line">blocked_clients:0    #正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</span><br></pre></td></tr></table></figure></p><p>如果参数是memory，记录的是内存的相关信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info memory</span><br><span class="line"># Memory</span><br><span class="line">used_memory:2252984    #由 Redis 分配器分配的内存总量，以字节（byte）为单位</span><br><span class="line">used_memory_human:2.15M    #上面的数字加上了单位</span><br><span class="line">used_memory_rss:9293824    #常驻集大小，即Redis已分配的内存总量。这个值和top、ps等命令的输出一致</span><br><span class="line">used_memory_peak:2607520    #Redis 的内存消耗峰值（以字节为单位）</span><br><span class="line">used_memory_peak_human:2.49M    #上面的数字加上了单位</span><br><span class="line">used_memory_lua:33792    #Lua 引擎所使用的内存大小（以字节为单位）</span><br><span class="line">mem_fragmentation_ratio:4.13    #used_memory_rss 和 used_memory 之间的比率</span><br><span class="line">mem_allocator:jemalloc-3.2.0    #在编译时指定的，Redis所使用的内存分配器。可以是libc、jemalloc或者tcmalloc。</span><br></pre></td></tr></table></figure></p><p>这里要注意！<font color="red">在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿</font>（我这个机器就已经属于严重的级别了）。当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。</p><p>如果参数是stats，那就是统计的相关信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info stats</span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:150383    #服务器已接受的连接请求数量</span><br><span class="line">total_commands_processed:500935    #服务器已执行的命令数量</span><br><span class="line">instantaneous_ops_per_sec:0    #服务器每秒钟执行的命令数量</span><br><span class="line">rejected_connections:0    #因为最大客户端数量限制而被拒绝的连接请求数量</span><br><span class="line">sync_full:<span class="number">0</span>    </span><br><span class="line">sync_partial_ok:<span class="number">0</span>    </span><br><span class="line">sync_partial_err:0    #查找数据库键成功的次数</span><br><span class="line">expired_keys:41    #因为过期而被自动删除的数据库键数量</span><br><span class="line">evicted_keys:0    #因为最大内存容量限制而被驱逐（evict）的键数量</span><br><span class="line">keyspace_hits:78121    #查找数据库键成功的次数</span><br><span class="line">keyspace_misses:56    #查找数据库键失败的次数</span><br><span class="line">pubsub_channels:0    #目前被订阅的频道数量</span><br><span class="line">pubsub_patterns:0    #目前被订阅的模式数量</span><br><span class="line">latest_fork_usec:878    #最近一次 fork() 操作耗费的微秒数</span><br></pre></td></tr></table></figure></p><p>如果参数是CPU，那么就会返回CPU的相关信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info cpu</span><br><span class="line"># CPU</span><br><span class="line">used_cpu_sys:63.95    #Redis服务器耗费的系统CPU</span><br><span class="line">used_cpu_user:129.54    #Redis服务器耗费的用户CPU </span><br><span class="line">used_cpu_sys_children:1.70    #子进程耗费的系统CPU</span><br><span class="line">used_cpu_user_children:1.03    #子进程耗费的用户CPU</span><br></pre></td></tr></table></figure></p><p>如果参数是keyspace，那么就会返回数据库相关的统计信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info keyspace</span><br><span class="line"># Keyspace</span><br><span class="line">db0:keys=262,expires=183,avg_ttl=284091259423    #据库的键数量、数据库设置有过期时间的key的数量（这个值减少是正常的）</span><br></pre></td></tr></table></figure></p><p>除了以上之外其他还有更多信息，请移步：<a href="http://redisdoc.com/server/info.html" target="_blank" rel="noopener">http://redisdoc.com/server/info.html</a> 。感谢前人栽树！！！</p><h2><span id="使用zabbix监控redis">使用zabbix监控redis</span></h2><p>用zabbix监控redis是一个很简单的事儿，只需要把需要监控的数据提取出来即可。而提取数据的方法就是利用info去得到对应的数值。</p><p>首先先来一个判断redis服务器连接的脚本：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# cat check_redis.sh</span><br><span class="line">#这个脚本是用来zabbix监控自建redis的</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">PORT=<span class="string">'6379'</span></span><br><span class="line">PASSWD=‘REDIS密码’ </span><br><span class="line">STATUS_redis=$(redis-cli -h <span class="string">'127.0.0.1'</span> -p $PORT -a $PASSWD ping)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$STATUS_redis"</span> == <span class="string">'PONG'</span> ];then</span><br><span class="line">        echo <span class="string">'1'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        echo <span class="string">'0'</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>然后更改zabbix_agentd.conf,如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=redis_status[*],redis-cli -h <span class="string">'127.0.0.1'</span> -p $<span class="number">1</span> info | grep -w $<span class="number">2</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">UserParameter=redis_ping,sudo sh /root/check_redis.sh</span><br></pre></td></tr></table></figure></p><p>修改/etc/sudoers文件如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">zabbix  ALL=(ALL)       NOPASSWD:ALL    #这个是新增</span><br><span class="line">Defaults:zabbix !requiretty        #这个是新增</span><br></pre></td></tr></table></figure></p><p>保存之后，重启zabbix-agent服务，由于我这个redis是通过zabbix-proxy监控的，所以在zabbix-proxy一端用<code>zabbix_get</code>来查看结果：<br><img src="/images/motiorredis.png" alt="抱光妹" title="zabbix_get到redis内容"></p><p>然后在zabbix-proxy的模板里面添加一些需要监控的item即可，有必要的话可以设置trigger+action用来报警，如图：<br><img src="/images/zabbixredis.png" alt="抱光妹" title="配置item"></p><p>最后就是grafana搞一个炫酷的图表来，如图：<br><img src="/images/grafanaredis.png" alt="抱光妹" title="使用grafana展示成果"></p><p>最后一点，关于redis的内存优化，各位可以来看看：<a href="https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</a> ，写的很全面了。还有zabbix各种模板整理，有需要的同学也可以去下载：<a href="https://monitoringartist.github.io/zabbix-searcher/" target="_blank" rel="noopener">https://monitoringartist.github.io/zabbix-searcher/</a> 。</p>]]></content>
    
    <summary type="html">
    
      要好好对待自己的那个Redis
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>通过nginx配置修改网页cookie属性</title>
    <link href="http://yoursite.com/2018/01/10/%E9%80%9A%E8%BF%87nginx%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5cookie%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/01/10/通过nginx配置修改网页cookie属性/</id>
    <published>2018-01-10T07:48:08.000Z</published>
    <updated>2018-01-10T08:09:04.789Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="需求与具体配置">需求与具体配置</span></h2><p>公司的电子商城在十九大等保安检时期被折腾出去，结果这几天又折腾回来了，据说还会是明年大数据研究院的主要开发项目。结果回来没几天被测试中心的人在cookie方面发现了几个问题，如下：</p><ol><li>cookie没有使用http-only；</li><li>cookie没有携带secure属性；</li><li>http头中需要配置“X-Frame-Options：SAMEORIGIN”；</li></ol><p>以上这几点可以通过nginx的配置来轻松实现，具体方法就是在需要更改的网页server的配置里面添加下面几句话。如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_header                  <span class="built_in">Set</span>-Cookie <span class="string">"HttpOnly"</span>;</span><br><span class="line">add_header                  <span class="built_in">Set</span>-Cookie <span class="string">"Secure"</span>;</span><br><span class="line">add_header                  X-Frame-Options <span class="string">"SAMEORIGIN"</span>;</span><br></pre></td></tr></table></figure></p><p><img src="/images/addheader.png" alt="好车" title="修改配置文件如图"></p><p>然后保存配置文件，<code>nginx -s reload</code>平滑重启即可，通过chrome在目标网页里按下<code>ctrl+shift+c</code>，先选择好<code>network</code>，然后重新刷新一下界面，选择域名，对应域名下点击<code>headers</code>，就会看到<code>cookie</code>的配置情况，如图：<br><img src="/images/seecookie.png" alt="好车" title="cookie生效"></p><h2><span id="扩展内容">扩展内容</span></h2><p>看到配置已经生效。那么这几个配置主要是干什么的呢？其实主要都是防范XSS攻击（跨域脚本攻击）的。</p><p>Cookie的Secure属性，意味着保持Cookie通信只限于加密传输，指示浏览器仅仅在通过安全/加密连接才能使用该Cookie。如果一个Web服务器从一个非安全连接里设置了一个带有secure属性的Cookie，当Cookie被发送到客户端时，它仍然能通过中间人攻击来拦截。 </p><p>Cookie的HttpOnly属性，指示浏览器不要在除HTTP（和HTTPS)请求之外暴露Cookie。一个有HttpOnly属性的Cookie，是不可以通过例如调用JavaScript(引用document.cookie)这种非HTTP方式来访问。因此，也不可能通过跨域脚本（一种非常普通的攻击技术）来偷走这种Cookie。</p><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在<code>frame</code>, <code>iframe</code>或者<code>object</code>中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。它有三个可选择项：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DENY：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许；</span><br><span class="line">SAMEORIGIN：表示该页面可以在相同域名页面的 frame 中展示；</span><br><span class="line">ALLOW-FROM uri地址：表示该页面可以在指定来源的 frame 中展示；</span><br></pre></td></tr></table></figure></p><p>如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p><p>这里还要额外注意一下！<font color="red">配置了Cookie的HttpOnly属性和Secure属性之后，如果测试中心的人使用的协议是http而不是https的话，会有“浏览器请求后端服务时header不会带上cookie参数”的现象，那是因为“由于secure属性的存在，导致浏览器在与服务器通信时不会使用该cookie”。这个时候就需要把secure=”true”这个配置去掉才可以达到正确测试的目的。</font></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://imququ.com/post/my-nginx-conf-for-security.html" target="_blank" rel="noopener">https://imququ.com/post/my-nginx-conf-for-security.html</a></p>]]></content>
    
    <summary type="html">
    
      用配置cookie来防御xss攻击
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>django新增class的时候数据库格式出错</title>
    <link href="http://yoursite.com/2018/01/10/django%E6%96%B0%E5%A2%9Eclass%E7%9A%84%E6%97%B6%E5%80%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%BC%E5%BC%8F%E5%87%BA%E9%94%99/"/>
    <id>http://yoursite.com/2018/01/10/django新增class的时候数据库格式出错/</id>
    <published>2018-01-10T07:33:06.000Z</published>
    <updated>2018-01-10T08:08:49.973Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>这几天开发频繁要求查看生产环境zookeeper的配置，于是就想在django里添加一个新的栏，以文本的形式随时更新zookeeper的情况。</p><p>于是我就登陆了django，在<code>model.py</code>里添加一个新的class，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#建立杭州测试ZK配置</span><br><span class="line">class HZfunczk(models.Model):</span><br><span class="line">   hzfunczk_remark = models.CharField(verbose_name=<span class="string">'杭州测试ZK配置'</span>,max_length=<span class="number">50000</span>,blank=<span class="literal">true</span>)</span><br><span class="line">   hzfunczk_signer = models.CharField(verbose_name=<span class="string">'登记人'</span>,max_length=<span class="number">30</span>,<span class="keyword">default</span>=<span class="string">'system'</span>)</span><br><span class="line">   hzfunczk_signtime = models.DateField(auto_now_add=True)</span><br><span class="line"></span><br><span class="line">   def __unicode__(self):</span><br><span class="line">       <span class="keyword">return</span> self.domain_name</span><br></pre></td></tr></table></figure></p><p>然后在django的目录下执行<code>python manage.py makemigrations</code>，这一步没问题，但是在执行<code>python manage.py migrate</code>的时候，就出现了下面的错误：<br><img src="/images/django1.png" alt="akb48" title="数据库格式不对"></p><p>我开始认为是charfield写错了，应该写Textfield，于是更改了一下，但是保存之后，再执行<code>python manage.py migrate</code>还是出错。其实这个错误主要原因就是因为我那个50000设置错了，因为字段hzfunczk_remark定义的长度50000超出了mysql的varchar的最大长度21845（在utf8编码情况下）。于是我就在<code>model.py</code>里把这个长度改成20000，保存之后，还是执行到<code>python manage.py migrate</code>这一步，依旧爆上面的错误。于是我就干脆把这个class先删除掉，没想到都删除光了，还是在<code>make</code>的时候会爆错。</p><p>这就很奇怪了，我已经删掉了为啥还有这样的事儿？于是就干脆进入到数据库去看，由于我现在只知道列名叫hzfunczk_remark，所以我要根据这个列名去查它所在的表，maria反馈如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [abccs]&gt; select TABLE_SCHEMA, TABLE_NAME <span class="keyword">from</span> information_schema.columns where COLUMN_NAME = <span class="string">'hzfunczk_remark'</span>; </span><br><span class="line">Empty set (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure></p><p>好尴尬呀，数据库里压根就没有列名为“hzfunczk_remark”的表。然后由于<code>python manage.py migrate</code>报错，现在无法启动django。怎么办？</p><p>遇到这种状况，就去django里的migrations文件夹，这个文件夹里有很多的以时间命名的py文件，它们记录着数据库的每一步操作，不过这里面的py还没有真正执行到数据库里，我找到当时添加class那个时间段的py文件，里面是这样的：<br><img src="/images/django2.png" alt="akb48" title="记录数据库操作的PY细节"></p><p>先把里面CharField改成TextField，然后把50000改成小于21845的就行了。如果你性子比较烈，那就干脆把这个文件以及之后产生的所有文件都删除掉。重新的去<code>make</code>。</p><p>如果还是实在不行，还有一个万不得已的办法，几乎所有的数据库错误都可以用这个方法解决：<font color="red">将migrations文件夹下的文件除了<strong>init</strong>.py全部删掉，然后将数据库drop掉，重新建数据库。然后make和migrate，就可以使用一个新的数据库</font>（但愿你永远用不到这个方法）。</p>]]></content>
    
    <summary type="html">
    
      sql添加行的时候可不能为所欲为...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>通道信息加密工具--Qtunnel</title>
    <link href="http://yoursite.com/2018/01/10/%E9%80%9A%E9%81%93%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7-Qtunnel/"/>
    <id>http://yoursite.com/2018/01/10/通道信息加密工具-Qtunnel/</id>
    <published>2018-01-10T04:20:01.000Z</published>
    <updated>2018-01-10T08:09:03.354Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>数据库做异地容灾是一个很常见的现象，既然信息要跨地域传递，要么就很土豪的打通机房之间的链路或者动用VPN，要不然就不可避免的走公网网络传输信息。既然选择了公网，那么数据库的语句就很容易被人监听到，所以把那些明文加密是必不可少的环节。</p><p>mysql支持<code>tls/ssl</code>加密方法对信息进行加密，这个方法的配置也很简单，就是两边各加上一个nginx，一个是正向代理一个是反向代理，配上ssl证书，然后就像配置网站https协议那样，在nginx.conf里开启ssl监听即可。</p><p>但是这种方法有一点小问题，就是在进行SSL握手之前，mysql会发送Server Greeting和Login Request数据包，然后才有可能使用SSL握手。这样步骤就多了一步鉴权，对访问性能有所影响。所以这个时候，我选择了另一个用于加密client和server之间链路通信的工具—-Qtunnel，因为它直接加密，速度更快。</p><p>Git的地址在这里：<a href="https://github.com/arstercz/qtunnel" target="_blank" rel="noopener">https://github.com/arstercz/qtunnel</a> ，<strong>感谢arstercz大神的再加工！</strong></p><p>上面说过了Qtunnel是不需要认证的，默认加密方法是RC4，以字节流的方式加密明文的每一个字节，而且密钥长度最长支持256位，可以很好的抵御暴力搜索密钥的攻击，总而言之，Qtunnel是一个轻量且快速的加解密工具，而且还可以搭配atlas等数据库中间件使用。</p><h2><span id="下载与准备">下载与准备</span></h2><p>由于Qtunnel是用go语言写的，所以需要先安装golang，centos服务器的yum安装方法如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></span><br><span class="line">yum install -y golang</span><br></pre></td></tr></table></figure></p><p>go语言安装完毕之后，我们就<code>git clone https://github.com/arstercz/qtunnel.git</code> ，获得qtunnel文件夹，文件夹内容如下：<br><img src="/images/downqtunnel.png" alt="抱光妹" title="qtunnel下载包内容"></p><p><code>make</code>，如果没有任何报错，那么就是安装成功了，使用<code>./bin/qtunnel -h</code>语句验证一番：<br><img src="/images/installqtunnel.png" alt="抱光妹" title="验证qtunnel"></p><p>本次实验的计划是这样的：用A机器访问B机器的mysql，并且插入数据，在B机器上的3306端口抓包，查看数据是否是明文；然后再在A机器和B机器上都安装qtunnel并且启动，然后重新插入数据，在B机器上的端口抓包，查看数据是否被加密。流程图如下：<br><img src="/images/架构.png" alt="抱光妹" title="架构图"></p><h2><span id="实验开始">实验开始</span></h2><p>A机器和B机器都是使用阿里云虚拟服务器，版本都是centos 6.4，现在我们的加密实验正式开始。</p><p>首先A和B机器上都不启动qtunnel，然后我们在A机器上登陆B机器的数据库，如果之前没有授权，那么授权语句是：<br>    <code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;A机器的IP地址&#39; IDENTIFIED BY &#39;密码&#39; WITH GRANT OPTION;</code></p><p>登陆mysql之后，我们随意的插一个语句，然后通过抓包发现无论这个语句还是数据库的反馈都是以明文的形式呈现，如图：<br><img src="/images/shujuluoben.png" alt="抱光妹" title="数据在明文裸奔"></p><p>这种让数据裸奔的行为无疑于找死，那么这个时候我们就要配置一下qtunnel，来看一下它的加密效果。</p><p>在A服务器上，我们设定qtunnel是客户端，手动建立一个conf文件，比如<code>vim /etc/conn.conf</code>，内容如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[client1]</span><br><span class="line">faddr = 10.252.215.108:3309    #这里是qtunnel客户端的IP</span><br><span class="line">baddr = 10.175.193.239:3310    #这里是qtunnel服务端的IP</span><br><span class="line">cryptoMethod = rc4             #这里选用rc4的方式加密</span><br><span class="line">secret = 3301_test%Iad      #rc4密钥，服务端的密码必须跟这个一致！</span><br><span class="line">clientmode = true              #表示这端是客户端</span><br></pre></td></tr></table></figure></p><p>然后使用<code>./bin/qtunnel -conf=/etc/conn.conf -daemon -logto=syslog</code>启动qtunnel，看一下进程和端口情况，如图：<br><img src="/images/aqidong.png" alt="抱光妹" title="看一下A进程和端口情况"></p><p>在B服务器上，同样手动建立一个配置文件，假设也叫conn.conf，内容如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[server1]</span><br><span class="line">faddr = 10.175.193.239:3310    #这里是qtunnel服务端的IP</span><br><span class="line">baddr = 10.175.193.239:3306    #这里是数据库的地址，由于在同一台机器上，所以地址一样</span><br><span class="line">cryptoMethod = rc4    </span><br><span class="line">secret = 3301_test%Iad      #rc4密钥，跟client密钥一致</span><br><span class="line">clientmode = false             #表示这是服务器端</span><br></pre></td></tr></table></figure></p><p>也用同样的语句启动qtunnel，查看3310这个端口已经被监听了：<br><img src="/images/bqidong.png" alt="抱光妹" title="看一下B进程和端口情况"></p><p>现在，我们在A服务器上来重新连接B数据库，但是要注意！<font color="red">这个时候mysql里的-h不能再是B的IP地址了，而是A的地址！因为qtunnel现在已经打通了一个通道，访问qtunnel的3310端口就等于是访问B数据库的3306端口（有点类似atlas的意思）。</font></p><p>连上之后，我们随意插入一些语句，看一下qtunnel的能力:<br><img src="/images/shujubuluoben.png" alt="抱光妹" title="数据已经被加密了"></p><p>可见这个时候，抓包显示都是加密的文字了，实验成功！</p><h2><span id="总结与参考资料">总结与参考资料</span></h2><p>总结一下：qtunnel采用rc4加密，在算法强度和速度方面是很好的选择，不会引起slave太大的延迟，对管理员或开发而言数据都是透明的（如果在上面的实验启动了qtunnel之后，不监听3310端口，而是监听3306端口，得到的依旧是明文），只是在两端传输的过程中增加了加解密处理。核心的业务(比如用户和充值)在做异地架构的时候可以考虑该方式增强数据的安全性。</p><p>《mysql使用ssl简析》：<a href="https://hsulei.com/2017/10/19/mysql%E4%BD%BF%E7%94%A8ssl%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">https://hsulei.com/2017/10/19/mysql%E4%BD%BF%E7%94%A8ssl%E7%AE%80%E6%9E%90/</a><br>《使用ssl加密mysql 5.6的官方文档》：<a href="https://dev.mysql.com/doc/refman/5.6/en/encrypted-connections.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/encrypted-connections.html</a></p>]]></content>
    
    <summary type="html">
    
      你总不会采取“数据在公网裸奔”这样的找死行为吧。
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="加密技术" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Qtunnel" scheme="http://yoursite.com/tags/Qtunnel/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix3.0搭配微信企业号报警</title>
    <link href="http://yoursite.com/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/"/>
    <id>http://yoursite.com/2018/01/10/Zabbix3-0搭配微信企业号报警/</id>
    <published>2018-01-10T03:18:02.000Z</published>
    <updated>2018-01-10T03:42:45.188Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Zabbix搭配微信企业号报警是一个很流行的手段，这里说一下如何配置。</p><h2><span id="准备工作">准备工作</span></h2><p>建立一个企业号以及具体应用的链接在此：<a href="http://chenx1242.blog.51cto.com/10430133/1954634，里面写的都很明白了。" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1954634，里面写的都很明白了。</a></p><p>现在打开微信企业号的官方网站<a href="https://work.weixin.qq.com，然后扫描一下微信二维码登录到企业号的控制台。" target="_blank" rel="noopener">https://work.weixin.qq.com，然后扫描一下微信二维码登录到企业号的控制台。</a></p><p>在控制台网页里，需要查找几个元素，分别是<code>CorpID</code>、<code>应用AgentId</code>、<code>应用Secret</code>还有<code>用户账号</code>。</p><p>首先，在控制台里选择“我的企业”，然后就可以看见<code>CorpID</code>，如图：<br><img src="/images/corpid.png" alt="抱光妹" title="获取CorpID"></p><p>然后点击“企业应用”，如果没有应用，那么就新建立一个应用。比如我已经建立了一个应用叫“zabbix告警”，那么应用AgentId和应用Secret就在如图的位置：<br><img src="/images/aksk1.png" alt="抱光妹" title="应用AgentId和应用Secret"></p><p>有了上面的CropID和Secret，就可以去验证一下accesstoken，登录<a href="http://qydev.weixin.qq.com/debug" target="_blank" rel="noopener">http://qydev.weixin.qq.com/debug</a> ，后在填入对应的CropID和Secret，看一下返回结果是否是“HTTP/1.0 200 OK”，如图：<br><img src="/images/checkaksk.png" alt="抱光妹" title="验证AgentId和Secret"></p><p>在这个“zabbix告警”的应用里可见范围里添加对应需要通知的人，然后在“通讯录”里，找到对应的人，记录他们的账号，如图：<br><img src="/images/content.png" alt="抱光妹" title="通讯录联系人"></p><p>材料已经俱备完毕，现在需要做的是更改zabbix-server配置。</p><p>首先，在zabbix-server.conf里添加一句<code>AlertScriptsPath=/usr/lib/zabbix/alertscripts</code>，这是为了说明一下脚本所在的路径。当然，这个路径你可以自己更改，然后重启一下zabbix-server。</p><h2><span id="编写脚本">编写脚本</span></h2><p><code>cd /usr/lib/zabbix/alertscripts</code>，在这个目录下我们要新写一个微信脚本，比如脚本名称叫<code>wechat.py</code>。</p><p>这个python脚本是需要requests模块的，所以需要先安装这个模块，安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install --upgrade requests</span><br></pre></td></tr></table></figure></p><p>而python脚本内容如下，<strong>感谢<a href="https://github.com/X-Mars/Zabbix-Alert-WeChat/的脚本" target="_blank" rel="noopener">https://github.com/X-Mars/Zabbix-Alert-WeChat/的脚本</a></strong>：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python2.7</span></span><br><span class="line">#_*_coding:utf-8 _*_</span><br><span class="line">#this script is used for alarm by WECHAT</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests,sys,json</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">def GetToken(Corpid,Secret):</span><br><span class="line">   Url = <span class="string">"https://qyapi.weixin.qq.com/cgi-bin/gettoken"</span></span><br><span class="line">   Data = &#123;</span><br><span class="line">       <span class="string">"corpid"</span>:Corpid,</span><br><span class="line">       <span class="string">"corpsecret"</span>:Secret</span><br><span class="line">   &#125;</span><br><span class="line">   r = requests.get(url=Url,params=Data,verify=False)</span><br><span class="line">   Token = r.json()[<span class="string">'access_token'</span>]</span><br><span class="line">   <span class="keyword">return</span> Token</span><br><span class="line">    </span><br><span class="line">def SendMessage(Token,User,Agentid,Subject,Content):</span><br><span class="line">   Url = <span class="string">"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s"</span> % Token</span><br><span class="line">   Data = &#123;</span><br><span class="line">       "touser": User,                                 # 企业号中的用户帐号，在zabbix用户Media中配置，如果配置不正常，将按部门发送。</span><br><span class="line">       #"totag": Tagid,                                # 企业号中的部门id，群发时使用。</span><br><span class="line">       "msgtype": "text",                              # 消息类型。</span><br><span class="line">       "agentid": Agentid,                             # 企业号中的应用id。</span><br><span class="line">       <span class="string">"text"</span>: &#123;</span><br><span class="line">           <span class="string">"content"</span>: Subject + <span class="string">'\n'</span> + Content</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">"safe"</span>: <span class="string">"0"</span></span><br><span class="line">   &#125;</span><br><span class="line">   r = requests.post(url=Url,data=json.dumps(Data),verify=False)</span><br><span class="line">   <span class="keyword">return</span> r.text</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   User = sys.argv[1]                                                              # zabbix传过来的第一个参数</span><br><span class="line">   Subject = sys.argv[2]                                                           # zabbix传过来的第二个参数</span><br><span class="line">   Content = sys.argv[3]                                                           # zabbix传过来的第三个参数</span><br><span class="line">   Corpid = <span class="string">"这里填写Corpid"</span>                                                   </span><br><span class="line">   Secret = <span class="string">"这里填写Secret"</span>                           </span><br><span class="line">   Agentid = <span class="string">"这里填写应用的agentid"</span>                                                        </span><br><span class="line">   Token = GetToken(Corpid, Secret)</span><br><span class="line">   Status = SendMessage(Token,User,Agentid,Subject,Content)</span><br><span class="line">   print Status</span><br></pre></td></tr></table></figure></p><p>脚本保存后，<code>chown -R zabbix:zabbix wechat.py</code>，然后小试一下，上面看到“Zabbix告警”这个微信应用里有一个用户账号叫ChenShuo，那么wechat.py执行语句是：<code>python wechat.py ChenShuo 这个是标题  这里是正文！！</code></p><p>然后看一下微信，如图：<br><img src="/images/checkpy.jpg" alt="抱光妹" title="脚本验证成功"></p><p>正确出现了微信提示，可见这个脚本是OK的了。</p><h2><span id="配置zabbix">配置zabbix</span></h2><p>现在我们要登录到zabbix网站，最上面的“Administration”里选择“Media types”，新建立一个Media type，如图：<br><img src="/images/mediatype.png" alt="抱光妹" title="新建立Media type"></p><p>保存之后，在“Administration”里选择“Users”，在Admin用户里点击“media”,把刚刚新增的“微信告警”这个media type添加进去，如图：<br><img src="/images/addpy.png" alt="抱光妹" title="添加Media type"></p><p>通知手段配置完毕，现在就是要在具体的Trigger上把微信告警这个新手段添加到active里。首先打开Configuration里的actions界面。此时假设现在有一个告警Trigger叫“模块发生了重启”，判断模块是否重启的依据就是pid值是否发生了变化。那么点击这个Trigger，在action里把“微信告警”添加到报警手段里，如图：<br><img src="/images/addtrigger.png" alt="抱光妹" title="配置trigger"></p><p>保存之后，整个的微信告警配置就完成了。为了验证配置是否生效，我冒死重启了一台生产环境的服务器，当然啦，好孩子千万不要效仿。</p><p>收到微信提示如图：<br><img src="/images/checkpy2.jpg" alt="抱光妹" title="脚本验证成功"><br>不过考虑到微信告警可能会有所延迟，所以在这建议大家把告警阈值配置稍微早一点，避免“孩子死了奶来了”这种尴尬的情况。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.yfshare.vip/2017/04/13/Zabbix%E4%B9%8B%E5%BE%AE%E4%BF%A1-Wechat-%E5%91%8A%E8%AD%A6/" target="_blank" rel="noopener">http://www.yfshare.vip/2017/04/13/Zabbix%E4%B9%8B%E5%BE%AE%E4%BF%A1-Wechat-%E5%91%8A%E8%AD%A6/</a><br><a href="https://github.com/X-Mars/Zabbix-Alert-WeChat/" target="_blank" rel="noopener">https://github.com/X-Mars/Zabbix-Alert-WeChat/</a></p>]]></content>
    
    <summary type="html">
    
      让微信报警来占据你和你的运维同事的业余时间...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>自己动手搭建一个hexo博客demo</title>
    <link href="http://yoursite.com/2018/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhexo%E5%8D%9A%E5%AE%A2demo/"/>
    <id>http://yoursite.com/2018/01/10/自己动手搭建一个hexo博客demo/</id>
    <published>2018-01-10T02:54:51.000Z</published>
    <updated>2018-01-10T03:39:34.098Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>曾几何时，自己动手做一个博客的想法愈加强烈，想在里面放一些更多除了技术之外的东西，比如烹饪的美食，比如PVP的视频，比如拍摄的照片，比如篮球足球的评论。在这种需求下，我从众多博客框架里面选择了hexo，原因就是“很多人都推荐hexo”….（囧）于是乎我在windows里搞一个，由于我在公司的网络是可以跨越长城的，所以搞github有一点天然的优势。而且github的博客不用花钱搞域名，他直接免费提供…</p><p><strong>在搞github的时候墙裂推荐各位去用命令行，有linux的基本基础就可以很熟练的使用命令行搞github， 它的客户端真的不如命令行好用。</strong></p><h2><span id="准备工作">准备工作</span></h2><p>先去注册一个github，然后去<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a> 上下载一个最新的git windows的客户端，我下载的是2.15.1版本，如图：<br><img src="/images/zhucegithub.png" alt="抱光妹" title="windows下载github"></p><p>下载完毕之后，就把这个exe文件安装，然后在“开始”里找到git再打开“Git Bash”，我的github账号是<code>RorschachChan</code>，电子邮件也已经配置过，所以现在就在这个bash窗口里写入如下语句：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"RorschachChan"</span></span><br><span class="line">git config --global user.email <span class="string">"chenx1242@163.com"</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/config1.png" alt="抱光妹" title="确定用户名和邮箱"><br>上面git config –global 参数，表示你这台机器上所有的Git仓库都会使用这个配置。</p><p>再去<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 上根据自己windows的情况，下载最新的nodejs，下载完了之后就一路next，然后需要退出重进一下git bash，在bash的命令行里输入<code>node -v</code>，看到版本号就是OK，同时输入node，$会变成&gt;，然后输入.exit就可以退出返回到bash。<br><img src="/images/nodeV.png" alt="抱光妹" title="查看node版本"></p><p>然后就是安装hexo，hexo的安装比较简单，就是在git bash里输入<code>npm install -g hexo-cli</code>和<code>npm install -g hexo</code>，然后需要等待一会，如果出现了“npm ERR! ”不要怕，重新输入一次应该就会好了，安装完毕之后，输入$ hexo -v查看hexo的版本，如图：<br><img src="/images/installhexo1.png" alt="抱光妹" title="安装hexo-cli"><br><img src="/images/installhexo2.png" alt="抱光妹" title="安装hexo"></p><p>然后建立一个github ssh密钥，在git bash里输入<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>，然后告诉密钥生成的路径（下图黄框）以及会让你输入对应的口诀（红色箭头），这个口诀很重要，要妥善保存，如图：<br><img src="/images/githubak.png" alt="抱光妹" title="配置密钥"></p><p>这个密码会在你提交项目（<code>hexo d</code>）时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。这时候去<code>C:\Users\33664\.ssh</code>的路径里就会看到一对钥匙，<strong>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</strong><br><img src="/images/miyao.png" alt="抱光妹" title="密钥在这里"></p><p>来到github的个人配置里，选择“SSH and GPG keys”，然后输入title和id_rsa.pub的内容，点击“add ssh key”。如图：<br><img src="/images/addak.png" alt="抱光妹" title="在github添加ak"><br>准备工作的最后一步，就是建立一个文件夹，我的文件夹建立在E盘下，名字就叫hexo。</p><h2><span id="开始搭建博客">开始搭建博客</span></h2><p>首先在git bash里进入/e/hexo，然后输入<code>hexo init</code>，这个命令是初始化命令，再输入<code>hexo -g</code>来生成静态文件，执行之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github上你的用户名.github.io的仓库上去的。然后可以输入<code>hexo s</code>来本地启动hexo，这个时候跑到浏览器里输入<code>localhost:4000</code>就会看到hexo博客最初的一个样子，如图：<br><img src="/images/hexo1.png" alt="抱光妹" title="最初是状态的hexo"></p><p>这个默认的主题比较难看，我们去<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> 下载最近一个比较火爆的主题next,并且把这个下载到hexo文件夹里的themes/next里，语句是：<code>git clone https://github.com/iissnan/hexo-theme-next.git themes/next</code><br><img src="/images/installnext.png" alt="抱光妹" title="安装next主题"></p><p>然后打开hexo文件夹里的_config.xml，把原有的theme注释，换成新的next，注意，中间是有空格的！<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#theme: landscape</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><p>然后<code>hexo clean</code>和<code>hexo g</code>清除 Hexo 的缓存和重新生成静态文件，再次<code>hexo s</code>启动进程，来到浏览看一下发现博客的样子就变成下面的样子了：<br><img src="/images/next1.png" alt="抱光妹" title="展示next主题"><br>这个看上去就简单大方很多了吧。</p><h2><span id="把博客上传到github">把博客上传到github</span></h2><p>现在有人问了，这个博客看上去好像很美，但是有两个致命的缺陷：第一，内容都是在我的windows里，如果我这个电脑坏了/出差/换新硬盘，那么如何保证我以前文件？第二，我启动进程需要执行 <code>hexo -s</code>，如果我电脑关机了，岂不是博客无法打开？</p><p>需要解决就要把磁盘上的内容传递到github库里了，同时github是常开进程的，这样既可以更新我们的内容又不会关闭博客进程，除非github这个网站黄了。</p><p>先去github网站去建立一个库（repository），这里我直接选择了公共读，如图：<br><img src="/images/repository.png" alt="抱光妹" title="建立一个新库"></p><p>然后在hexo文件夹里面，修改一下_config.xml的几个地方：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 石锤淡啤酒    #这个是网站在标签页的标题</span><br><span class="line">subtitle: 生活就是等待戈多    #这个是副标题</span><br><span class="line">description: 这里记录的不只有代码，还有生活和思想！    #这里也可以写网站的关键词，也可以矫情的写点别的</span><br><span class="line">author: Chris Chan    #这个作者会在网页最下面显示</span><br><span class="line">language: zh-Hans    #这里表示简体中文</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repository: git@github.com:RorschachChan/RorschachChan.github.io.git    #这里写的就是刚刚申请的库名</span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure></p><p>建立完库以及修改保存了_config.xml之后，我们执行一句<code>hexo d</code>部署命令，在执行的时候需要输入当时你建立id_rsa时候的口诀，刚刚申请的那个口诀不会这么快就忘了吧。<br><img src="/images/hexod.png" alt="抱光妹" title="部署博客"></p><p>返回到github的网站就看到hexo里所有的内容都上传到了github网站里了，如图:<br><img src="/images/hexod2.png" alt="抱光妹" title="上传成功"></p><p>在浏览器里输入“<a href="https://你的用户名.github.io”，就看到了博客界面：" target="_blank" rel="noopener">https://你的用户名.github.io”，就看到了博客界面：</a><br><img src="/images/newnext.png" alt="抱光妹" title="更改了主题和作者的界面"></p><p>同理，如果你的github用户名是test，建立的是test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io" target="_blank" rel="noopener">http://test.github.io</a> 了，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>至此，建立一个博客demo就到此结束了！</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://baoyuzhang.github.io/2017/04/28/【Hexo搭建独立博客全纪录】（一）使用Git和Github/" target="_blank" rel="noopener">https://baoyuzhang.github.io/2017/04/28/【Hexo搭建独立博客全纪录】（一）使用Git和Github/</a><br><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a><br><a href="http://opiece.me/2015/04/09/hexo-guide/" target="_blank" rel="noopener">http://opiece.me/2015/04/09/hexo-guide/</a><br><a href="http://shenzekun.cn/hexo的next主题个性化配置教程.html" target="_blank" rel="noopener">http://shenzekun.cn/hexo的next主题个性化配置教程.html</a> 强烈推荐这篇文章，可以让你把next主题的博客做的更加漂亮！</p>]]></content>
    
    <summary type="html">
    
      记录自己搭窝的过程，方便以后搭更多的窝...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="博客搭建" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Query String跟Arg的差异</title>
    <link href="http://yoursite.com/2018/01/09/Query-String%E8%B7%9Farg%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>http://yoursite.com/2018/01/09/Query-String跟arg的异同/</id>
    <published>2018-01-09T12:47:40.000Z</published>
    <updated>2018-01-09T14:06:15.915Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言与需求">前言与需求</span></h2><p>在<a href="https://rorschachchan.github.io/2018/01/09/记一次配置rewrite和return的经历/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/09/记一次配置rewrite和return的经历/</a> 里记录了一次rewrite和return的故事，不过我当时在最后的return里是把域名给写死了：<code>rewrite ^.*$ http://dvlshop.lechange.com/index.php/wap/$id$query last;</code>。</p><p>现在新的需求又来了，说域名不要写死，<code>http://dvlshop.lechange.com/index.php/</code>这部分要跟整个uri的state部分保持一致。</p><p>于是我这里再把整个uri贴出来，辣一下各位的眼睛：<br><a href="http://dvlshop.lechange.com/index.php/wap/?" target="_blank" rel="noopener">http://dvlshop.lechange.com/index.php/wap/?</a><br><em>client_id</em>=lc_mall_m&amp;<br><em>redirect_uri</em>=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;<br><em>response_type</em>=code&amp;    <code>#满足条件的话把这个改成+auto+</code><br><em>scope</em>=read&amp;<br><em>state</em>=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;<br><em>user</em>=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;<br><em>expire</em>=1514191636&amp;<br><em>source_type</em>=lc_app&amp;<br><em>nonce</em>=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27 </p><p>也就是说现在只需要变量state那点部分，那么这个时候就不能再使用$query_string了，要使用$arg。</p><p>$arg可以精确匹配变量，比如说我有一个参数（uri里？后面的那部分全叫参数）：&amp;p=你大爷&amp;q=你大娘，用$query_string和$arg就是获取所有，而使用$arg_p就是可以获取“你大爷”。</p><p>于是说动手就动手，把nginx.conf改成了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.php.*</span><br><span class="line">&#123;</span><br><span class="line">    include php_fcgi.conf;</span><br><span class="line">    include pathinfo.conf;</span><br><span class="line">    set $flag <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span> ( $args ~ <span class="string">"source_type=lc_app"</span> ) &#123;</span><br><span class="line">       set $flag  <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( $args ~ <span class="string">"(.*)response_type(.*)"</span> )&#123;</span><br><span class="line">       set $Flag  <span class="string">"$flag$flag"</span>;</span><br><span class="line">       set $id $<span class="number">1</span>;</span><br><span class="line">       set $query $<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ($Flag = <span class="string">"11"</span>)&#123;</span><br><span class="line">        set $flag <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">301</span>  $arg_state$id+auto+$query;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是通过日志查看，发现$arg_state得到的是<code>/http%3A%2F%2Fdvlshop.lechange.com%2Fproduct-79.html</code>,这就很囧了，我希望获取<code>http%3A%2F%2Fdvlshop.lechange.com%2Fproduct-79.html</code>（不要前面的反斜杠）或者是<code>/product-79.html</code>（不要中间的网站）。这可怎么办？</p><p>答案是，<strong>原生的nginx是做不到这一点，因为nginx不参与业务层逻辑方面的业务。</strong>如果说要达到改写的目的，就要搭配lua或者把nginx换成openresty。于是乎就让开发修改一下传递的state来达到目的。</p><h2><span id="扩展与补充">扩展与补充</span></h2><p>看到这个结果突然让我想起来一道面试题，说开发有一个模块，同时这个模块会给nginx提供几个状态码，比如状态码是111，那就是代表OK，状态码不是111，那就是代表不OK，现在想写一个语句，如果nginx获得的状态码不是111，返回一个404的页面，怎么写？</p><p>没错，答案也是“原生nginx写不了”，原因跟上面的一样，应用模块状态码是业务层的，nginx是http层的，不在一层压根就无法交流。</p><p>在这里也顺道补充一下“在浏览器中输入一个URL后都发生了什么？”，以下是一个大概流程：</p><ol><li>浏览器向DNS服务器查找输入URL对应的IP地址；</li><li>DNS服务器返回网站的IP地址；</li><li>浏览器根据IP地址与目标web服务器建立TCP连接；</li><li>发送HTTP请求；</li><li>服务器处理请求；</li><li>返回响应结果；</li><li>关闭TCP连接；</li><li>浏览器解析HTML；</li><li>浏览器布局渲染；</li></ol><p><img src="/images/家有喜事.gif" alt="星爷、李丽珍、张曼玉" title="《家有喜事》"></p>]]></content>
    
    <summary type="html">
    
      $query_string搞不定的事情，$arg来！
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>记一次配置rewrite和return的经历</title>
    <link href="http://yoursite.com/2018/01/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%85%8D%E7%BD%AErewrite%E5%92%8Creturn%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2018/01/09/记一次配置rewrite和return的经历/</id>
    <published>2018-01-09T08:39:10.000Z</published>
    <updated>2018-01-11T03:02:43.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言与需求">前言与需求</span></h2><p>自动电商平台归属了大数据研究院之后，我又恢复了那个“把nginx当成爸爸”的日子。开发不断地提出了的要求，我一样一样的疲命应付，并且在应付后记录下来，就怕以后再遇到类似的问题。</p><p>这次的需求是一个跳转，满足某个条件之后把<code>“http://dvlshop.lechange.com/index.php/wap/?client_id=lc_mall_m&amp;redirect_uri=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;response_type=code&amp;scope=read&amp;state=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;user=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;expire=1514191636&amp;source_type=lc_app&amp;nonce=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27 ”</code><br>改成<br><code>“http://dvlshop.lechange.com/index.php/wap/?client_id=lc_mall_m&amp;redirect_uri=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;=code&amp;scope=read&amp;state=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;user=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;expire=1514191636&amp;source_type=lc_app&amp;nonce=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27”</code></p><p>具体条件是: </p><ol><li>先判断是否有source_type=lc_app；</li><li>再判断是否有response_type；</li><li>如果以上两个都满足，将“response_type”改成“+auto+”；</li></ol><p>各位看官，我理解你们此时不想继续看下去的心情，其实我当初看着那么一大坨uri心里也直犯闹，但是没办法，“食君之禄，分君之忧”，我只能耐着性子一个一个的拆开，还别说，拆开的话就清晰许多了，如下：<br><a href="http://dvlshop.lechange.com/index.php/wap/?" target="_blank" rel="noopener">http://dvlshop.lechange.com/index.php/wap/?</a><br><em>client_id</em>=lc_mall_m&amp;<br><em>redirect_uri</em>=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;<br><em>response_type</em>=code&amp;    <code>#满足条件的话把这个改成+auto+</code><br><em>scope</em>=read&amp;<br><em>state</em>=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;<br><em>user</em>=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;<br><em>expire</em>=1514191636&amp;<br><em>source_type</em>=lc_app&amp;<br><em>nonce</em>=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27 </p><h2><span id="开始操作">开始操作</span></h2><p>针对这次需求我的计划是这样的：把原地址看成”$1+ response_type +$2”这样的一个样式，确定$1和$2，然后rewrite成”$1+ +auto+ +$2”不就搞定了么？ 于是乎我就凭着我那二把刀的nginx技术开始动手。折腾了大约半个小时，拿出来这样一个配置：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.php.*</span><br><span class="line">   &#123;</span><br><span class="line">       include php_fcgi.conf;</span><br><span class="line">       include pathinfo.conf;</span><br><span class="line">       set $flag <span class="string">"0"</span>;</span><br><span class="line">       <span class="keyword">if</span> ( $request_uri ~ <span class="string">"source_type=lc_app"</span> ) &#123;</span><br><span class="line">          set $flag  <span class="string">"1"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ( $request_uri ~ <span class="string">"(.*)response_type(.*)"</span> )&#123;</span><br><span class="line">          set $Flag  <span class="string">"$flag$flag"</span>;</span><br><span class="line">          set $id $<span class="number">1</span>;</span><br><span class="line">          set $query $<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       if ($Flag = "11")&#123;#注意这个地方是11</span><br><span class="line">           set $flag <span class="string">"0"</span>;</span><br><span class="line">          rewrite ^.*$ http:<span class="comment">//dvlshop.lechange.com/index.php/wap/$id$query last;#前面那一段是写死的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>但是很不幸，<code>nginx -s reload</code>之后的结果是“$1+$2+$1+ response_type +$2”的格式（地址太长太恶心了，我就不写了）。</p><p>然后在arstercz大神的指点下，把那句rewrite改成了<code>return 301 http://dvlshop.lechange.com/index.php/wap/?$id$query;</code>。就达到了效果。</p><h2><span id="原因确定">原因确定</span></h2><p>后来追寻原因，原来是： <font color="red">rewrite后面接的$uri不需要$args，因为$args会被自动带过来。而return的则会丢失$args，需要手动补上$args。</font>而我上面的$1,$2恰巧就是$args，所以用rewrite的话就会重复。举个例子，比如请求「<a href="http://localhost/?a=1」想被" target="_blank" rel="noopener">http://localhost/?a=1」想被</a> 301 到「<a href="https://localhost/?a=1?a=1」，要么" target="_blank" rel="noopener">https://localhost/?a=1?a=1」，要么</a><br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    rewrite / https:<span class="comment">//$host$uri permanent;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要么就<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//$host$request_uri;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="补充说明">补充说明</span></h2><p>PS，这里补充一下uri、request_uri、document_uri之间的区别：</p><ul><li>$request_uri: /stat.php?id=1585378&amp;web_id=1585378</li><li>$uri: /stat.php    (不带？后面)</li><li>$document_uri: /stat.php    （与uri完全相同）</li></ul><p><img src="/images/hugguangmei.gif" alt="抱光妹" title="《四重奏》"></p>]]></content>
    
    <summary type="html">
    
      比较一下return跟rewrite的不同。
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
</feed>
