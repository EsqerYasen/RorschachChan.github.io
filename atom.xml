<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-11T02:43:57.121Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Python使用yaml的几个例子</title>
    <link href="http://yoursite.com/2018/01/11/%E5%9C%A8Python%E4%BD%BF%E7%94%A8yaml%E7%9A%84%E5%87%A0%E4%B8%AA%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2018/01/11/在Python使用yaml的几个例子/</id>
    <published>2018-01-11T02:11:17.000Z</published>
    <updated>2018-01-11T02:43:57.121Z</updated>
    
    <content type="html"><![CDATA[<p>python版本：<code>2.7.5</code><br>安装方法：<code>pip install PyYaml</code></p><p>“把变量写进yaml做配置文件，然后python脚本从yaml文件里面取到变量”的方法最近是在python编程里比较流行的配置项方法。yaml更加易读，而且通过缩进表示结构，这一点与python不谋而合。</p><p>Yaml有四个比较常用的用法，分别是<code>load()</code>、<code>dump()</code>、<code>load_all()</code>、<code>dump_all()</code>。这篇文章主要就是了解一下这四个方法。</p><p>首先我们先写一个很简单的test.py：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">yaml_str = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">name: Gakki</span></span><br><span class="line"><span class="string">age: 29</span></span><br><span class="line"><span class="string">job: Actress</span></span><br><span class="line"><span class="string">relationship: Wife</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br><span class="line"> </span><br><span class="line">aaa = yaml.load(yaml_str)</span><br><span class="line">print aaa</span><br></pre></td></tr></table></figure></p><p>执行的话，看到的效果就是：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">&#123;<span class="string">'job'</span>: <span class="string">'Actress'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'relationship'</span>: <span class="string">'Wife'</span>, <span class="string">'name'</span>: <span class="string">'Gakki'</span>&#125;</span><br></pre></td></tr></table></figure></p><p>这个aaa的类型是一个<code>字典（dict）</code>，如果要得到里面那个”Gakki”，那么就是aaa[‘name’]。通过load方法，一个字符串变成了一个字典。</p><p>现在把test.py换成如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">yaml_dict = &#123;<span class="string">"name"</span>: <span class="string">"Gakki"</span>,</span><br><span class="line">         <span class="string">"age"</span>: <span class="number">29</span>,</span><br><span class="line">         <span class="string">"job"</span>: <span class="string">"Actress"</span>,</span><br><span class="line">         <span class="string">"relationship"</span>: <span class="string">"Wife"</span></span><br><span class="line">              &#125;</span><br><span class="line">aaa = yaml.dump(yaml_dict, default_flow_style=False)</span><br><span class="line">print aaa</span><br><span class="line">print (type(aaa))</span><br></pre></td></tr></table></figure></p><p>执行后的效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">age: <span class="number">29</span></span><br><span class="line">job: Actress</span><br><span class="line">name: Gakki</span><br><span class="line">relationship: Wife</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>可见，通过dump方法，把一个dict变成了一个字符串。</p><p>现在写一个配置文件，假如它叫test.yaml:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Gakki</span><br><span class="line">- <span class="number">29</span></span><br><span class="line">- Actress</span><br><span class="line">- Wife</span><br></pre></td></tr></table></figure></p><p>再来一个test.py，内容如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"> </span><br><span class="line">aaa = yaml.load(file(<span class="string">'test.yaml'</span>, <span class="string">'r'</span>))</span><br><span class="line">print aaa</span><br><span class="line">print (type(aaa))</span><br></pre></td></tr></table></figure></p><p>执行这个test.py：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">[<span class="string">'Gakki'</span>, <span class="number">29</span>, <span class="string">'Actress'</span>, <span class="string">'Wife'</span>]</span><br><span class="line">&lt;type 'list'&gt;    #得到了一个列表</span><br></pre></td></tr></table></figure></p><p>如果把那个test.yaml升级成字典和列表的混合结构，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- name: Chris</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line"> job: OM Engineer</span><br><span class="line">- name: Gakki</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line"> job: Actress</span><br><span class="line"> relationship: Wife</span><br></pre></td></tr></table></figure></p><p>执行test.py的效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">[&#123;<span class="string">'job'</span>: <span class="string">'OM Engineer'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'name'</span>: <span class="string">'Chris'</span>&#125;, &#123;<span class="string">'job'</span>: <span class="string">'Actress'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'relationship'</span>: <span class="string">'Wife'</span>, <span class="string">'name'</span>: <span class="string">'Gakki'</span>&#125;]</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>既然获得的结果是一个包含字典的列表，那么如果要获得“Gakki”就是aaa[1][‘name’]</p><p>如果想要复制和引用，那么要用&amp;和*，比如把test.yaml改成这样：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: &amp;name Gakki</span><br><span class="line">wife: *name</span><br></pre></td></tr></table></figure></p><p>执行test.py的效果如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Gakki'</span>, <span class="string">'wife'</span>: <span class="string">'Gakki'</span>&#125;</span><br><span class="line">&lt;type <span class="string">'dict'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>在同一个yaml文件中，可以用 — 来分段，这样可以将多个文档写在一个文件中：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"> name: Chris</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line"> job: OM Engineer</span><br><span class="line">---</span><br><span class="line"> name: Gakki</span><br><span class="line"> age: <span class="number">29</span></span><br><span class="line"> job: Actress</span><br><span class="line"> relationship: Wife</span><br></pre></td></tr></table></figure></p><p>再写一个新的test.py如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line">ys = yaml.load_all(file('gakki.yaml', 'r'))    #load_all() 方法会生成一个迭代器，可以用for输出出来</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> ys:</span><br><span class="line">   print y</span><br></pre></td></tr></table></figure></p><p>执行这个py的效果：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@paas-online-crs-001 chentest]# python test.py </span><br><span class="line">&#123;<span class="string">'job'</span>: <span class="string">'OM Engineer'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'name'</span>: <span class="string">'Chris'</span>&#125;</span><br><span class="line">&#123;<span class="string">'job'</span>: <span class="string">'Actress'</span>, <span class="string">'age'</span>: <span class="number">29</span>, <span class="string">'relationship'</span>: <span class="string">'Wife'</span>, <span class="string">'name'</span>: <span class="string">'Gakki'</span>&#125;</span><br></pre></td></tr></table></figure></p><p>参考文档：<a href="https://huilansame.github.io/huilansame.github.io/archivers/recommond-case-file-type-yaml" target="_blank" rel="noopener">https://huilansame.github.io/huilansame.github.io/archivers/recommond-case-file-type-yaml</a></p><p><img src="/images/todalaugh.gif" alt="抱光妹" title="Toda马笑"></p>]]></content>
    
    <summary type="html">
    
      以后要多用yaml格式做配置文件...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>使用Zabbix去监控Redis</title>
    <link href="http://yoursite.com/2018/01/10/%E4%BD%BF%E7%94%A8Zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7Redis/"/>
    <id>http://yoursite.com/2018/01/10/使用Zabbix去监控Redis/</id>
    <published>2018-01-10T14:49:04.000Z</published>
    <updated>2018-01-10T15:15:46.273Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="了解redis的info">了解Redis的info</span></h2><p>要获得Redis的当前情况，使用<code>info</code>命令即可。具体用法：<code>redis-cli -h 127.0.0.1 -p 6379 -a redis_passwd info [参数]</code> 。针对不同的参数就会看到具体的数字，如果没有带参数，那么就会把默认情况写出来，如果带上<code>all</code>参数，那么就会把所有情况都写出来。比如：<code>redis-cli -h 127.0.0.1 -p 6379 -a redis_passwd info server</code>，就会看到redis关于server的一些数据，如下：<br><img src="/images/redisinfo.png" alt="抱光妹" title="redis的info内容"><br>可以看出，从server里可以查询到的是版本号、pid号、配置文件路径等等东西。</p><p>如果参数是client，记录了是客户端的相关信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info clients</span><br><span class="line"># Clients</span><br><span class="line">connected_clients:64    #已连接客户端的数量（不包括通过从属服务器连接的客户端）</span><br><span class="line">client_longest_output_list:0    #当前连接的客户端当中，最长的输出列表</span><br><span class="line">client_biggest_input_buf:0    #当前连接的客户端当中，最大输入缓存</span><br><span class="line">blocked_clients:0    #正在等待阻塞命令（BLPOP、BRPOP、BRPOPLPUSH）的客户端的数量</span><br></pre></td></tr></table></figure></p><p>如果参数是memory，记录的是内存的相关信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info memory</span><br><span class="line"># Memory</span><br><span class="line">used_memory:2252984    #由 Redis 分配器分配的内存总量，以字节（byte）为单位</span><br><span class="line">used_memory_human:2.15M    #上面的数字加上了单位</span><br><span class="line">used_memory_rss:9293824    #常驻集大小，即Redis已分配的内存总量。这个值和top、ps等命令的输出一致</span><br><span class="line">used_memory_peak:2607520    #Redis 的内存消耗峰值（以字节为单位）</span><br><span class="line">used_memory_peak_human:2.49M    #上面的数字加上了单位</span><br><span class="line">used_memory_lua:33792    #Lua 引擎所使用的内存大小（以字节为单位）</span><br><span class="line">mem_fragmentation_ratio:4.13    #used_memory_rss 和 used_memory 之间的比率</span><br><span class="line">mem_allocator:jemalloc-3.2.0    #在编译时指定的，Redis所使用的内存分配器。可以是libc、jemalloc或者tcmalloc。</span><br></pre></td></tr></table></figure></p><p>这里要注意！<font color="red">在理想情况下， used_memory_rss 的值应该只比 used_memory 稍微高一点儿</font>（我这个机器就已经属于严重的级别了）。当 rss &gt; used ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。内存碎片的比率可以通过 mem_fragmentation_ratio 的值看出。当 used &gt; rss 时，表示 Redis 的部分内存被操作系统换出到交换空间了，在这种情况下，操作可能会产生明显的延迟。</p><p>如果参数是stats，那就是统计的相关信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info stats</span><br><span class="line"># Stats</span><br><span class="line">total_connections_received:150383    #服务器已接受的连接请求数量</span><br><span class="line">total_commands_processed:500935    #服务器已执行的命令数量</span><br><span class="line">instantaneous_ops_per_sec:0    #服务器每秒钟执行的命令数量</span><br><span class="line">rejected_connections:0    #因为最大客户端数量限制而被拒绝的连接请求数量</span><br><span class="line">sync_full:<span class="number">0</span>    </span><br><span class="line">sync_partial_ok:<span class="number">0</span>    </span><br><span class="line">sync_partial_err:0    #查找数据库键成功的次数</span><br><span class="line">expired_keys:41    #因为过期而被自动删除的数据库键数量</span><br><span class="line">evicted_keys:0    #因为最大内存容量限制而被驱逐（evict）的键数量</span><br><span class="line">keyspace_hits:78121    #查找数据库键成功的次数</span><br><span class="line">keyspace_misses:56    #查找数据库键失败的次数</span><br><span class="line">pubsub_channels:0    #目前被订阅的频道数量</span><br><span class="line">pubsub_patterns:0    #目前被订阅的模式数量</span><br><span class="line">latest_fork_usec:878    #最近一次 fork() 操作耗费的微秒数</span><br></pre></td></tr></table></figure></p><p>如果参数是CPU，那么就会返回CPU的相关信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info cpu</span><br><span class="line"># CPU</span><br><span class="line">used_cpu_sys:63.95    #Redis服务器耗费的系统CPU</span><br><span class="line">used_cpu_user:129.54    #Redis服务器耗费的用户CPU </span><br><span class="line">used_cpu_sys_children:1.70    #子进程耗费的系统CPU</span><br><span class="line">used_cpu_user_children:1.03    #子进程耗费的用户CPU</span><br></pre></td></tr></table></figure></p><p>如果参数是keyspace，那么就会返回数据库相关的统计信息：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# redis-cli -h 127.0.0.1 -p 6379 info keyspace</span><br><span class="line"># Keyspace</span><br><span class="line">db0:keys=262,expires=183,avg_ttl=284091259423    #据库的键数量、数据库设置有过期时间的key的数量（这个值减少是正常的）</span><br></pre></td></tr></table></figure></p><p>除了以上之外其他还有更多信息，请移步：<a href="http://redisdoc.com/server/info.html" target="_blank" rel="noopener">http://redisdoc.com/server/info.html</a> 。感谢前人栽树！！！</p><h2><span id="使用zabbix监控redis">使用zabbix监控redis</span></h2><p>用zabbix监控redis是一个很简单的事儿，只需要把需要监控的数据提取出来即可。而提取数据的方法就是利用info去得到对应的数值。</p><p>首先先来一个判断redis服务器连接的脚本：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@func-redis-001 ~]# cat check_redis.sh</span><br><span class="line">#这个脚本是用来zabbix监控自建redis的</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">PORT=<span class="string">'6379'</span></span><br><span class="line">PASSWD=‘REDIS密码’ </span><br><span class="line">STATUS_redis=$(redis-cli -h <span class="string">'127.0.0.1'</span> -p $PORT -a $PASSWD ping)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$STATUS_redis"</span> == <span class="string">'PONG'</span> ];then</span><br><span class="line">        echo <span class="string">'1'</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        echo <span class="string">'0'</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>然后更改zabbix_agentd.conf,如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=redis_status[*],redis-cli -h <span class="string">'127.0.0.1'</span> -p $<span class="number">1</span> info | grep -w $<span class="number">2</span> | awk -F<span class="string">':'</span> <span class="string">'&#123;print $NF&#125;'</span></span><br><span class="line">UserParameter=redis_ping,sudo sh /root/check_redis.sh</span><br></pre></td></tr></table></figure></p><p>修改/etc/sudoers文件如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root    ALL=(ALL)       ALL</span><br><span class="line">zabbix  ALL=(ALL)       NOPASSWD:ALL    #这个是新增</span><br><span class="line">Defaults:zabbix !requiretty        #这个是新增</span><br></pre></td></tr></table></figure></p><p>保存之后，重启zabbix-agent服务，由于我这个redis是通过zabbix-proxy监控的，所以在zabbix-proxy一端用<code>zabbix_get</code>来查看结果：<br><img src="/images/motiorredis.png" alt="抱光妹" title="zabbix_get到redis内容"></p><p>然后在zabbix-proxy的模板里面添加一些需要监控的item即可，有必要的话可以设置trigger+action用来报警，如图：<br><img src="/images/zabbixredis.png" alt="抱光妹" title="配置item"></p><p>最后就是grafana搞一个炫酷的图表来，如图：<br><img src="/images/grafanaredis.png" alt="抱光妹" title="使用grafana展示成果"></p><p>最后一点，关于redis的内存优化，各位可以来看看：<a href="https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://cachecloud.github.io/2017/02/16/Redis%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</a> ，写的很全面了。还有zabbix各种模板整理，有需要的同学也可以去下载：<a href="https://monitoringartist.github.io/zabbix-searcher/" target="_blank" rel="noopener">https://monitoringartist.github.io/zabbix-searcher/</a> 。</p>]]></content>
    
    <summary type="html">
    
      要好好对待自己的那个Redis
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>通过nginx配置修改网页cookie属性</title>
    <link href="http://yoursite.com/2018/01/10/%E9%80%9A%E8%BF%87nginx%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9%E7%BD%91%E9%A1%B5cookie%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2018/01/10/通过nginx配置修改网页cookie属性/</id>
    <published>2018-01-10T07:48:08.000Z</published>
    <updated>2018-01-10T08:09:04.789Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="需求与具体配置">需求与具体配置</span></h2><p>公司的电子商城在十九大等保安检时期被折腾出去，结果这几天又折腾回来了，据说还会是明年大数据研究院的主要开发项目。结果回来没几天被测试中心的人在cookie方面发现了几个问题，如下：</p><ol><li>cookie没有使用http-only；</li><li>cookie没有携带secure属性；</li><li>http头中需要配置“X-Frame-Options：SAMEORIGIN”；</li></ol><p>以上这几点可以通过nginx的配置来轻松实现，具体方法就是在需要更改的网页server的配置里面添加下面几句话。如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_header                  <span class="built_in">Set</span>-Cookie <span class="string">"HttpOnly"</span>;</span><br><span class="line">add_header                  <span class="built_in">Set</span>-Cookie <span class="string">"Secure"</span>;</span><br><span class="line">add_header                  X-Frame-Options <span class="string">"SAMEORIGIN"</span>;</span><br></pre></td></tr></table></figure></p><p><img src="/images/addheader.png" alt="好车" title="修改配置文件如图"></p><p>然后保存配置文件，<code>nginx -s reload</code>平滑重启即可，通过chrome在目标网页里按下<code>ctrl+shift+c</code>，先选择好<code>network</code>，然后重新刷新一下界面，选择域名，对应域名下点击<code>headers</code>，就会看到<code>cookie</code>的配置情况，如图：<br><img src="/images/seecookie.png" alt="好车" title="cookie生效"></p><h2><span id="扩展内容">扩展内容</span></h2><p>看到配置已经生效。那么这几个配置主要是干什么的呢？其实主要都是防范XSS攻击（跨域脚本攻击）的。</p><p>Cookie的Secure属性，意味着保持Cookie通信只限于加密传输，指示浏览器仅仅在通过安全/加密连接才能使用该Cookie。如果一个Web服务器从一个非安全连接里设置了一个带有secure属性的Cookie，当Cookie被发送到客户端时，它仍然能通过中间人攻击来拦截。 </p><p>Cookie的HttpOnly属性，指示浏览器不要在除HTTP（和HTTPS)请求之外暴露Cookie。一个有HttpOnly属性的Cookie，是不可以通过例如调用JavaScript(引用document.cookie)这种非HTTP方式来访问。因此，也不可能通过跨域脚本（一种非常普通的攻击技术）来偷走这种Cookie。</p><p>X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在<code>frame</code>, <code>iframe</code>或者<code>object</code>中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。它有三个可选择项：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DENY：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许；</span><br><span class="line">SAMEORIGIN：表示该页面可以在相同域名页面的 frame 中展示；</span><br><span class="line">ALLOW-FROM uri地址：表示该页面可以在指定来源的 frame 中展示；</span><br></pre></td></tr></table></figure></p><p>如果设置为 DENY，不光在别人的网站 frame 嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为 SAMEORIGIN，那么页面就可以在同域名页面的 frame 中嵌套。</p><p>这里还要额外注意一下！<font color="red">配置了Cookie的HttpOnly属性和Secure属性之后，如果测试中心的人使用的协议是http而不是https的话，会有“浏览器请求后端服务时header不会带上cookie参数”的现象，那是因为“由于secure属性的存在，导致浏览器在与服务器通信时不会使用该cookie”。这个时候就需要把secure=”true”这个配置去掉才可以达到正确测试的目的。</font></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://imququ.com/post/my-nginx-conf-for-security.html" target="_blank" rel="noopener">https://imququ.com/post/my-nginx-conf-for-security.html</a></p>]]></content>
    
    <summary type="html">
    
      用配置cookie来防御xss攻击
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="运维技术" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>django新增class的时候数据库格式出错</title>
    <link href="http://yoursite.com/2018/01/10/django%E6%96%B0%E5%A2%9Eclass%E7%9A%84%E6%97%B6%E5%80%99%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A0%BC%E5%BC%8F%E5%87%BA%E9%94%99/"/>
    <id>http://yoursite.com/2018/01/10/django新增class的时候数据库格式出错/</id>
    <published>2018-01-10T07:33:06.000Z</published>
    <updated>2018-01-10T08:08:49.973Z</updated>
    
    <content type="html"><![CDATA[<p>这几天开发频繁要求查看生产环境zookeeper的配置，于是就想在django里添加一个新的栏，以文本的形式随时更新zookeeper的情况。</p><p>于是我就登陆了django，在<code>model.py</code>里添加一个新的class，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#建立杭州测试ZK配置</span><br><span class="line">class HZfunczk(models.Model):</span><br><span class="line">   hzfunczk_remark = models.CharField(verbose_name=<span class="string">'杭州测试ZK配置'</span>,max_length=<span class="number">50000</span>,blank=<span class="literal">true</span>)</span><br><span class="line">   hzfunczk_signer = models.CharField(verbose_name=<span class="string">'登记人'</span>,max_length=<span class="number">30</span>,<span class="keyword">default</span>=<span class="string">'system'</span>)</span><br><span class="line">   hzfunczk_signtime = models.DateField(auto_now_add=True)</span><br><span class="line"></span><br><span class="line">   def __unicode__(self):</span><br><span class="line">       <span class="keyword">return</span> self.domain_name</span><br></pre></td></tr></table></figure></p><p>然后在django的目录下执行<code>python manage.py makemigrations</code>，这一步没问题，但是在执行<code>python manage.py migrate</code>的时候，就出现了下面的错误：<br><img src="/images/django1.png" alt="akb48" title="数据库格式不对"></p><p>我开始认为是charfield写错了，应该写Textfield，于是更改了一下，但是保存之后，再执行<code>python manage.py migrate</code>还是出错。其实这个错误主要原因就是因为我那个50000设置错了，因为字段hzfunczk_remark定义的长度50000超出了mysql的varchar的最大长度21845（在utf8编码情况下）。于是我就在<code>model.py</code>里把这个长度改成20000，保存之后，还是执行到<code>python manage.py migrate</code>这一步，依旧爆上面的错误。于是我就干脆把这个class先删除掉，没想到都删除光了，还是在<code>make</code>的时候会爆错。</p><p>这就很奇怪了，我已经删掉了为啥还有这样的事儿？于是就干脆进入到数据库去看，由于我现在只知道列名叫hzfunczk_remark，所以我要根据这个列名去查它所在的表，maria反馈如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [abccs]&gt; select TABLE_SCHEMA, TABLE_NAME <span class="keyword">from</span> information_schema.columns where COLUMN_NAME = <span class="string">'hzfunczk_remark'</span>; </span><br><span class="line">Empty set (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure></p><p>好尴尬呀，数据库里压根就没有列名为“hzfunczk_remark”的表。然后由于<code>python manage.py migrate</code>报错，现在无法启动django。怎么办？</p><p>遇到这种状况，就去django里的migrations文件夹，这个文件夹里有很多的以时间命名的py文件，它们记录着数据库的每一步操作，不过这里面的py还没有真正执行到数据库里，我找到当时添加class那个时间段的py文件，里面是这样的：<br><img src="/images/django2.png" alt="akb48" title="记录数据库操作的PY细节"></p><p>先把里面CharField改成TextField，然后把50000改成小于21845的就行了。如果你性子比较烈，那就干脆把这个文件以及之后产生的所有文件都删除掉。重新的去<code>make</code>。</p><p>如果还是实在不行，还有一个万不得已的办法，几乎所有的数据库错误都可以用这个方法解决：<font color="red">将migrations文件夹下的文件除了<strong>init</strong>.py全部删掉，然后将数据库drop掉，重新建数据库。然后make和migrate，就可以使用一个新的数据库</font>（但愿你永远用不到这个方法）。</p>]]></content>
    
    <summary type="html">
    
      sql添加行的时候可不能为所欲为...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>通道信息加密工具--Qtunnel</title>
    <link href="http://yoursite.com/2018/01/10/%E9%80%9A%E9%81%93%E4%BF%A1%E6%81%AF%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7-Qtunnel/"/>
    <id>http://yoursite.com/2018/01/10/通道信息加密工具-Qtunnel/</id>
    <published>2018-01-10T04:20:01.000Z</published>
    <updated>2018-01-10T08:09:03.354Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="前言">前言</span></h2><p>数据库做异地容灾是一个很常见的现象，既然信息要跨地域传递，要么就很土豪的打通机房之间的链路或者动用VPN，要不然就不可避免的走公网网络传输信息。既然选择了公网，那么数据库的语句就很容易被人监听到，所以把那些明文加密是必不可少的环节。</p><p>mysql支持<code>tls/ssl</code>加密方法对信息进行加密，这个方法的配置也很简单，就是两边各加上一个nginx，一个是正向代理一个是反向代理，配上ssl证书，然后就像配置网站https协议那样，在nginx.conf里开启ssl监听即可。</p><p>但是这种方法有一点小问题，就是在进行SSL握手之前，mysql会发送Server Greeting和Login Request数据包，然后才有可能使用SSL握手。这样步骤就多了一步鉴权，对访问性能有所影响。所以这个时候，我选择了另一个用于加密client和server之间链路通信的工具—-Qtunnel，因为它直接加密，速度更快。</p><p>Git的地址在这里：<a href="https://github.com/arstercz/qtunnel" target="_blank" rel="noopener">https://github.com/arstercz/qtunnel</a> ，<strong>感谢arstercz大神的再加工！</strong></p><p>上面说过了Qtunnel是不需要认证的，默认加密方法是RC4，以字节流的方式加密明文的每一个字节，而且密钥长度最长支持256位，可以很好的抵御暴力搜索密钥的攻击，总而言之，Qtunnel是一个轻量且快速的加解密工具，而且还可以搭配atlas等数据库中间件使用。</p><h2><span id="下载与准备">下载与准备</span></h2><p>由于Qtunnel是用go语言写的，所以需要先安装golang，centos服务器的yum安装方法如下:<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh http:<span class="comment">//dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span></span><br><span class="line">yum install -y golang</span><br></pre></td></tr></table></figure></p><p>go语言安装完毕之后，我们就<code>git clone https://github.com/arstercz/qtunnel.git</code> ，获得qtunnel文件夹，文件夹内容如下：<br><img src="/images/downqtunnel.png" alt="抱光妹" title="qtunnel下载包内容"></p><p><code>make</code>，如果没有任何报错，那么就是安装成功了，使用<code>./bin/qtunnel -h</code>语句验证一番：<br><img src="/images/installqtunnel.png" alt="抱光妹" title="验证qtunnel"></p><p>本次实验的计划是这样的：用A机器访问B机器的mysql，并且插入数据，在B机器上的3306端口抓包，查看数据是否是明文；然后再在A机器和B机器上都安装qtunnel并且启动，然后重新插入数据，在B机器上的端口抓包，查看数据是否被加密。流程图如下：<br><img src="/images/架构.png" alt="抱光妹" title="架构图"></p><h2><span id="实验开始">实验开始</span></h2><p>A机器和B机器都是使用阿里云虚拟服务器，版本都是centos 6.4，现在我们的加密实验正式开始。</p><p>首先A和B机器上都不启动qtunnel，然后我们在A机器上登陆B机器的数据库，如果之前没有授权，那么授权语句是：<br>    <code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;A机器的IP地址&#39; IDENTIFIED BY &#39;密码&#39; WITH GRANT OPTION;</code></p><p>登陆mysql之后，我们随意的插一个语句，然后通过抓包发现无论这个语句还是数据库的反馈都是以明文的形式呈现，如图：<br><img src="/images/shujuluoben.png" alt="抱光妹" title="数据在明文裸奔"></p><p>这种让数据裸奔的行为无疑于找死，那么这个时候我们就要配置一下qtunnel，来看一下它的加密效果。</p><p>在A服务器上，我们设定qtunnel是客户端，手动建立一个conf文件，比如<code>vim /etc/conn.conf</code>，内容如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[client1]</span><br><span class="line">faddr = 10.252.215.108:3309    #这里是qtunnel客户端的IP</span><br><span class="line">baddr = 10.175.193.239:3310    #这里是qtunnel服务端的IP</span><br><span class="line">cryptoMethod = rc4             #这里选用rc4的方式加密</span><br><span class="line">secret = 3301_test%Iad      #rc4密钥，服务端的密码必须跟这个一致！</span><br><span class="line">clientmode = true              #表示这端是客户端</span><br></pre></td></tr></table></figure></p><p>然后使用<code>./bin/qtunnel -conf=/etc/conn.conf -daemon -logto=syslog</code>启动qtunnel，看一下进程和端口情况，如图：<br><img src="/images/aqidong.png" alt="抱光妹" title="看一下A进程和端口情况"></p><p>在B服务器上，同样手动建立一个配置文件，假设也叫conn.conf，内容如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[server1]</span><br><span class="line">faddr = 10.175.193.239:3310    #这里是qtunnel服务端的IP</span><br><span class="line">baddr = 10.175.193.239:3306    #这里是数据库的地址，由于在同一台机器上，所以地址一样</span><br><span class="line">cryptoMethod = rc4    </span><br><span class="line">secret = 3301_test%Iad      #rc4密钥，跟client密钥一致</span><br><span class="line">clientmode = false             #表示这是服务器端</span><br></pre></td></tr></table></figure></p><p>也用同样的语句启动qtunnel，查看3310这个端口已经被监听了：<br><img src="/images/bqidong.png" alt="抱光妹" title="看一下B进程和端口情况"></p><p>现在，我们在A服务器上来重新连接B数据库，但是要注意！<font color="red">这个时候mysql里的-h不能再是B的IP地址了，而是A的地址！因为qtunnel现在已经打通了一个通道，访问qtunnel的3310端口就等于是访问B数据库的3306端口（有点类似atlas的意思）。</font></p><p>连上之后，我们随意插入一些语句，看一下qtunnel的能力:<br><img src="/images/shujubuluoben.png" alt="抱光妹" title="数据已经被加密了"></p><p>可见这个时候，抓包显示都是加密的文字了，实验成功！</p><h2><span id="总结与参考资料">总结与参考资料</span></h2><p>总结一下：qtunnel采用rc4加密，在算法强度和速度方面是很好的选择，不会引起slave太大的延迟，对管理员或开发而言数据都是透明的（如果在上面的实验启动了qtunnel之后，不监听3310端口，而是监听3306端口，得到的依旧是明文），只是在两端传输的过程中增加了加解密处理。核心的业务(比如用户和充值)在做异地架构的时候可以考虑该方式增强数据的安全性。</p><p>《mysql使用ssl简析》：<a href="https://hsulei.com/2017/10/19/mysql%E4%BD%BF%E7%94%A8ssl%E7%AE%80%E6%9E%90/" target="_blank" rel="noopener">https://hsulei.com/2017/10/19/mysql%E4%BD%BF%E7%94%A8ssl%E7%AE%80%E6%9E%90/</a><br>《使用ssl加密mysql 5.6的官方文档》：<a href="https://dev.mysql.com/doc/refman/5.6/en/encrypted-connections.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/encrypted-connections.html</a></p>]]></content>
    
    <summary type="html">
    
      你总不会采取“数据在公网裸奔”这样的找死行为吧。
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="加密技术" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Qtunnel" scheme="http://yoursite.com/tags/Qtunnel/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix3.0搭配微信企业号报警</title>
    <link href="http://yoursite.com/2018/01/10/Zabbix3-0%E6%90%AD%E9%85%8D%E5%BE%AE%E4%BF%A1%E4%BC%81%E4%B8%9A%E5%8F%B7%E6%8A%A5%E8%AD%A6/"/>
    <id>http://yoursite.com/2018/01/10/Zabbix3-0搭配微信企业号报警/</id>
    <published>2018-01-10T03:18:02.000Z</published>
    <updated>2018-01-10T03:42:45.188Z</updated>
    
    <content type="html"><![CDATA[<p>Zabbix搭配微信企业号报警是一个很流行的手段，这里说一下如何配置。</p><h2><span id="准备工作">准备工作</span></h2><p>建立一个企业号以及具体应用的链接在此：<a href="http://chenx1242.blog.51cto.com/10430133/1954634，里面写的都很明白了。" target="_blank" rel="noopener">http://chenx1242.blog.51cto.com/10430133/1954634，里面写的都很明白了。</a></p><p>现在打开微信企业号的官方网站<a href="https://work.weixin.qq.com，然后扫描一下微信二维码登录到企业号的控制台。" target="_blank" rel="noopener">https://work.weixin.qq.com，然后扫描一下微信二维码登录到企业号的控制台。</a></p><p>在控制台网页里，需要查找几个元素，分别是<code>CorpID</code>、<code>应用AgentId</code>、<code>应用Secret</code>还有<code>用户账号</code>。</p><p>首先，在控制台里选择“我的企业”，然后就可以看见<code>CorpID</code>，如图：<br><img src="/images/corpid.png" alt="抱光妹" title="获取CorpID"></p><p>然后点击“企业应用”，如果没有应用，那么就新建立一个应用。比如我已经建立了一个应用叫“zabbix告警”，那么应用AgentId和应用Secret就在如图的位置：<br><img src="/images/aksk1.png" alt="抱光妹" title="应用AgentId和应用Secret"></p><p>有了上面的CropID和Secret，就可以去验证一下accesstoken，登录<a href="http://qydev.weixin.qq.com/debug" target="_blank" rel="noopener">http://qydev.weixin.qq.com/debug</a> ，后在填入对应的CropID和Secret，看一下返回结果是否是“HTTP/1.0 200 OK”，如图：<br><img src="/images/checkaksk.png" alt="抱光妹" title="验证AgentId和Secret"></p><p>在这个“zabbix告警”的应用里可见范围里添加对应需要通知的人，然后在“通讯录”里，找到对应的人，记录他们的账号，如图：<br><img src="/images/content.png" alt="抱光妹" title="通讯录联系人"></p><p>材料已经俱备完毕，现在需要做的是更改zabbix-server配置。</p><p>首先，在zabbix-server.conf里添加一句<code>AlertScriptsPath=/usr/lib/zabbix/alertscripts</code>，这是为了说明一下脚本所在的路径。当然，这个路径你可以自己更改，然后重启一下zabbix-server。</p><h2><span id="编写脚本">编写脚本</span></h2><p><code>cd /usr/lib/zabbix/alertscripts</code>，在这个目录下我们要新写一个微信脚本，比如脚本名称叫<code>wechat.py</code>。</p><p>这个python脚本是需要requests模块的，所以需要先安装这个模块，安装方法如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install --upgrade requests</span><br></pre></td></tr></table></figure></p><p>而python脚本内容如下，<strong>感谢<a href="https://github.com/X-Mars/Zabbix-Alert-WeChat/的脚本" target="_blank" rel="noopener">https://github.com/X-Mars/Zabbix-Alert-WeChat/的脚本</a></strong>：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python2.7</span></span><br><span class="line">#_*_coding:utf-8 _*_</span><br><span class="line">#this script is used for alarm by WECHAT</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests,sys,json</span><br><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">urllib3.disable_warnings()</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">def GetToken(Corpid,Secret):</span><br><span class="line">   Url = <span class="string">"https://qyapi.weixin.qq.com/cgi-bin/gettoken"</span></span><br><span class="line">   Data = &#123;</span><br><span class="line">       <span class="string">"corpid"</span>:Corpid,</span><br><span class="line">       <span class="string">"corpsecret"</span>:Secret</span><br><span class="line">   &#125;</span><br><span class="line">   r = requests.get(url=Url,params=Data,verify=False)</span><br><span class="line">   Token = r.json()[<span class="string">'access_token'</span>]</span><br><span class="line">   <span class="keyword">return</span> Token</span><br><span class="line">    </span><br><span class="line">def SendMessage(Token,User,Agentid,Subject,Content):</span><br><span class="line">   Url = <span class="string">"https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=%s"</span> % Token</span><br><span class="line">   Data = &#123;</span><br><span class="line">       "touser": User,                                 # 企业号中的用户帐号，在zabbix用户Media中配置，如果配置不正常，将按部门发送。</span><br><span class="line">       #"totag": Tagid,                                # 企业号中的部门id，群发时使用。</span><br><span class="line">       "msgtype": "text",                              # 消息类型。</span><br><span class="line">       "agentid": Agentid,                             # 企业号中的应用id。</span><br><span class="line">       <span class="string">"text"</span>: &#123;</span><br><span class="line">           <span class="string">"content"</span>: Subject + <span class="string">'\n'</span> + Content</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="string">"safe"</span>: <span class="string">"0"</span></span><br><span class="line">   &#125;</span><br><span class="line">   r = requests.post(url=Url,data=json.dumps(Data),verify=False)</span><br><span class="line">   <span class="keyword">return</span> r.text</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   User = sys.argv[1]                                                              # zabbix传过来的第一个参数</span><br><span class="line">   Subject = sys.argv[2]                                                           # zabbix传过来的第二个参数</span><br><span class="line">   Content = sys.argv[3]                                                           # zabbix传过来的第三个参数</span><br><span class="line">   Corpid = <span class="string">"这里填写Corpid"</span>                                                   </span><br><span class="line">   Secret = <span class="string">"这里填写Secret"</span>                           </span><br><span class="line">   Agentid = <span class="string">"这里填写应用的agentid"</span>                                                        </span><br><span class="line">   Token = GetToken(Corpid, Secret)</span><br><span class="line">   Status = SendMessage(Token,User,Agentid,Subject,Content)</span><br><span class="line">   print Status</span><br></pre></td></tr></table></figure></p><p>脚本保存后，<code>chown -R zabbix:zabbix wechat.py</code>，然后小试一下，上面看到“Zabbix告警”这个微信应用里有一个用户账号叫ChenShuo，那么wechat.py执行语句是：<code>python wechat.py ChenShuo 这个是标题  这里是正文！！</code></p><p>然后看一下微信，如图：<br><img src="/images/checkpy.jpg" alt="抱光妹" title="脚本验证成功"></p><p>正确出现了微信提示，可见这个脚本是OK的了。</p><h2><span id="配置zabbix">配置zabbix</span></h2><p>现在我们要登录到zabbix网站，最上面的“Administration”里选择“Media types”，新建立一个Media type，如图：<br><img src="/images/mediatype.png" alt="抱光妹" title="新建立Media type"></p><p>保存之后，在“Administration”里选择“Users”，在Admin用户里点击“media”,把刚刚新增的“微信告警”这个media type添加进去，如图：<br><img src="/images/addpy.png" alt="抱光妹" title="添加Media type"></p><p>通知手段配置完毕，现在就是要在具体的Trigger上把微信告警这个新手段添加到active里。首先打开Configuration里的actions界面。此时假设现在有一个告警Trigger叫“模块发生了重启”，判断模块是否重启的依据就是pid值是否发生了变化。那么点击这个Trigger，在action里把“微信告警”添加到报警手段里，如图：<br><img src="/images/addtrigger.png" alt="抱光妹" title="配置trigger"></p><p>保存之后，整个的微信告警配置就完成了。为了验证配置是否生效，我冒死重启了一台生产环境的服务器，当然啦，好孩子千万不要效仿。</p><p>收到微信提示如图：<br><img src="/images/checkpy2.jpg" alt="抱光妹" title="脚本验证成功"><br>不过考虑到微信告警可能会有所延迟，所以在这建议大家把告警阈值配置稍微早一点，避免“孩子死了奶来了”这种尴尬的情况。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://www.yfshare.vip/2017/04/13/Zabbix%E4%B9%8B%E5%BE%AE%E4%BF%A1-Wechat-%E5%91%8A%E8%AD%A6/" target="_blank" rel="noopener">http://www.yfshare.vip/2017/04/13/Zabbix%E4%B9%8B%E5%BE%AE%E4%BF%A1-Wechat-%E5%91%8A%E8%AD%A6/</a><br><a href="https://github.com/X-Mars/Zabbix-Alert-WeChat/" target="_blank" rel="noopener">https://github.com/X-Mars/Zabbix-Alert-WeChat/</a></p>]]></content>
    
    <summary type="html">
    
      让微信报警来占据你和你的运维同事的业余时间...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>自己动手搭建一个hexo博客demo</title>
    <link href="http://yoursite.com/2018/01/10/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAhexo%E5%8D%9A%E5%AE%A2demo/"/>
    <id>http://yoursite.com/2018/01/10/自己动手搭建一个hexo博客demo/</id>
    <published>2018-01-10T02:54:51.000Z</published>
    <updated>2018-01-10T03:39:34.098Z</updated>
    
    <content type="html"><![CDATA[<p>曾几何时，自己动手做一个博客的想法愈加强烈，想在里面放一些更多除了技术之外的东西，比如烹饪的美食，比如PVP的视频，比如拍摄的照片，比如篮球足球的评论。在这种需求下，我从众多博客框架里面选择了hexo，原因就是“很多人都推荐hexo”….（囧）于是乎我在windows里搞一个，由于我在公司的网络是可以跨越长城的，所以搞github有一点天然的优势。而且github的博客不用花钱搞域名，他直接免费提供…</p><p><strong>在搞github的时候墙裂推荐各位去用命令行，有linux的基本基础就可以很熟练的使用命令行搞github， 它的客户端真的不如命令行好用。</strong></p><h2><span id="准备工作">准备工作</span></h2><p>先去注册一个github，然后去<a href="https://git-scm.com" target="_blank" rel="noopener">https://git-scm.com</a> 上下载一个最新的git windows的客户端，我下载的是2.15.1版本，如图：<br><img src="/images/zhucegithub.png" alt="抱光妹" title="windows下载github"></p><p>下载完毕之后，就把这个exe文件安装，然后在“开始”里找到git再打开“Git Bash”，我的github账号是<code>RorschachChan</code>，电子邮件也已经配置过，所以现在就在这个bash窗口里写入如下语句：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"RorschachChan"</span></span><br><span class="line">git config --global user.email <span class="string">"chenx1242@163.com"</span></span><br></pre></td></tr></table></figure></p><p><img src="/images/config1.png" alt="抱光妹" title="确定用户名和邮箱"><br>上面git config –global 参数，表示你这台机器上所有的Git仓库都会使用这个配置。</p><p>再去<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a> 上根据自己windows的情况，下载最新的nodejs，下载完了之后就一路next，然后需要退出重进一下git bash，在bash的命令行里输入<code>node -v</code>，看到版本号就是OK，同时输入node，$会变成&gt;，然后输入.exit就可以退出返回到bash。<br><img src="/images/nodeV.png" alt="抱光妹" title="查看node版本"></p><p>然后就是安装hexo，hexo的安装比较简单，就是在git bash里输入<code>npm install -g hexo-cli</code>和<code>npm install -g hexo</code>，然后需要等待一会，如果出现了“npm ERR! ”不要怕，重新输入一次应该就会好了，安装完毕之后，输入$ hexo -v查看hexo的版本，如图：<br><img src="/images/installhexo1.png" alt="抱光妹" title="安装hexo-cli"><br><img src="/images/installhexo2.png" alt="抱光妹" title="安装hexo"></p><p>然后建立一个github ssh密钥，在git bash里输入<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>，然后告诉密钥生成的路径（下图黄框）以及会让你输入对应的口诀（红色箭头），这个口诀很重要，要妥善保存，如图：<br><img src="/images/githubak.png" alt="抱光妹" title="配置密钥"></p><p>这个密码会在你提交项目（<code>hexo d</code>）时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。这时候去<code>C:\Users\33664\.ssh</code>的路径里就会看到一对钥匙，<strong>id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</strong><br><img src="/images/miyao.png" alt="抱光妹" title="密钥在这里"></p><p>来到github的个人配置里，选择“SSH and GPG keys”，然后输入title和id_rsa.pub的内容，点击“add ssh key”。如图：<br><img src="/images/addak.png" alt="抱光妹" title="在github添加ak"><br>准备工作的最后一步，就是建立一个文件夹，我的文件夹建立在E盘下，名字就叫hexo。</p><h2><span id="开始搭建博客">开始搭建博客</span></h2><p>首先在git bash里进入/e/hexo，然后输入<code>hexo init</code>，这个命令是初始化命令，再输入<code>hexo -g</code>来生成静态文件，执行之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github上你的用户名.github.io的仓库上去的。然后可以输入<code>hexo s</code>来本地启动hexo，这个时候跑到浏览器里输入<code>localhost:4000</code>就会看到hexo博客最初的一个样子，如图：<br><img src="/images/hexo1.png" alt="抱光妹" title="最初是状态的hexo"></p><p>这个默认的主题比较难看，我们去<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> 下载最近一个比较火爆的主题next,并且把这个下载到hexo文件夹里的themes/next里，语句是：<code>git clone https://github.com/iissnan/hexo-theme-next.git themes/next</code><br><img src="/images/installnext.png" alt="抱光妹" title="安装next主题"></p><p>然后打开hexo文件夹里的_config.xml，把原有的theme注释，换成新的next，注意，中间是有空格的！<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#theme: landscape</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><p>然后<code>hexo clean</code>和<code>hexo g</code>清除 Hexo 的缓存和重新生成静态文件，再次<code>hexo s</code>启动进程，来到浏览看一下发现博客的样子就变成下面的样子了：<br><img src="/images/next1.png" alt="抱光妹" title="展示next主题"><br>这个看上去就简单大方很多了吧。</p><h2><span id="把博客上传到github">把博客上传到github</span></h2><p>现在有人问了，这个博客看上去好像很美，但是有两个致命的缺陷：第一，内容都是在我的windows里，如果我这个电脑坏了/出差/换新硬盘，那么如何保证我以前文件？第二，我启动进程需要执行 <code>hexo -s</code>，如果我电脑关机了，岂不是博客无法打开？</p><p>需要解决就要把磁盘上的内容传递到github库里了，同时github是常开进程的，这样既可以更新我们的内容又不会关闭博客进程，除非github这个网站黄了。</p><p>先去github网站去建立一个库（repository），这里我直接选择了公共读，如图：<br><img src="/images/repository.png" alt="抱光妹" title="建立一个新库"></p><p>然后在hexo文件夹里面，修改一下_config.xml的几个地方：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: 石锤淡啤酒    #这个是网站在标签页的标题</span><br><span class="line">subtitle: 生活就是等待戈多    #这个是副标题</span><br><span class="line">description: 这里记录的不只有代码，还有生活和思想！    #这里也可以写网站的关键词，也可以矫情的写点别的</span><br><span class="line">author: Chris Chan    #这个作者会在网页最下面显示</span><br><span class="line">language: zh-Hans    #这里表示简体中文</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line"> type: git</span><br><span class="line"> repository: git@github.com:RorschachChan/RorschachChan.github.io.git    #这里写的就是刚刚申请的库名</span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure></p><p>建立完库以及修改保存了_config.xml之后，我们执行一句<code>hexo d</code>部署命令，在执行的时候需要输入当时你建立id_rsa时候的口诀，刚刚申请的那个口诀不会这么快就忘了吧。<br><img src="/images/hexod.png" alt="抱光妹" title="部署博客"></p><p>返回到github的网站就看到hexo里所有的内容都上传到了github网站里了，如图:<br><img src="/images/hexod2.png" alt="抱光妹" title="上传成功"></p><p>在浏览器里输入“<a href="https://你的用户名.github.io”，就看到了博客界面：" target="_blank" rel="noopener">https://你的用户名.github.io”，就看到了博客界面：</a><br><img src="/images/newnext.png" alt="抱光妹" title="更改了主题和作者的界面"></p><p>同理，如果你的github用户名是test，建立的是test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io" target="_blank" rel="noopener">http://test.github.io</a> 了，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>至此，建立一个博客demo就到此结束了！</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://baoyuzhang.github.io/2017/04/28/【Hexo搭建独立博客全纪录】（一）使用Git和Github/" target="_blank" rel="noopener">https://baoyuzhang.github.io/2017/04/28/【Hexo搭建独立博客全纪录】（一）使用Git和Github/</a><br><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a><br><a href="http://opiece.me/2015/04/09/hexo-guide/" target="_blank" rel="noopener">http://opiece.me/2015/04/09/hexo-guide/</a><br><a href="http://shenzekun.cn/hexo的next主题个性化配置教程.html" target="_blank" rel="noopener">http://shenzekun.cn/hexo的next主题个性化配置教程.html</a> 强烈推荐这篇文章，可以让你把next主题的博客做的更加漂亮！</p>]]></content>
    
    <summary type="html">
    
      记录自己搭窝的过程，方便以后搭更多的窝...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="博客搭建" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Query String跟Arg的差异</title>
    <link href="http://yoursite.com/2018/01/09/Query-String%E8%B7%9Farg%E7%9A%84%E5%BC%82%E5%90%8C/"/>
    <id>http://yoursite.com/2018/01/09/Query-String跟arg的异同/</id>
    <published>2018-01-09T12:47:40.000Z</published>
    <updated>2018-01-09T14:06:15.915Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="前言与需求">前言与需求</span></h2><p>在<a href="https://rorschachchan.github.io/2018/01/09/记一次配置rewrite和return的经历/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/01/09/记一次配置rewrite和return的经历/</a> 里记录了一次rewrite和return的故事，不过我当时在最后的return里是把域名给写死了：<code>rewrite ^.*$ http://dvlshop.lechange.com/index.php/wap/$id$query last;</code>。</p><p>现在新的需求又来了，说域名不要写死，<code>http://dvlshop.lechange.com/index.php/</code>这部分要跟整个uri的state部分保持一致。</p><p>于是我这里再把整个uri贴出来，辣一下各位的眼睛：<br><a href="http://dvlshop.lechange.com/index.php/wap/?" target="_blank" rel="noopener">http://dvlshop.lechange.com/index.php/wap/?</a><br><em>client_id</em>=lc_mall_m&amp;<br><em>redirect_uri</em>=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;<br><em>response_type</em>=code&amp;    <code>#满足条件的话把这个改成+auto+</code><br><em>scope</em>=read&amp;<br><em>state</em>=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;<br><em>user</em>=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;<br><em>expire</em>=1514191636&amp;<br><em>source_type</em>=lc_app&amp;<br><em>nonce</em>=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27 </p><p>也就是说现在只需要变量state那点部分，那么这个时候就不能再使用$query_string了，要使用$arg。</p><p>$arg可以精确匹配变量，比如说我有一个参数（uri里？后面的那部分全叫参数）：&amp;p=你大爷&amp;q=你大娘，用$query_string和$arg就是获取所有，而使用$arg_p就是可以获取“你大爷”。</p><p>于是说动手就动手，把nginx.conf改成了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.php.*</span><br><span class="line">&#123;</span><br><span class="line">    include php_fcgi.conf;</span><br><span class="line">    include pathinfo.conf;</span><br><span class="line">    set $flag <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span> ( $args ~ <span class="string">"source_type=lc_app"</span> ) &#123;</span><br><span class="line">       set $flag  <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( $args ~ <span class="string">"(.*)response_type(.*)"</span> )&#123;</span><br><span class="line">       set $Flag  <span class="string">"$flag$flag"</span>;</span><br><span class="line">       set $id $<span class="number">1</span>;</span><br><span class="line">       set $query $<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ($Flag = <span class="string">"11"</span>)&#123;</span><br><span class="line">        set $flag <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">301</span>  $arg_state$id+auto+$query;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是通过日志查看，发现$arg_state得到的是<code>/http%3A%2F%2Fdvlshop.lechange.com%2Fproduct-79.html</code>,这就很囧了，我希望获取<code>http%3A%2F%2Fdvlshop.lechange.com%2Fproduct-79.html</code>（不要前面的反斜杠）或者是<code>/product-79.html</code>（不要中间的网站）。这可怎么办？</p><p>答案是，<strong>原生的nginx是做不到这一点，因为nginx不参与业务层逻辑方面的业务。</strong>如果说要达到改写的目的，就要搭配lua或者把nginx换成openresty。于是乎就让开发修改一下传递的state来达到目的。</p><h2><span id="扩展与补充">扩展与补充</span></h2><p>看到这个结果突然让我想起来一道面试题，说开发有一个模块，同时这个模块会给nginx提供几个状态码，比如状态码是111，那就是代表OK，状态码不是111，那就是代表不OK，现在想写一个语句，如果nginx获得的状态码不是111，返回一个404的页面，怎么写？</p><p>没错，答案也是“原生nginx写不了”，原因跟上面的一样，应用模块状态码是业务层的，nginx是http层的，不在一层压根就无法交流。</p><p>在这里也顺道补充一下“在浏览器中输入一个URL后都发生了什么？”，以下是一个大概流程：</p><ol><li>浏览器向DNS服务器查找输入URL对应的IP地址；</li><li>DNS服务器返回网站的IP地址；</li><li>浏览器根据IP地址与目标web服务器建立TCP连接；</li><li>发送HTTP请求；</li><li>服务器处理请求；</li><li>返回响应结果；</li><li>关闭TCP连接；</li><li>浏览器解析HTML；</li><li>浏览器布局渲染；</li></ol><p><img src="/images/家有喜事.gif" alt="星爷、李丽珍、张曼玉" title="《家有喜事》"></p>]]></content>
    
    <summary type="html">
    
      $query_string搞不定的事情，$arg来！
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>记一次配置rewrite和return的经历</title>
    <link href="http://yoursite.com/2018/01/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%85%8D%E7%BD%AErewrite%E5%92%8Creturn%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2018/01/09/记一次配置rewrite和return的经历/</id>
    <published>2018-01-09T08:39:10.000Z</published>
    <updated>2018-01-11T03:02:43.284Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="前言与需求">前言与需求</span></h2><p>自动电商平台归属了大数据研究院之后，我又恢复了那个“把nginx当成爸爸”的日子。开发不断地提出了的要求，我一样一样的疲命应付，并且在应付后记录下来，就怕以后再遇到类似的问题。</p><p>这次的需求是一个跳转，满足某个条件之后把<code>“http://dvlshop.lechange.com/index.php/wap/?client_id=lc_mall_m&amp;redirect_uri=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;response_type=code&amp;scope=read&amp;state=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;user=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;expire=1514191636&amp;source_type=lc_app&amp;nonce=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27 ”</code><br>改成<br><code>“http://dvlshop.lechange.com/index.php/wap/?client_id=lc_mall_m&amp;redirect_uri=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;=code&amp;scope=read&amp;state=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;user=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;expire=1514191636&amp;source_type=lc_app&amp;nonce=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27”</code></p><p>具体条件是: </p><ol><li>先判断是否有source_type=lc_app；</li><li>再判断是否有response_type；</li><li>如果以上两个都满足，将“response_type”改成“+auto+”；</li></ol><p>各位看官，我理解你们此时不想继续看下去的心情，其实我当初看着那么一大坨uri心里也直犯闹，但是没办法，“食君之禄，分君之忧”，我只能耐着性子一个一个的拆开，还别说，拆开的话就清晰许多了，如下：<br><a href="http://dvlshop.lechange.com/index.php/wap/?" target="_blank" rel="noopener">http://dvlshop.lechange.com/index.php/wap/?</a><br><em>client_id</em>=lc_mall_m&amp;<br><em>redirect_uri</em>=https%3A%2F%2Fdvlshop.lechange.com%2Fopenapi%2Ftrustlogin_api%2Fparse%2Fwap_trustlogin_lecheng%2Fcallback&amp;<br><em>response_type</em>=code&amp;    <code>#满足条件的话把这个改成+auto+</code><br><em>scope</em>=read&amp;<br><em>state</em>=http%3A%2F%2Fdvlshop.lechange.com%2Findex.php%2Fwap&amp;<br><em>user</em>=token%2Flcid_9f9lmo2u6i7hkl6t6eaodn2blmg5jbsg&amp;<br><em>expire</em>=1514191636&amp;<br><em>source_type</em>=lc_app&amp;<br><em>nonce</em>=cdizHO6uvSx5JK79Kmtz5RBpSi0ROhpF&amp;signature=VeCceYCWDE6BZjIdni/68YCmhqc=%27 </p><h2><span id="开始操作">开始操作</span></h2><p>针对这次需求我的计划是这样的：把原地址看成”$1+ response_type +$2”这样的一个样式，确定$1和$2，然后rewrite成”$1+ +auto+ +$2”不就搞定了么？ 于是乎我就凭着我那二把刀的nginx技术开始动手。折腾了大约半个小时，拿出来这样一个配置：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location ~ .*\.php.*</span><br><span class="line">   &#123;</span><br><span class="line">       include php_fcgi.conf;</span><br><span class="line">       include pathinfo.conf;</span><br><span class="line">       set $flag <span class="string">"0"</span>;</span><br><span class="line">       <span class="keyword">if</span> ( $request_uri ~ <span class="string">"source_type=lc_app"</span> ) &#123;</span><br><span class="line">          set $flag  <span class="string">"1"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ( $request_uri ~ <span class="string">"(.*)response_type(.*)"</span> )&#123;</span><br><span class="line">          set $Flag  <span class="string">"$flag$flag"</span>;</span><br><span class="line">          set $id $<span class="number">1</span>;</span><br><span class="line">          set $query $<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       if ($Flag = "11")&#123;#注意这个地方是11</span><br><span class="line">           set $flag <span class="string">"0"</span>;</span><br><span class="line">          rewrite ^.*$ http:<span class="comment">//dvlshop.lechange.com/index.php/wap/$id$query last;#前面那一段是写死的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>但是很不幸，<code>nginx -s reload</code>之后的结果是“$1+$2+$1+ response_type +$2”的格式（地址太长太恶心了，我就不写了）。</p><p>然后在arstercz大神的指点下，把那句rewrite改成了<code>return 301 http://dvlshop.lechange.com/index.php/wap/?$id$query;</code>。就达到了效果。</p><h2><span id="原因确定">原因确定</span></h2><p>后来追寻原因，原来是： <font color="red">rewrite后面接的$uri不需要$args，因为$args会被自动带过来。而return的则会丢失$args，需要手动补上$args。</font>而我上面的$1,$2恰巧就是$args，所以用rewrite的话就会重复。举个例子，比如请求「<a href="http://localhost/?a=1」想被" target="_blank" rel="noopener">http://localhost/?a=1」想被</a> 301 到「<a href="https://localhost/?a=1?a=1」，要么" target="_blank" rel="noopener">https://localhost/?a=1?a=1」，要么</a><br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    rewrite / https:<span class="comment">//$host$uri permanent;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要么就<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">301</span> https:<span class="comment">//$host$request_uri;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="补充说明">补充说明</span></h2><p>PS，这里补充一下uri、request_uri、document_uri之间的区别：</p><ul><li>$request_uri: /stat.php?id=1585378&amp;web_id=1585378</li><li>$uri: /stat.php    (不带？后面)</li><li>$document_uri: /stat.php    （与uri完全相同）</li></ul><p><img src="/images/hugguangmei.gif" alt="抱光妹" title="《四重奏》"></p>]]></content>
    
    <summary type="html">
    
      比较一下return跟rewrite的不同。
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux运维工程师面试题第一套</title>
    <link href="http://yoursite.com/2018/01/04/Linux%E8%BF%90%E7%BB%B4%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E5%A5%97/"/>
    <id>http://yoursite.com/2018/01/04/Linux运维工程师面试题第一套/</id>
    <published>2018-01-04T08:46:41.000Z</published>
    <updated>2018-01-09T08:38:19.625Z</updated>
    
    <content type="html"><![CDATA[<p>这套题的出处是<a href="http://blog.51cto.com/nolinux/1670406，看到了闲着没事周末就做一做，答案都是我自己在工作里得到的，不一定百分百准确，只是无聊的时候做做，现在拿出来跟各位分享一番。" target="_blank" rel="noopener">http://blog.51cto.com/nolinux/1670406，看到了闲着没事周末就做一做，答案都是我自己在工作里得到的，不一定百分百准确，只是无聊的时候做做，现在拿出来跟各位分享一番。</a></p><p><strong>1、请写出五种系统性能分析工具，并简述其作用和特点</strong><br>[我的答案] top、free、vmstat、iostat、perf等等等等，如果你想装逼，可以回答fio,blktrace，oprofile。<br>具体的作用和特点这里不多说了，但是我着重要推荐vmstat，很实用很棒的一个命令。</p><p><strong>2、请写出web服务器的调优要点</strong><br>[我的答案]以nginx为例，个人总结有如下几个要点：<br>1）尽可能的少用http，因为http是有开销的；<br>2）尽可能的使用CDN；<br>3）添加Expire/Cache-Control头，这个头是缓存用的，可以缓存图片和flash那样不轻易更改的文件，减少访问时间；<br>4）启动gzip压缩，这个没啥好说的了；<br>5）尽可能少的重定向，能rewrite就不要return，我也知道return比rewrite好写，但是重定向是需要时间的，增加一次重定向就会多一次web需求；<br>6）如果可以，把ajax也做缓存；<br>7）减少dns查询，很多网页会有外站的广告，这些广告也是会启动dns查询的，所以如果不缺钱，减少这种广告；<br>8）调好服务器里的TCP协议栈，这个无论是web服务器还是应用服务器都是必须的；</p><p><strong>3、请写出你知道或使用过的nginx扩展模块（注意标注知道和使用）</strong><br>[我的答案] 随便说几个，这玩意到时候结合工作过的情况说说吧：<br>Nginx负载均衡模块：nginx-upstream-fair<br>非阻塞访问redis模块：redis2-nginx-module<br>分布式图片实时动态压缩：ngx-fastdfs</p><p><strong>4、请简述你了解的自动化配置管理工具特点和运行原理</strong><br>[我的答案]我用的最多的就是ansible和saltstack，这俩都是python的，对于我这个半路出家的更亲切。<br>ansible基于SSH协议传输数据，不用装agent，配置比较简单，对windows支持惨不忍睹；<br>saltstack使用消息队列zeroMQ传输数据，如果1000台以上的话它速度比ansible还要快,要安装agent，对windows支持同样惨不忍睹；</p><p><strong>5、目前，有一个文件，内容如下：<br>         172.16.100.1<br>         172.16.100.2<br>         172.16.100.3<br>         172.16.100.4<br>   请使用while和ssh命令，登录文件内的ip并执行hostname命令</strong><br>[我的答案]这个我还真没有什么思路，不过应该是跟“&lt;”输入重定向命令结合的一个脚本吧。<br>PS,为啥不用ansible…哪怕pssh也可以啊！</p><p><strong>6、请使用awk命令将如下两份文件中名字相同的两行合并起来<br>   A文件：<br>          大广州 21岁<br>          广州大 23岁<br>          州广大 22岁<br>          广州大 24岁<br>   B文件：<br>          广州大 男<br>         大广州 男<br>          州广大 男<br>          广州大 男<br>输出效果：<br>    <code>大广州 21岁 男</code></strong><br>[我的答案]awk ‘NR==FNR{a[$1]=$2}NR&gt;FNR{print $0,a[$1]}’  第2个文件名 第1个文件名<br><img src="/images/awkpinjie.png" alt="awk拼接" title="awk拼接的效果"><br>PS，做完这道题，我已经不认识“广”“州”这两个字了…</p><p><strong>7、请使用绘图的方式简述TCP/IP三次握手和四次断开的交互过程</strong><br>[我的答案]这种图满大街都是了，我这个灵魂画师在这里就不污染各位的眼睛，不过这里推荐各位去看一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=2651160450&amp;idx=2&amp;sn=1128438fa5287b6cee503880698642b2&amp;scene=21" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&amp;mid=2651160450&amp;idx=2&amp;sn=1128438fa5287b6cee503880698642b2&amp;scene=21</a> 对原理讲的浅显易懂。<br>多说一句，网易招聘java的时候也问这个问题，不过他们问的是“为什么要三次握手？”</p><p><strong>8、请根据你的理解，简述高可用服务体系的相关组件，并列举该组件的具体实现服务名字</strong><br>[我的答案] 我觉得这个题是要问一些架构上的东西，以我工作环境为例：<br>统一配置:zookeeper、Consul、Etcd+Confd(这俩比较常见于动态管理nginx)<br>前端展示:nginx<br>消息队列:activemq、kafka<br>读写分离中间件:atlas<br>日志分析:elk</p><p><strong>9、请根据你的理解，简述负载均衡的实现方式</strong><br>[我的答案]负载均衡主要分为两种，硬件（F5）和软件（NGINX、Haproxy、LVS），硬件效果比较牛逼，它是把<strong>4-7层的负载均衡功能做到一个硬件里面</strong>，但是价格昂贵最近用的越来越少了。<br>软件的负载均衡又分两种，四层和七层：四层是<strong>在IP/TCP协议栈上把网络包的IP地址和端口进行修改</strong>，达到转发的目的；七层就是<strong>在应用层里把HTTP请求、URL等具体的应用数据发送到具体的服务器上</strong>。四层的效率比七层的高，四层一般安排在架构的前端，七层一般就是在具体服务器的前端。<br>软件负载均衡比较常见的几个分配方式如下：<br>轮询：访问请求依序分发给后端服务器；<br>加权轮询：访问请求依序分发后端服务器，服务器权重越高被分发的几率也越大；<br>最小连接数： 将访问请求分发给当前连接数最小的一台后端服务器，服务器权重越高被分发的几率也越大；</p><p><strong>10、请根据你的理解，简述数据迁移工具和数据存储服务有哪些以及相关特点</strong><br>[我的答案]由于我公司主要都放在了阿里云，数据库用过的就这么几个:mysql、redis和elasticsearch。对于Storm和Hadoop这俩我还是初学者。<br>mysql:关系型数据库<br>elasticsearch:全文检索框架，这玩意逐渐向一个数据库靠拢了<br>redis:键值储存数据库</p><p>mysql的数据迁移最常见的就是mysqldump，但是要注意使用不当会锁表，<br>redis的数据迁移最稳妥的方法就是主从同步：在slave端启动redis，然后执行<code>slaveof master机器IP地址 6379</code>，然后使用<code>info</code>的时候查看<code>master_link_status</code>如果是<code>up</code>那就是OK了，再执行<code>slaveof no one</code>,提示OK就是OK了；<br>Elasticsearch的数据迁移工具就是Elasticsearch-Exporter，不过我对它仅仅只是了解，用的并不多； </p><p><strong>总结</strong><br>这套题不算难，方向是偏应用的，但是对云端服务的运维来说不算很友好，因为云厂商基本都把数据备份和数据迁移都做成自己的工具（比如阿里云的DTS），所以很多云服务的运维对这种东西了解不多。</p><p><img src="/images/welcomekuniao.jpg" alt="欢迎新人" title="欢迎来到巴塞罗那！库迪尼奥"></p>]]></content>
    
    <summary type="html">
    
      把基础知识重新看起来
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx动态编译新的模块</title>
    <link href="http://yoursite.com/2018/01/03/Nginx%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E6%96%B0%E7%9A%84%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/01/03/Nginx动态编译新的模块/</id>
    <published>2018-01-03T13:44:44.000Z</published>
    <updated>2018-01-04T04:50:19.075Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="开始动手">开始动手</span></h2><p>打算给电脑上的nginx添加一个当时没有编译安装的echo-nginx-module模块，这是一个第三方模块，要知道nginx要添加模块是需要重新编译的，这一点跟apache不同，apache是在配置文件里引用.so文件的。</p><p>首先先<code>nginx -V</code>，查看一下nginx已经编译的模块都有啥，如图：<br><img src="/images/nginxV.png" alt="akb48" title="nginx模块一览"></p><p>于是我就<code>git clone https://github.com/openresty/echo-nginx-module</code>，但是发现竟然告诉我“git: command not found”。oh shit，原来这台nginx实验机器压根就没有装过git啊！而yum源里的软件基本上已经过时的太久了，就拿git来说吧，使用<code>yum info git</code>看到的版本是1.8.3.1。但是在<a href="https://github.com/git/git/releases" target="_blank" rel="noopener">https://github.com/git/git/releases</a> 里可以看到，git的版本现在已经丧心病狂的到达了2.16的版本了。<br><img src="/images/yuminfogit.png" alt="akb48" title="git版本太落后"></p><h2><span id="那么我们先安装git">那么我们先安装git!</span></h2><p>通过<code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel</code>和<code>yum install  gcc perl-ExtUtils-MakeMaker</code>来安装依赖库。<code>wget https://github.com/git/git/archive/v2.16.0-rc0.tar.gz</code>来下载2.16的git保存到centos里。<code>tar -xzvf v2.9.2.tar.gz -C /目标目录/</code>，然后在目标目录里面执行<code>make prefix=/usr/local/git all</code>和<code>make prefix=/usr/local/git install</code>，编译过程可能会比较长，请耐心等待。</p><p>编译结束之后，<code>echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &gt;&gt; /etc/bashrc</code>，把git添加到环境变量，再<code>source /etc/bashrc</code>让它实时生效，最后再一次看看<code>git --version</code>，大功告成！<br><img src="/images/gitversion.png" alt="akb48" title="展现git版本"></p><h2><span id="编译新模块">编译新模块</span></h2><p>git搞定了之后，重新<code>git clone https://github.com/openresty/echo-nginx-module</code>，然后在nginx的configure文件夹里面，把echo-nginx-module模块添加上。命令如下：</p><p><code>./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre=/root/pcre-8.41 --with-http_v2_module --add-module=/root/echo-nginx-module-0.61</code>,我这里还附赠了一个“http_v2_module”。</p><p>configure完毕之后，去<code>make</code>一下就可以了，不要轻易<code>make install</code>，不然就是重新安装了。原来的nginx.conf等配置都没了。</p><p>养成替换nginx二进制文件的好习惯，如下：</p><pre><code>cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bakcp nginx编译目录/objs/nginx /usr/local/nginx/sbin/</code></pre><p>然后再打开看一下<code>nginx -V</code><br><img src="/images/nginxV2.png" alt="akb48" title="安装模块成功"></p>]]></content>
    
    <summary type="html">
    
      你的nginx总不能一辈子都不变的吧
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>从vmstat命令里看服务器瓶颈</title>
    <link href="http://yoursite.com/2018/01/03/%E4%BB%8Evmstat%E5%91%BD%E4%BB%A4%E9%87%8C%E7%9C%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%93%B6%E9%A2%88/"/>
    <id>http://yoursite.com/2018/01/03/从vmstat命令里看服务器瓶颈/</id>
    <published>2018-01-03T12:56:56.000Z</published>
    <updated>2018-01-08T14:24:31.445Z</updated>
    
    <content type="html"><![CDATA[<p>这几天重新翻看基础知识，看到了<code>vmstat</code>，我认为它是一个非常优秀的命令,因为它包括了<code>top</code>和<code>free</code>，甚至还包含了一些io的信息，可以说是运维人员常备命令之一。常用方法：<code>vmstat (-a) 多少秒刷一次 刷多少次</code>。</p><p><img src="/images/vmstat.png" alt="vmstat" title="vmstat的效果"></p><p>对上面这个图来一个简单的解释：</p><p>r: 运行队列中进程数量，这个值长期大于1就要判断是否需要增加CPU。<br>b: 等待IO的进程数量</p><p>swpd: 使用虚拟内存大小(如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能）<br>free: 空闲物理内存大小<br>buff: 用作缓冲的内存大小<br>cache: 用作缓存的内存大小(如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小)<br>inact: 非活跃内存大小（当使用-a选项时显示）<br>active: 活跃的内存大小（当使用-a选项时显示）</p><p>si: 每秒从交换区写到内存的大小，由磁盘调入内存<br>so: 每秒写入交换区的内存大小，由内存调入磁盘<br>注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。</p><p>bi: 每秒读取的块数<br>bo: 每秒写入的块数<br>注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。</p><p>in: 每秒中断数，包括时钟中断。<br>cs: 每秒上下文切换数。<br>注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。</p><p>us: 用户进程执行时间百分比(user time)<br>注意： us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。</p><p>sy: 内核系统进程执行时间百分比(system time)<br>注意：sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。</p><p>wa: IO等待时间百分比<br>注意：wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。</p><p>id: 空闲时间百分比</p><p>最后总结：如果r经常大于4 ，且id经常少于40，表示cpu的负荷很重。如果bi，bo长期不等于0，表示内存不足。</p><p>r（运行队列）展示了正在执行和等待CPU资源的任务个数。当这个值超过了CPU数目，就会出现CPU瓶颈了。 CPU 100%并不能说明什么，Linux总是试图要CPU尽可能的繁忙，使得任务的吞吐量最大化。唯一能够确定CPU瓶颈的还是r（运行队列）的值。</p>]]></content>
    
    <summary type="html">
    
      使用vmstat查看服务器情况
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运维" scheme="http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>关于阿里云CDN的两个故障解决</title>
    <link href="http://yoursite.com/2017/12/28/CDN%E7%BD%91%E7%AB%99%E4%B8%80%E6%AC%A1%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/12/28/CDN网站一次打不开的问题/</id>
    <published>2017-12-28T09:34:57.000Z</published>
    <updated>2018-01-09T06:13:19.193Z</updated>
    
    <content type="html"><![CDATA[<p>测试中心今天在测试时候发现了一个问题：官方的A网站做了域名跳转，跳转到阿里云CDN，但是在浏览器里输入A地址栏的时候，发现域名的确变成了CDN的域名，但是页面是403。</p><p>如图：<br><img src="/images/cdn403.png" alt="跳转CDN出现403" title="跳转CDN出现403"></p><p>但是奇怪的是，再在浏览器点击一下回车，网页就神奇的打开了。</p><p>这个原因就是阿里云的CDN有一个“Refer防盗链”，需要在防盗链里面把A域名添加到白名单，这样的话就可以直接访问了。至于为什么第二次回车就可以访问，是因为那时候域名已经成CDN自己的域名了，当然可以访问。<br><img src="/images/referer.png" alt="refer防盗链配置" title="在这里添加防盗链的白名单"></p><p>但是这个防盗链也要注意！毕竟白/黑名单添加都是一个危险举动，一定三思后行。有可能你的css\js是用cdn加速的，一旦加上了白名单，可能css就会变得很难看。</p><p>不就之后，商城也下来一个需求，说公司有两个多年不用的域名B和C，打算废物利用，两个都要达到直接“跳转官网”的目的。</p><p>于是我就到阿里云域名管理的那里搜索一下，发现目前官网域名后端绑定的是一个CDN，于是也把域名B和域名C做一个CNAME到这个域名，不过登陆浏览器发现域名B和域名C都反馈502。</p><p>于是我就到电子商城后端的nginx.conf里查看，确认server_name字段没有写错，然后把域名B和域名C的CNAME直接改成了CDN的域名，再通过了dig确认。但是等于浏览器还是发现502。</p><p>最后找了阿里云的人了解，原来阿里云规定“一个CDN只能绑定一个域名，因为节点上没有那两个域名的配置，所以只要不符合节点上有配置文件信息的，全部502”。所以B和C是无法访问的。要解决这个问题有两招，1）把域名B和域名C直接A记录绑定CDN后面的SLB上，但是代价就是访问速度不如CDN快；2）重新购买两个CDN，都绑定SLB，然后把这两个CDN分别绑定到域名B和域名C上，代价是多收一点流量费…</p><p><img src="/images/messi.jpg" alt="梅西在国家德比进球" title="在伯纳乌进球感觉真好！"></p>]]></content>
    
    <summary type="html">
    
      为啥有些网站必须要点两次才能打开？
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="CDN" scheme="http://yoursite.com/tags/CDN/"/>
    
      <category term="网站技术" scheme="http://yoursite.com/tags/%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>screen的用法</title>
    <link href="http://yoursite.com/2017/12/21/screen%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/21/screen的用法/</id>
    <published>2017-12-21T07:59:44.000Z</published>
    <updated>2018-01-04T03:35:41.357Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候在Linux要后台执行程序，都是使用“&amp;”，或者是nohup，不过这两个更多应用于临时的脚本。一个比较高科技的方法就是使用<code>screen</code>。</p><p>安装screen的方法很简单：<code>yum install -y screen</code>。</p><p>如果新建一个screen，就输入<code>screen -S name</code>，这样会新开一个窗口，然后执行命令。比如我要启动django，那么就输入<code>python manage.py runserver 0.0.0.0:9000</code>即可。</p><p>这个重开一个窗口，列出所有screen进程，就这样：</p><pre><code>[root@docker ~]# screen -lsThere are screens on:    3029.xiedi    (Attached)</code></pre><p>如果想链接上之前那个django，执行命令<code>screen -r 3029</code>即可。</p><p><img src="/images/kobe.png" alt="goodbye,Kobe" title="kobe vs durant"></p>]]></content>
    
    <summary type="html">
    
      如果你想在后台执行程序...
    
    </summary>
    
      <category term="用来讨饭吃的技术" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E8%AE%A8%E9%A5%AD%E5%90%83%E7%9A%84%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="其他软件" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>pictest</title>
    <link href="http://yoursite.com/2017/12/13/pictest/"/>
    <id>http://yoursite.com/2017/12/13/pictest/</id>
    <published>2017-12-13T13:40:06.000Z</published>
    <updated>2018-01-03T07:06:26.282Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个我用来测试图片上传的文章<br><a id="more"></a></p><p>啊！五环，你比四环多一环！<br>啊！五环，你比六环少一环！<br><img src="/images/1.gif" alt="akb48" title="天气妹儿"><br>终于有一天，你会修到七环</p><p><img src="/images/paradin.jpg" alt="paradin" title="SQ"></p>]]></content>
    
    <summary type="html">
    
      这是一个我用来测试图片上传的文章
    
    </summary>
    
      <category term="用来保护视力的图片" scheme="http://yoursite.com/categories/%E7%94%A8%E6%9D%A5%E4%BF%9D%E6%8A%A4%E8%A7%86%E5%8A%9B%E7%9A%84%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="美女" scheme="http://yoursite.com/tags/%E7%BE%8E%E5%A5%B3/"/>
    
      <category term="图片" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>这里记录的不只有代码，还有生活和思想！</title>
    <link href="http://yoursite.com/2017/12/13/%E8%BF%99%E9%87%8C%E8%AE%B0%E5%BD%95%E7%9A%84%E4%B8%8D%E5%8F%AA%E6%9C%89%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%BF%98%E6%9C%89%E7%94%9F%E6%B4%BB%E5%92%8C%E6%80%9D%E6%83%B3%EF%BC%81/"/>
    <id>http://yoursite.com/2017/12/13/这里记录的不只有代码，还有生活和思想！/</id>
    <published>2017-12-13T06:17:22.000Z</published>
    <updated>2018-01-10T04:19:02.637Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/石锤淡啤酒.png" alt="beer" title="那些在阳光下挥洒青春的日子啊！"></p><p>你说要一个人去旅行　但是归期却没有约定　亚得里亚海边风中的吉他声<br>你说你带着苍白的回忆　却谢谢能与我相逢　我怕你在异乡夜里孤独醒来<br>要拒绝两人单调的生活　想寻找自由　迷信了爱情　就迷失了我自己<br>你就这样　离开吧　抛弃吧　他乡的旅人<br>你就那样　离开吧　抛弃吧　一个人生活</p><p>你说要一个人去旅行　眼里藏着一朵乌云　知道你藏不住秘密　天空就会飘着雨<br>你说你带着一本日记　却不想再拥有回忆　我怕你在异乡孤独的醒来<br>要拒绝两人单调的生活　不想再随波逐流　迷信了孤独　就软弱的抛弃了我的等待</p><p>你就这样　离开吧　抛弃吧　他乡的旅人<br>你就那样　离开吧　抛弃吧　让我孤独生活</p><p>你就这样　离开吧　抛弃我　孤独的旅人<br>你就这样　离开我　抛弃我　让我孤独生活</p><p>我想要一个人去旅行　但愿归期会有约定　每个人都在问我　是否可以找到自由的你<br>亚得里亚海边他乡的人和风中的吉他声　我怕你一个人在异乡孤独醒来<br>我会带着你回来</p>]]></content>
    
    <summary type="html">
    
      先用陈升先生的一首《一个人去旅行》做我这个博客的开场白
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="音乐" scheme="http://yoursite.com/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="感悟" scheme="http://yoursite.com/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>
