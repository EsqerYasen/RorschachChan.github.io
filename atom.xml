<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chris Chan&#39;s BLOG</title>
  
  <subtitle>那些在阳光下挥洒青春的日子啊！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-28T01:24:33.709Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Chris Chan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>超赞的京都大阪五日游</title>
    <link href="http://yoursite.com/2018/05/25/%E8%B6%85%E8%B5%9E%E7%9A%84%E4%BA%AC%E9%83%BD%E5%A4%A7%E9%98%AA%E4%BA%94%E6%97%A5%E6%B8%B8/"/>
    <id>http://yoursite.com/2018/05/25/超赞的京都大阪五日游/</id>
    <published>2018-05-25T07:34:25.000Z</published>
    <updated>2018-05-28T01:24:33.709Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>说来惭愧，活了30年了这是我第一次出国旅行，借着公司有一次旅游的机会就跟女朋友一起到京都和大阪玩5天。</p><p>搞定了签证，在网上买好了USJ的快速通行票，又预定了随身WIFI，简单在穷游、知乎和马蜂窝上做了做自由行的攻略，18号晚上6点半从杭州萧山机场出发，两个小时后到达关西机场。之前在《miss pilot》里看到过ANA的航空，这一次亲自乘坐感觉还是不错，飞机场有吃有玩还有葡萄酒喝。</p><p>到关西机场之后，又按指纹又照相的通过了一连串的海关检查，就跟公司其他小伙伴兵分两路，他们去奈良看鹿，我跟女票直接去京都。凭借女票的三脚猫日语功力和她已经来过大阪的经验，我俩先办理了地铁卡，购买了一日游行卡，然后坐上了从大阪出发到京都。</p><p>从大阪到京都大约花了一个半小时左右，抵达京都已经是晚上11点了。路上下着细细小雨，再加上两人拖着箱子有点肚饿，就在路边的seven-eleven里简单买了一点水和东西，买东西之余发现在超市里有成人书籍出售。从便利店出来顺着google地图找之前在爱彼迎上预订的民宿，那是一个公寓型民宿，凭借店主之前在邮件里写的密码，我们从信箱里拿到房间钥匙。</p><h2><span id="日本的庙">日本的庙</span></h2><p>京都是一个充满寺庙和神社的地方，京都的旅行就是“从这个庙出来，到下一个庙去”，而清水寺正是京都众多庙里人气很旺的景点之一，日本的庙和神社有一个习惯，入寺前先用竹勺洗手，如果要入室参拜的话还要脱鞋。在京都穿和服是一个很常见的事情，而且我觉得一群人穿和服是一个蛮cool的风景，不过女票没有租，但是在寺里买了很多的御守。</p><p>昨晚到京都太晚，无法注意天空，到了白天才发现京都的天真的很蓝，看见远方的山轻而易举。从清水寺出来下一站是八坂神社，巧的是遇到了一对新婚夫妇在这里结婚拍照，不得不说日本新郎传统的黑和服加扇子的形象还是很帅的。</p><h2><span id="日本的玩">日本的玩</span></h2><p>水族馆一直都是我非常喜欢的地方，而大阪海游馆也是这一次游玩里安排的一个重要环节，但是比较让我失望的是它的海底隧道很短，大约也就杭州水族馆的一半长度。我俩没有看到喂食节目，而且海游馆也没有海豹顶球，海豚跳舞这样的节目。不过海游馆的鱼种类还是很多的，有些品种还可以亲手去摸一摸它们。出了海游馆就是一个蛮大的摩天轮，用一日通票的话可以免费上去坐一圈。</p><p>大阪的USJ是我们这次日本之行的最后一站也是最高潮的部分，去年圣诞节我跟女票在上海的迪士尼度过的。从迪士尼回来就一直碎碎念大阪的环球影城，我俩还特意挑选了一个工作日去玩就是为了尽可能的少排队，但是那天依旧很多很多人，真的超火爆。</p><p>环球影城的运营模式跟迪士尼差不多，通过IP分主题区，可以购物也有花车游行。但是整个乐园的玩法相对单一—-都是过山车：哈利波特是过山车、蜘蛛侠是过山车、小黄人是原地晃晃过山车、侏罗纪公园是水上过山车，至于翼龙飞行和好莱坞美梦更是超刺激的过山车…</p><p>这一次环球影城的特殊项目有四个：怪物猎人、美少女战士（看动画片）、柯南（密室逃脱）和最终幻想。我跟女票还有公司同事都选择了柯南，虽然通篇日语对白，不过还是能猜出来一个大概剧情，所以一个半小时玩下来感觉就像看了一遍柯南的剧场版，里面的解密就不剧透了，机关真的很难，想要在一个小时内完全逃脱几乎是一个不可能的任务。</p><p>上面把正经的娱乐说完了，下面来说一点不正经的娱乐。我和女票在大阪住在日本桥地铁站附近，那里距离道顿堀走路也就10分钟的路程，而道顿堀附近有一个街叫宗右卫门町，那里就是大阪有名的牛郎街，一路走过去各种牛郎宣传大海报和在路边搭讪的小哥，甚至那附近的小吃店里还有牛郎哥的宣传单。除了铺天盖地的牛郎哥哥外还有站街的妹妹，大多数都是黄发浓妆，但是仔细看脸都不算太好看的。这些人会跟过往的单身男女搭讪，邀请他们去店里坐坐喝点酒说说话，至于有没有更进一步的皮肉关系，那就不好说了。而且据说他们是不做不懂日语人的生意的，所以如果他们真的纠缠你了，就直接说我是外国人就好。</p><h2><span id="日本的购物">日本的购物</span></h2><p>到了日本，买东西是必然的。不过当地的大商场关门很早，基本晚上八点半左右就开始关门。在伏见稻荷大社甚至有的商铺五点半就打烊了，我很好奇，商场这么早关门，那日本人晚上的娱乐是什么呢？他们除了去居酒屋喝酒和广场溜达再加上回家看电视难道就没有其他的娱乐了吗？</p><p>不过，各大药妆店的营业时间很晚，甚至唐吉坷德是24小时营业。这种地方里充满了大陆人、香港人、台湾人、韩国人还有泰国人，在人群和背包中穿梭，拎着篮子买买买，买到5000就可以退税。我女票这次买了很多的卸妆水乳液面膜眼霜口红还有零食，作为一个在旁边无事可做的男人，深深地觉得陪女人逛街是一个很遭罪的事情。</p><h2><span id="日本的吃">日本的吃</span></h2><p>我是看过《深夜食堂》和《孤独的美食家》的，所以对日本的食物有一点好感，而且在杭州吃到日本料理也不是一个难事。不过这次到了日本，连续吃了五天当地的饭，发现日本的菜其实很单一。</p><p>日本普通的餐就是“米饭+猪肉\牛肉\鸡肉+沙拉+味增汤”，日本的米饭是很好吃的，但是他们的肉做法基本就是炸，炒是很少的。如果不是米饭的话就是炒面、拉面、寿司或者是煎饺。期间我跟女票吃了一次烤肉，里面有“最强牛里脊和牛肠”给我留下了很深的印象。此外在海游馆还吃到了我梦寐已久的大阪烧，插播一句话，吃大阪烧的时候还看到足球运动员郑大世，我女票一眼就认出他来了…</p><p>日本的消费能力不低，五天下来，基本上每一顿饭都大约花费了3000多日元，在吉野家吃算比较便宜的，2000不到就能搞定。在烤肉店要了套餐，每人是5000日元。这次在日本，觉得最好吃的是牛里脊，然后就是烤蟹壳。</p><p>说完了吃再说说喝，大阪和京都随处可见自动售卖机，售卖机里面基本就是五样饮品—水、绿茶、优酸乳、可乐和咖啡，价钱还都差不多。日本的水果很贵，一个不到6斤重的西瓜就要2200日元左右，橘子大约五块钱一个，但是他们的酒却相比较便宜。在日本我可没少喝梅子酒、气泡果酒和啤酒。</p><h2><span id="日本的电视">日本的电视</span></h2><p>我俩住的民宿有一个小电视，里面有12个频道，其中三个是购物频道…我想可能日本的免费电视就这么点，大多数都是收费频道。这九个电视台白天有新闻，有韩剧，有街头采访；晚上有芭蕾舞片段、有综艺节目、还有打着圣光的肉番！说到综艺节目，里面有一个片段就是把秃头用毛巾擦的锃亮，然后用遥控板去对着秃头摁键，结果信号经过秃头的折射，竟然能顺利的操纵电视。再后来叫来两个秃头，尝试多次折射，依旧可以准确遥控电视…就这么一个环节把我之前从来不看日本综艺节目的同事笑翻了，回国后就开始恶补这种日本综艺。</p><h2><span id="游玩的tips">游玩的tips</span></h2><p>1.日本路边的垃圾箱很少，据说是因为他们没有边走路边吃喝东西的习惯，所以随处带一个塑料袋来装垃圾；<br>2.USJ的快速通行证只有日语区的页面才有，请准备好visa和master卡；<br>3.办理的地铁充值卡不要扔，下一次再来日本，直接储值依旧可以使用；<br>4.到了USJ别上来先买东西，要先排队玩，东西可以放到最后出院的时候再买；<br>5.不会日语在一般情况下没问题，但是如果看不懂车站的话，就难免要问路了，这样会比较头疼，准备一个google翻译。<br>6.champion在日本的地摊也有卖，人民币大约100多，所以淘宝上那些200左右的champion完全不需要考虑…</p><h2><span id="这次的遗憾">这次的遗憾</span></h2><p>这次玩的蛮爽的，但是大阪仅仅只有三天只能玩一个皮毛，比如本次出游的遗憾如下：</p><p>1.据说大阪有一个棒球场，20日元一个球，然后通过发球机器发射，游客可以轮棒尝试一下本垒打的快感，但是由于时间太紧没有打上棒球…<br>2.没有去游戏机厅，以前常在漫画里看到日本有那种弹子机，如果赢的多，可以用塑料筐装满小弹子去换钱，这种游戏机厅在大阪的商场很常见，而且门口都有大广告，上面写“新品到店，欢迎畅玩”；<br>3.在龟梨和也和山下智久主演的《我命中注定的人》里，龟梨和也手工雕刻了一个王将的木牌，这次到了大阪逛了很多店，都没有发现这款木雕，不仅没有这个木雕，连战国时期各大将的头盔纺织品也没有看到，这一点很遗憾；<br>4.USJ里的变形金刚和终结者2都暂时停业，不过我后来在B战上看了视频，还是过山车…</p><p>等下一次如果有机会能去东京的话，就尝试把上面几个弥补上，再顺便去一趟秋叶原。</p>]]></content>
    
    <summary type="html">
    
      这五天在日本走了两个完全不同的城市
    
    </summary>
    
      <category term="坠乱花天" scheme="http://yoursite.com/categories/%E5%9D%A0%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="日本" scheme="http://yoursite.com/tags/%E6%97%A5%E6%9C%AC/"/>
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab+Jenkins搭建持续集成系统</title>
    <link href="http://yoursite.com/2018/05/25/Gitlab-Jenkins%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/05/25/Gitlab-Jenkins搭建持续集成系统/</id>
    <published>2018-05-25T07:33:46.000Z</published>
    <updated>2018-05-26T02:07:19.218Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>gitlab是一个应用很广泛的版本控制工具，他也有自带的持续集成工具—<code>gitlab cli</code>，但是这个工具不如jenkins那么好用。本文的目的要把gitlab和jenkins进行结合，当我们更新了代码并且把代码push到gitlab的时候，gitlab会把代码的变化通知到jenkins，然后jenkins就会自动构建project。</p><p>说一下实验环境：<br>Jenkins所在服务器IP：121.41.37.251（10.168.173.181），版本是<code>2.124</code>(查看jenkins的版本语句<code>java -jar /usr/lib/jenkins/jenkins.war --version</code>);<br>Gitlab所在服务器IP：114.55.224.158（10.25.85.175），使用容器安装，版本是<code>10.7.3</code>;</p><h2><span id="jenkins添加gitlab插件">jenkins添加gitlab插件</span></h2><p>通过浏览器登陆jenkins界面，然后在<code>系统管理</code>里面选择<code>管理插件</code>，如图：<br><img src="/images/gitlabjenkins1.png" alt="akb48"></p><p>然后在<code>可选择插件</code>里搜索<code>gitlab hook</code>插件，但是没想到我这个版本提示，目前的1.4.2版本的<code>gitlab hook</code>目前存在安全隐患，如图：<br><img src="/images/gitlabjenkins2.png" alt="akb48"></p><p>具体的安全隐患细节是这样的：<br><img src="/images/gitlabjenkins3.png" alt="akb48"></p><p>这个风险请自己把握，然后我选择了继续安装，如图：<br><img src="/images/gitlabjenkins4.png" alt="akb48"></p><p>安装完了<code>gitlab hook</code>插件后，还要安装<code>GitLab Plugin</code>和<code>Gitlab Authentication plugin</code>这两个插件，方法跟上面的一样。</p><h2><span id="创建测试工程">创建测试工程</span></h2><p>在jenkins上建立一个新的任务，比如叫”jicheng-test”，这是一个<code>自由风格的软件项目</code>：<br><img src="/images/gitlabjenkins6.png" alt="akb48"></p><p>然后在源码管理里面选择git，然后输入gitlab里面仓库的地址，比如我在gitlab上新建了一个仓库叫jenkinstest，那么就复制这个仓库的地址填到jenkins的<code>Repositories</code>里，如图：<br><img src="/images/gitlabjenkins8.png" alt="akb48"></p><p>还要在<code>Credentials</code>这里面写上gitlab的用户和密码，然后保存即可：<br><img src="/images/gitlabjenkins9.png" alt="akb48"></p><h2><span id="配置-gitlab-用户">配置 GitLab 用户</span></h2><p>浏览器切换到gitlab界面，在用户头像点击，<code>User settings</code> —&gt; <code>Access Tokens</code>，这里的<code>Personal Access Tokens</code>写入一个账号，这个账号是用来让Jenkins和GitLab API交互。这个用户将需要是全局的管理员或添加进每个组／工程，并作为成员。需要开发者权限来报告构建状态。如图：<br><img src="/images/gitlabjenkins5.png" alt="akb48"></p><p>输入账号和账号有效时期之后，会生成一个Private token，如图：<br><img src="/images/gitlabjenkins7.png" alt="akb48"></p><p>拷贝它，稍后在配置Jenkins服务器时会用到。</p>]]></content>
    
    <summary type="html">
    
      尚未完成...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="jenkins" scheme="http://yoursite.com/tags/jenkins/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用yum安装软件爆No such file or directory</title>
    <link href="http://yoursite.com/2018/05/17/%E4%BD%BF%E7%94%A8yum%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E7%88%86No-such-file-or-directory/"/>
    <id>http://yoursite.com/2018/05/17/使用yum安装软件爆No-such-file-or-directory/</id>
    <published>2018-05-17T09:25:09.000Z</published>
    <updated>2018-05-17T11:03:29.837Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天开发反馈说<code>yum install redis</code>报错<code>-bash: /usr/bin/yum: /usr/bin/python: bad interpreter: No such file or directory</code>，于是我就登上服务器，使用python一看，反馈<code>-bash: python: command not found</code>，原来这个机器的python被人改动了，用<code>whereis python</code>查了一下，原来python的地址被人改成了<code>/usr/bin/python2.7</code>，于是就手动更改了一下<code>/usr/bin/yum</code>，把<code>#!/usr/bin/python</code>改成了<code>#!/usr/bin/python2.7</code>。但是使用<code>yum install -y redis</code>发现虽然可以连接到库但是会报<code>No such file or directory</code>，如图：<br><img src="/images/nofile.png" alt="paradin"></p><p>原来光改了<code>/usr/bin/yum</code>还没用，还要改<code>/usr/libexec/urlgrabber-ext-down</code>这个文件，同样也是把python改成<code>/usr/bin/python2.7</code>说明python的路径才可以。</p><p>改了上面两个文件之后，又加上了<code>yum clean all</code>和<code>yum makecache</code>，清除一下缓存，一切恢复了正常。</p><p><img src="/images/slamdunk.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      去日本旅游期间，我要电话不接、微信装死...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="yum" scheme="http://yoursite.com/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title>使用zabbix去监控docker容器</title>
    <link href="http://yoursite.com/2018/05/17/%E4%BD%BF%E7%94%A8zabbix%E5%8E%BB%E7%9B%91%E6%8E%A7docker%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/2018/05/17/使用zabbix去监控docker容器/</id>
    <published>2018-05-17T06:06:46.000Z</published>
    <updated>2018-05-17T11:35:27.993Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="前言">前言</span></h2><p>现在容器技术越来越普遍，那么搭建了容器肯定要监控起来，监控方法有两种，一种是做一个zabbix-agent容器去监控容器，还有一个是升级原有的zabbix-agent，这里说第一种。</p><p>这里先交代一下环境：zabbix-server的ip是10.244.48.42，要监控的机器ip是10.244.34.79，这个机器里面装了一个容器在运行gitlab，如图：<br><img src="/images/gitlab20.png" alt="paradin"></p><p>事前检查两台服务器是否互通，而且10050和10051端口是否standby。还要在zabbix-server端做好<code>auto-discovery</code>，等等等等准备工作。</p><h2><span id="使用zabbix-agent-docker进行监控">使用Zabbix Agent Docker进行监控</span></h2><p>在10.244.34.79这个机器上先安装zabbix-agent容器：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name=dockbix \#这个是容器的名称</span><br><span class="line">  --net=host \#容器可以直接访问主机上所有的网络信息</span><br><span class="line">  --privileged \#容器内的root拥有真正的root权限</span><br><span class="line">  -v /:/rootfs \#这个是对应宿主机的映射盘</span><br><span class="line">  -v /var/run:/var/run \</span><br><span class="line">  --restart unless-stopped \ #不管退出状态码是什么始终重启容器，不过当daemon启动时，如果容器之前已经为停止状态，不要尝试启动它。</span><br><span class="line">  -e &quot;ZA_Server=10.244.48.42&quot; \#这里就填写zabbix-server的ip地址</span><br><span class="line">  -e &quot;ZA_ServerActive=10.244.48.42&quot; \</span><br><span class="line">  -d hub.c.163.com/canghai809/dockbix-agent-xxl-limited:latest#这里使用了网易蜂巢镜像</span><br></pre></td></tr></table></figure></p><p>但是反馈给我<code>docker: invalid restart policy unless-stopped.</code>这样的错误信息，原来这个gitlab这台服务器的docker版本较老，而<code>unless-stopped</code>这个是在1.9.0版本才加入的，所以对于旧版的docker环境需要改成<code>always</code>。</p><p>更改docker run的命令之后重新执行效果如下：<br><img src="/images/gitlab21.png" alt="paradin"></p><p>可见容器启动成功，<code>docker logs -f 容器ID号</code>看一下日志是否正常。如果正常的话，应该在zabbix-server端是可以看到这个10.244.34.79已经被添加到控制台里了，如图：<br><img src="/images/gitlab22.png" alt="paradin"></p><h2><span id="导入监控docker的模版">导入监控docker的模版</span></h2><p>在zabbix server上导入监控docker的模版，一共2个模版,下载后解压。模版下载地址: <a href="https://dl.cactifans.com/zabbix/Zabbix-Template-App-Docker.tar.gz" target="_blank" rel="noopener">https://dl.cactifans.com/zabbix/Zabbix-Template-App-Docker.tar.gz</a> 。</p><p>我使用主动模式，因此导入<code>Zabbix-Template-App-Docker-active.xml</code>这个模版，如图：<br><img src="/images/gitlab23.png" alt="paradin"></p><p><img src="/images/gitlab24.png" alt="paradin" title="将这个模板应用到10.244.34.79上"></p><p>此时可以去zabbix-server这个机器上验证一下是否监控成功，在zabbix-server上执行<code>zabbix_get -s 10.244.34.79 -k docker.discovery</code>，效果如下：<br><img src="/images/gitlab25.png" alt="paradin"></p><p>可见已经成功获取到了那两个容器的名称，这就代表zabbix-server已经监控到位了。</p><h2><span id="验证数据">验证数据</span></h2><p>首先现在10.244.34.79里执行<code>docker stats 容器1的ID 容器2的ID...</code>，看一下当前运行的所有容器的状态，如下：<br><img src="/images/gitlab26.png" alt="paradin"></p><p>与zabbix-server的<code>latest data</code>做一下对比，由于被监控机的docker版本较老，<code>docker stats</code>结果不是那么的精准，不过用来监控参考还是OK的…如果docker是最新版的，那么监控值是很准的。<br><img src="/images/gitlab28.png" alt="paradin" title="docker 18.04.0版本的stats跟zabbix获取值一致"></p><p>剩下的就是慢慢添加triggers了…</p><p>补充一句，<code>zabbix-agent 3.2</code>的rpm安装方法：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh http://repo.zabbix.com/zabbix/3.2/rhel/7/x86_64/zabbix-release-3.2-1.el7.noarch.rpm </span><br><span class="line">yum -y install zabbix-agent zabbix-sender</span><br><span class="line">service zabbix-agent start</span><br><span class="line">chkconfig zabbix-agent on</span><br></pre></td></tr></table></figure></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://github.com/monitoringartist/zabbix-docker-monitoring" target="_blank" rel="noopener">https://github.com/monitoringartist/zabbix-docker-monitoring</a> （墙裂推荐！）<br><a href="https://blog.codeship.com/ensuring-containers-are-always-running-with-dockers-restart-policy/" target="_blank" rel="noopener">https://blog.codeship.com/ensuring-containers-are-always-running-with-dockers-restart-policy/</a></p>]]></content>
    
    <summary type="html">
    
      dockbix会直接监控所有的运行容器
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
      <category term="zabbix" scheme="http://yoursite.com/tags/zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab的配置备份</title>
    <link href="http://yoursite.com/2018/05/16/Gitlab%E9%85%8D%E7%BD%AE%E5%A4%87%E4%BB%BD/"/>
    <id>http://yoursite.com/2018/05/16/Gitlab配置备份/</id>
    <published>2018-05-16T07:02:50.000Z</published>
    <updated>2018-05-16T07:51:07.958Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>我这个gitlab是容器安装的，直接使用最新的gitlab镜像，gitlab版本是<code>10.7.3</code>。</p><p>要备份数据的话，就要进入容器里，执行<code>gitlab-rake gitlab:backup:create</code>，效果如下：<br><img src="/images/gitlab19.png" alt="paradin"></p><p>执行完毕之后，在<code>/var/opt/gitlab/backups</code>文件夹里就会生成一个备份文件，我这里生成的文件叫：1526454102_2018_05_16_10.7.3_gitlab_backup.tar，这个就是备份的文件。</p><p>如果要还原的话，命令如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 先关闭连接数据库的进程</span><br><span class="line">sudo gitlab-ctl stop</span><br><span class="line"></span><br><span class="line"># 通过指定时间戳来执行restore操作，这个操作会复写gitlab的数据库</span><br><span class="line">sudo gitlab-rake gitlab:backup:restore BACKUP=1526454102 #BACKUP后面的是备份文件开头的那串数字</span><br><span class="line"></span><br><span class="line"># 再次启动gitlab</span><br><span class="line">sudo gitlab-ctl start</span><br><span class="line"></span><br><span class="line"># 通过下面命令检查gitlab</span><br><span class="line">sudo gitlab-rake gitlab:check SANITIZE=true</span><br></pre></td></tr></table></figure></p><p>注意！利用backup机制进行备份的话，对gitlab的版本是要求严格一致的。例如用8.6版的gitlab生成的备份文件，拿到8.7版的gitlab上进行恢复，是会报错的。</p><p>如果要设置这个备份文件的生命周期和备份文件存储的位置，编辑<code>/etc/gitlab/gitlab.rb</code>，修改如下的地方：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gitlab_rails[&apos;backup_path&apos;] = &quot;/var/opt/gitlab/backups&quot;#这里改新路径</span><br><span class="line">gitlab_rails[&apos;backup_archive_permissions&apos;] = 0644#这里可以设定文件的权限</span><br><span class="line"># limit backup lifetime to 7 days - 604800 seconds</span><br><span class="line">gitlab_rails[&apos;backup_keep_time&apos;] = 604800#文件存储时间一周</span><br></pre></td></tr></table></figure></p><p>然后重启一下gitlab即可。</p>]]></content>
    
    <summary type="html">
    
      不备份，要是数据丢了就死翘翘了...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab的简单应用</title>
    <link href="http://yoursite.com/2018/05/16/Gitlab%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/16/Gitlab的简单实用/</id>
    <published>2018-05-16T01:30:52.000Z</published>
    <updated>2018-05-26T06:49:50.306Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>gitlab跟svn的区别我就不多说了，这里直接说具体应用。</p><h2><span id="建立一个project">建立一个project</span></h2><p>先登陆到gitlab的网页，我这里使用了root用户，选择<code>create a project</code>，然后就是填写project的名称以及它所属的用户，这里由于只有root用户，所以这个叫<code>jjfjj</code>的project就是root自己的，如果建立了一个组的话，那么这里就填写那个组，如下：<br><img src="/images/gitlab14.png" alt="paradin"></p><p>下面这个<code>Visibility Level</code> ，就是权限等级，它分三种：</p><ol><li>Private：私有的，只有你自己或者组内的成员能访问</li><li>Internal：所有登录的用户</li><li>Public：公开的，所有人都可以访问</li></ol><p>这个东西和project的名称都是可以后期更改的。</p><p>然后就是<code>create project</code>，就创建了这个jjfjj。如图:<br><img src="/images/gitlab15.png" alt="paradin"></p><h2><span id="将本地代码上传">将本地代码上传</span></h2><p>建立好了gitlab，就要把开发的代码传进去，我在另外一个机器里，创建一个目录code，这个目录就是专门用来放置代码的，假设现在里面有一个文件叫<code>testcode.py</code>，如图：<br><img src="/images/gitlab16.png" alt="paradin"></p><p>具体操作如下：<br><img src="/images/gitlab17.png" alt="paradin"></p><p>如果在两个不同的文件夹里执行上面的过程，会传输到两个不同的project里。说明一下上面几个命令的意思：<br><code>git init</code>：初始化git仓库<br><code>git add .</code>：添加整个目录里的所有文件到仓库<br><code>git rm --cached 某个文件名</code>：将某个文件从gitlab上撤除，如果想当前文件夹恢复成一个普通的文件夹，那就把文件夹路径下的.git文件删除掉即可<br><code>git commit -m &#39;这里是要写的注释&#39;</code>：提交代码到仓库<br><code>git remote add origin +gitlab的地址(上上图里红色框的内容)</code>：链接到gitlab服务器<br><code>git push origin master</code>：push代码到服务器<br><code>git remote -v</code>：查看当前文件夹的目标project</p><p>此时刷新一下gitlab的project页面，就看到刚刚的那个<code>testcode.py</code>已经传上来了。如图：<br><img src="/images/gitlab18.png" alt="paradin"></p><p>如果代码有所更改或者出现<code>Everything up-to-date</code>，那么就按顺序执行<code>git add .</code>，<code>git commit -m &#39;这里是要写的注释&#39;</code>，<code>git push origin master</code>即可。</p><h2><span id="免密码push代码">免密码push代码</span></h2><p>在上面的<code>git push origin master</code>的时候需要输入gitlab的用户密码，如要需要免密码push，有两种方法。</p><p>第一种方法是ssh，请看 <a href="https://blog.whsir.com/post-1749.html/comment-page-1#comment-3425" target="_blank" rel="noopener">https://blog.whsir.com/post-1749.html/comment-page-1#comment-3425</a> 。</p><p>第二种方法还是用http的方式传送，但是将密码写进配置文件里：<br>执行<code>git config --global credential.helper store</code>，然后<code>cat ~/.gitconfig</code>，就会看到如下结果：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">email = chen_shuo@dahuatech.com</span><br><span class="line">name = root</span><br><span class="line">[credential]</span><br><span class="line">helper = store</span><br></pre></td></tr></table></figure></p><p>重新去执行<code>git add .</code>，<code>git commit -m &#39;这里是要写的注释&#39;</code>，<code>git push origin master</code>，就不再需要输入密码了。</p><h2><span id="从gitlab上垃取代码">从gitlab上垃取代码</span></h2><p>在要部署的机器上找到要部署的文件夹，我这里用/gitlab为例，操作如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pass-mixnumbus-001 /GITLAB] # git init        #将这个文件夹进行初始化                                             </span><br><span class="line">Initialized empty Git repository in /GITLAB/.git/#提示现在已经安装了.git文件</span><br><span class="line">[root@pass-mixnumbus-001 /GITLAB(master)] # git remote add origin http://114.55.224.158/root/JJFJJ.git#确定库</span><br><span class="line">[root@pass-mixnumbus-001 /GITLAB(master)] # git pull origin master #制定要把master分支的代码全拉取到这个文件夹里</span><br><span class="line">Username for 'http://114.55.224.158': root#输入账号和密码</span><br><span class="line">Password <span class="keyword">for</span> <span class="string">'http://root@114.55.224.158'</span>: </span><br><span class="line">From http:<span class="comment">//114.55.224.158/root/JJFJJ</span></span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">[root@pass-mixnumbus-001 /GITLAB(master)] # ls#看一下效果</span><br><span class="line">admin.py  looksql.py  models.py  syncECS.py  testsyncECS.py</span><br></pre></td></tr></table></figure></p><p>再与gitlab界面的代码比较一下，果然都过来了！如图：<br><img src="/images/gitlab30.png" alt="paradin"></p><h2><span id="在gitlab上建立分支">在gitlab上建立分支</span></h2><p>gitlab上有很多个分支，主要的分支是master，它也是默认的分支，但是实际工作中是需要其他的开发去新建一些测试的分支，到时候可以先把这些测试的分支拿来部署，如果有问题就回滚回master分支。</p><p>分支相关的语句如下：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git branch#查看本地分支</span><br><span class="line">git branch -r#查看远程分支</span><br><span class="line">git branch -a #查看所有分支</span><br><span class="line">git branch develop#本地创建新的分支，此时刷新gitlab的页面的话就会有这个叫develop的分支建立了</span><br><span class="line">git checkout develop#切换到新的develop分支</span><br><span class="line">git checkout -b develop#上面两步可以合成一个命令，这个的意思就是：创建+切换分支</span><br></pre></td></tr></table></figure></p><p>这个时候在代码机上新增或者改变文件，然后执行<code>git add .</code>，<code>git commit -m &#39;这里是要写的注释&#39;</code>，<code>git push origin develop</code>，就把新增的变化上传到了develop分支，如图：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23pg8sy5bZ ~<span class="regexp">/GITLAB(develop)] # git push origin develop</span></span><br><span class="line"><span class="regexp">Counting objects: 4, done.</span></span><br><span class="line"><span class="regexp">Compressing objects: 100% (2/</span><span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">325</span> bytes | <span class="number">0</span> bytes/s, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">1</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: </span><br><span class="line">remote: To create a merge request <span class="keyword">for</span> develop, <span class="attr">visit</span>:</span><br><span class="line">remote:   http:<span class="comment">//114.55.224.158/root/JJFJJ/merge_requests/new?merge_request%5Bsource_branch%5D=develop</span></span><br><span class="line">remote: </span><br><span class="line">To http:<span class="comment">//114.55.224.158/root/JJFJJ.git</span></span><br><span class="line">   fc8d456.<span class="number">.8</span>a97b58  develop -&gt; develop</span><br></pre></td></tr></table></figure></p><p>而在部署的机器上，直接执行<code>git pull origin develop</code>，输入账号密码之后，就会把develop分支的内容全部垃取下来了。</p><p>如果不想要这个develop分支了，就<code>git branch -d develop</code>，如果要删除远程的分支，就是<code>git push origin :develop</code>，注意这个冒号。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.cnbluebox.com/blog/2014/04/15/gitlabde-shi-yong/" target="_blank" rel="noopener">https://blog.cnbluebox.com/blog/2014/04/15/gitlabde-shi-yong/</a><br><a href="https://zhang759740844.github.io/2016/08/27/git%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">https://zhang759740844.github.io/2016/08/27/git%E6%8A%80%E5%B7%A7/</a><br><a href="https://www.restran.net/2016/02/23/git-and-gitlab-guide/" target="_blank" rel="noopener">https://www.restran.net/2016/02/23/git-and-gitlab-guide/</a><br><a href="https://www.jianshu.com/p/f54053afecf2" target="_blank" rel="noopener">https://www.jianshu.com/p/f54053afecf2</a></p>]]></content>
    
    <summary type="html">
    
      docker + gitlab，这才是未来部署的方向
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>Gitlab的汉化过程</title>
    <link href="http://yoursite.com/2018/05/15/Gitlab%E7%9A%84%E6%B1%89%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/15/Gitlab的汉化过程/</id>
    <published>2018-05-15T02:17:51.000Z</published>
    <updated>2018-05-15T12:29:16.804Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="gitlab的容器安装方法">gitlab的容器安装方法</span></h2><p>部署前的第一句话，gitlab是不支持32位系统的！</p><p>gitlab用容器部署的话非常的简单，首先<code>docker pull gitlab/gitlab-ce:latest</code>下载镜像，然后<code>docker run --detach --hostname 本机外网IP --publish 443:443 --publish 80:80 --publish 2222:22 --name gitlab --restart always gitlab/gitlab-ce:latest</code>建立一个容器，如图：<br><img src="/images/gitlab10.png" alt="paradin"></p><p>然后在浏览器的地址栏里输入服务器的外网IP地址，就到了一个更换密码的页面，这个密码就是root的密码，如图：<br><img src="/images/gitlab13.png" alt="paradin"></p><p>设定密码之后，就可以通过root账号登陆gitlab了，如图：<br><img src="/images/gitlab11.png" alt="paradin"></p><p>至于“使用ldsp方式登录”、“配置域名”和“关闭注册功能”请移步去看：<a href="https://rorschachchan.github.io/2018/05/10/在已经运行的docker容器里面使用中文/" target="_blank" rel="noopener">https://rorschachchan.github.io/2018/05/10/在已经运行的docker容器里面使用中文/</a> 。</p><h2><span id="gitlab的汉化方法">gitlab的汉化方法</span></h2><p>汉化之前，要确定gitlab的版本，先<code>docker exec -it 容器ID env LANG=C.UTF-8 /bin/bash</code>登陆到容器里，执行<code>cat /opt/gitlab/embedded/service/gitlab-rails/VERSION</code>，由于当时镜像是最新的，所以gitlab的版本是<code>10.7.3</code>。</p><p>还是在容器里，执行<code>git clone https://gitlab.com/xhang/gitlab.git</code>，克隆获取汉化版本库(这里要感谢辛苦的汉化工作者，向你们致敬！)，默认是获取最新的。如果需要下载老版本的汉化包，则要加上老版本的分支，如：<code>git clone https://gitlab.com/xhang/gitlab.git -b v10.2.5-zh</code>。</p><p>然后<code>gitlab-ctl stop</code>先停止gitlab服务，<code>cd gitlab/</code>进入到刚刚下载的那个git包里，执行如下代码：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@10 gitlab]# git fetch</span><br><span class="line">root@10 gitlab]# git diff v10.7.3 v10.7.3-zh &gt; ../10.7.3-zh.diff</span><br><span class="line">root@10 gitlab]# cd ..</span><br><span class="line">root@10 ~]# patch -d /opt/gitlab/embedded/service/gitlab-rails -p1 &lt; 10.7.3-zh.diff</span><br><span class="line">root@10 ~]# #如果提示没有patch，请执行apt-get update &amp;&amp; apt-get install patch</span><br><span class="line">root@10 ~]# gitlab-ctl start</span><br></pre></td></tr></table></figure></p><p>重新返回到浏览器里，就能看到汉化后的gitlab了，大功告成！<br><img src="/images/gitlab12.png" alt="paradin"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://xuanwo.org/2016/04/13/gitlab-install-intro/" target="_blank" rel="noopener">https://xuanwo.org/2016/04/13/gitlab-install-intro/</a><br><a href="https://www.jianshu.com/p/6606aed59a56" target="_blank" rel="noopener">https://www.jianshu.com/p/6606aed59a56</a><br><a href="http://adairjun.github.io/2016/12/20/gitlab/" target="_blank" rel="noopener">http://adairjun.github.io/2016/12/20/gitlab/</a><br><a href="https://github.com/marbleqi/gitlab-ce-zh/blob/v10.5.1-zh-patch/Nginx.md" target="_blank" rel="noopener">https://github.com/marbleqi/gitlab-ce-zh/blob/v10.5.1-zh-patch/Nginx.md</a><br><img src="/images/kdshotharden.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      为了考虑众多用户尤其是各位领导的英文水平...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="gitlab" scheme="http://yoursite.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>浅析django里models.py、views.py与网页之间的爱恨纠葛</title>
    <link href="http://yoursite.com/2018/05/14/%E6%B5%85%E6%9E%90django%E9%87%8Cmodels-py%E3%80%81views-py%E3%80%81page%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BA%A0%E8%91%9B/"/>
    <id>http://yoursite.com/2018/05/14/浅析django里models-py、views-py、page之间的纠葛/</id>
    <published>2018-05-14T14:04:16.000Z</published>
    <updated>2018-05-15T02:53:10.183Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>环境：<code>django 2.0</code> + <code>python 3.6</code> + <code>pycharm 2018</code>  </p><p>django建立一个app之后就会有<code>models.py</code>、<code>views.py</code>、<code>admin.py</code>这几个文件，他们三个分别的用途如下： </p><ol><li><code>models.py</code>主要是用来设置数据在数据库的存储格式（比如默认值，字段类型和字段长度等等）; </li><li><code>admin.py</code>是用来设置在/admin/后台里面的显示样式; </li><li><code>views.py</code>是用来设置在前台网页里的显示样式； </li><li><code>urls.py</code>是用来编辑域名规则；</li></ol><p><code>admin.py</code>是后台配置的文件，所以对前台网页来说，它不重要，而真正与前端网页相关的就是三个部分：<code>models.py</code>、<code>views.py</code>和对应的网页。  </p><p>举个例子，假设有一个<code>models.py</code>，内容如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.db import models     </span><br><span class="line">from django.contrib.auth.models import User   </span><br><span class="line">   </span><br><span class="line">class BlogType(models.Model):         </span><br><span class="line">type_name = models.CharField(max_length=15)    #规定type_name是一个最大为15字节的charfield          </span><br><span class="line">def __str__(self):             </span><br><span class="line">return &apos;&lt;BlogType:%s&gt;&apos; % self.type_name</span><br></pre></td></tr></table></figure></p><p>然后随便加入一些内容，如图：<br><img src="/images/type_name1.png" alt="paradin">   </p><p>而在<code>views.py</code>里，要求在前端网页里如此的显示：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.shortcuts import render_to_response,get_object_or_404     </span><br><span class="line">from .models import Blog,BlogType    #这里引用了models.py里的那两个class </span><br><span class="line">    </span><br><span class="line">def blog_list(request):         </span><br><span class="line">context = &#123;&#125;         </span><br><span class="line">context[&apos;blog_types&apos;] = BlogType.objects.all()         </span><br><span class="line">return render_to_response(&apos;pageblog/blog_list.html&apos;,context)</span><br></pre></td></tr></table></figure></p><p>在<code>views.py</code>里规定，如果有访问域名是<code>/blog_list/</code>的网页，就返回<code>pageblog/blog_list.html</code>这个页面，而这个<code>blog_list.html</code>只是一个框架，里面的内容是<code>context</code>。<code>context</code>本身是一个字典，里面的里面的key对应的value是用ojbects这个函数获得的，<code>objects.all()</code>就是获取全部的意思。用来填充blog_list.html的context里面有blogs和blog_types两个key。</p><p>那么现在就可以在<code>blog_list.html</code>里使用<code>blog_types</code>这个key了，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 前面略 --&gt;     </span><br><span class="line">&lt;h4&gt;博客分类&lt;/h4&gt;     </span><br><span class="line">&lt;h3&gt; &#123;&#123; blog_types&#125;&#125; &lt;/h3&gt;     </span><br><span class="line">&lt;!-- 后面略 --&gt;</span><br></pre></td></tr></table></figure></p><p>这样的效果如下：<br><img src="/images/type_name2.png" alt="paradin">  </p><p>返回的是<code>QuerySet</code>类型，<code>QuerySet</code>是Django的查询集，可以通过<code>QuerySet</code>条件查询得到对应模型的对象集合。由此看出<code>blog_types</code>已经成功的引入到了<code>blog_list.html</code>里。</p><p>至于拆成每一个“博客类型”就很简单了，html部分如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;h4&gt;博客分类&lt;/h4&gt;                 </span><br><span class="line">&lt;!-- ul是无项目的标签 --&gt;                 </span><br><span class="line">&lt;ul&gt;                     </span><br><span class="line">&#123;% for blog_type in blog_types%&#125;    #开始一个for循环                         </span><br><span class="line">&lt;li&gt;&lt;a href=&quot;&#123;% url &apos;blogs_with_type&apos; blog_type.pk %&#125;&quot;&gt;&#123;&#123; blog_type.type_name &#125;&#125; &lt;/a&gt;&lt;/li&gt;        #对每一个类型加上一个a链接                     </span><br><span class="line">&#123;% empty %&#125;        #如果唯空就说“暂无分类”                         </span><br><span class="line">&lt;!--  li是具体的项目 --&gt;                         </span><br><span class="line">&lt;li&gt; 暂无分类 &lt;/li&gt;                     </span><br><span class="line">&#123;% endfor %&#125;                     </span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      搞明白这个，就算明白django之间几个核心文件的关系了。
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
  </entry>
  
  <entry>
    <title>加载css样式的两个方法</title>
    <link href="http://yoursite.com/2018/05/12/%E5%8A%A0%E8%BD%BDcss%E6%A0%B7%E5%BC%8F%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/12/加载css样式的两个方法/</id>
    <published>2018-05-12T07:27:19.000Z</published>
    <updated>2018-05-15T03:36:24.864Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="背景说明">背景说明</span></h2><p>环境： <code>django 2.0</code>+<code>python 3.6</code>+<code>pycharm 2018</code><br>project名称: <code>blog</code></p><h2><span id="普通的网页加载css">普通的网页加载css</span></h2><p>网页使用了css才会更好看更炫酷，一般情况下的网页是这样的：<br><img src="/images/css0.png" alt="akb48"></p><p>上面这个html文件里用到了模板，而且又对div和 a标签做了class定义，最后分别对各自的class进行了css说明。整个文档看下来比较直观。</p><p>但是这样就会有一个问题，就是把html内容和css内容写到了一起，一般来说为了后期维护，都会把css单独写到一个文件夹里，然后让这个html来引用这个css文件夹的具体某个css文件。</p><p>于是，我们就在<code>blog</code>这个project目录下建立一个叫static的文件夹，用它来专门装<code>css\js</code>这样的静态文件。</p><p>首先，建立了这个static文件，肯定就涉及到引用的问题，而如何让django可以识别static呢？</p><p>打开<code>blog/settings.py</code>这个文件，这个文件是整个project的配置文件，在文件末尾加上这样的话，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将项目根目录里的static制定成项目的静态文件夹,这样django就可以识别</span><br><span class="line">#注意，static前面没有&apos;/&apos;</span><br><span class="line">STATICFILES_DIRS = [os.path.join(BASE_DIR, &apos;static&apos;),]</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>这样blog这个根目录就可以识别了<code>static</code>文件夹了。</p><p>然后在pycharm里新建一个css文件叫<code>base.css</code>，如果是专业版的pycharm是可以直接建立css类型文件的，免费社区版是没有这个功能。再将原文里面的所有关于css的内容拷贝到这个<code>base.css</code>里，如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">margin: 5px;</span><br><span class="line">padding: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav &#123;</span><br><span class="line">background-color: gold;</span><br><span class="line">border-bottom: 2px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav a&#123;</span><br><span class="line">text-decoration:none;</span><br><span class="line">color: blue;</span><br><span class="line">padding: 5px 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div.nav a.logo&#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">font-size: 120%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>保存之后，为了验证django是否成功的识别此文件，可以在浏览器里输入<code>外网IP：端口号/static/base.css</code>查看是否返回就是上面内容，如果是就代表识别成功，如果是404就要重新检查<code>settings.py</code>了。</p><p>在原有的html里删除掉<code>&lt;style&gt;</code>标签内css内容，还要在head里添加一句话：<code>&lt;link  rel=&quot;stylesheet&quot; href=&quot;/static/base.css&quot;&gt;</code>,如下：<br><img src="/images/css1.png" alt="akb48"></p><p>这样就达到了引用css所在的static文件夹的目的。</p><h2><span id="django内部的加载css方法">Django内部的加载css方法</span></h2><p>上面说的是普通html加载css的方法，而django内部也有自己的一套方法，再次打开settings.py里看到有如下的内容：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [   </span><br><span class="line"> <span class="string">'django.contrib.admin'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.auth'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.contenttypes'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.sessions'</span>,   </span><br><span class="line"> <span class="string">'django.contrib.messages'</span>,    </span><br><span class="line"> <span class="string">'django.contrib.staticfiles'</span>,   </span><br><span class="line"> <span class="string">'blog'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>上面的<code>django.contrib.staticfiles</code>就是django的css加载方法，使用这个方法也很简单。</p><p>首先要在html文件最上面先声明要调用这个方法:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load staticfiles %&#125;</span><br><span class="line">&#123;# 这个staticfiles是django自带的，可以在settings文件里看到 #&#125;</span><br></pre></td></tr></table></figure></p><p>然后把link标签改成如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link  rel=&quot;stylesheet&quot; href=&quot;&#123;% static &apos;base.css&apos; %&#125;&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>保存文件刷新即可，而且用了这种方法，在chrome浏览器里F12 查看，会解析成普通模式的方法，如图：<br><img src="/images/css2.png" alt="akb48"></p><font color="red">在django项目里，还是更推荐用django的方法。</font><h2><span id="额外补充">额外补充</span></h2><p>如果html文件开头声明引用了某个模板，比如：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% extends &apos;base.html&apos; %&#125;#声明引用了base.html这个模板</span><br><span class="line">&#123;% load staticfiles %&#125;</span><br></pre></td></tr></table></figure></p><p>那么<code>extends</code>语句必须在最上面，不然就会报错：<code>TemplateSyntaxError at /&lt;ExtendsNode: extends &#39;base.html&#39;&gt; must be the first tag in the template.</code></p>]]></content>
    
    <summary type="html">
    
      如果html里没有header这个标签，就需要在模板文件里面新加一个块，在块里声明css的地址
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
      <category term="前端技术" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>创建Mysql容器过程</title>
    <link href="http://yoursite.com/2018/05/12/%E5%88%9B%E5%BB%BAMysql%E5%AE%B9%E5%99%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/12/创建Mysql容器过程/</id>
    <published>2018-05-12T02:28:46.000Z</published>
    <updated>2018-05-15T03:28:57.952Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="过程记录">过程记录</span></h2><p>先<code>docker pull mysql</code>，当前最近的版本是8.0，然后<code>docker images</code>查看一下效果。</p><p>然后就是启动一个容器，命令是：<code>docker run --name test-mysql -p 3306:3306 -e MYSQL\_ROOT\_PASSWORD=123456 -d mysql</code>,这句话的意思是：启动一个叫test-mysql的容器， 端口影射是3306到宿主机的3306，同时设置root的密码是123456，然后以守护进程的形式启动。</p><p>但是如果在宿主机上使用<code>mysql -h127.0.0.1 -uroot -p123456</code>可能会报错，报错内容是：<code>Authentication plugin ‘caching_sha2_password’ cannot be loaded:</code></p><p>那么就<code>docker exec -it 容器ID号 env LANG=C.UTF-8 /bin/bash</code>进入到容器里，使用<code>mysql -uroot -p123456</code>，看一下在容器里是否可以正常登录，如果可以的话，那么就在mysql的命令行里执行<code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;</code>。  </p><p>退出容器在宿主机上重新连接，这样就OK了。至于原因就是，mysql的客户端是yum安装的，虽然是centos 7，但是安装的版本也是5.5版本的，所以8.0的客户端有一个新的密码加密方式：<code>caching_sha2_password</code>，客户端不支持，所以需要手动到命令行里更改一下。</p><h2><span id="mysql存储的坑">mysql存储的坑</span></h2><p>先思考一个问题：假如某mysql容器里存储了100G的数据，那么这个容器关闭了，这100G的数据还在么？从宿主机是可以找到这100G的数据么？</p><p><code>docker inspect mysql-container-id</code>，找到里面的volume字段，这里也显示挂载的host路径，可以通过这个路径来备份数据。或者使用<code>docker cp mysql-container-id:/path/to/db-backup-file ./</code>，把容器内数据放到当前目录下。如果是生产环境，必须使用Volume或数据容器。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="http://binary-space.iteye.com/blog/2412769" target="_blank" rel="noopener">http://binary-space.iteye.com/blog/2412769</a><br><a href="http://dockone.io/question/108" target="_blank" rel="noopener">http://dockone.io/question/108</a><br><img src="/images/rondopass1.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      据说mysql的容器坑很多...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="docker容器" scheme="http://yoursite.com/tags/docker%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>python报错：importError: No module named bz2</title>
    <link href="http://yoursite.com/2018/05/12/python%E6%8A%A5%E9%94%99%EF%BC%9A&#39;importError-No-module-named-bz2&#39;/"/>
    <id>http://yoursite.com/2018/05/12/python报错：&#39;importError-No-module-named-bz2&#39;/</id>
    <published>2018-05-12T02:08:07.000Z</published>
    <updated>2018-05-12T04:19:32.054Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>每日统计阿里云同步延迟的邮件早就编写完毕了，现在要放到专门跑脚本的服务器里，进去到这个服务器里发现这个机器已经被人装了两个python，分别是python 2.7.5（默认路径）和python 2.7.13（路径是<code>/usr/local/python/bin/python</code>），说实话我个人不太明白这么做的原因何在。</p><p>但是既然已经被人搞成这样了，那就适应环境吧，把脚本拷贝过来，把依赖库都安装好，但是在执行<code>matplotlib</code>的库的时候，爆了一个错误：<code>ImportError: No module named bz2</code>。</p><p>这就是因为两个python，但是启动的那个python文件夹里面是没有<code>bz2.so</code>这个文件的，于是就需要把系统里默认的2.7.5的<code>bz2.so</code>拷贝到2.7.13的lib路径里。</p><p>首先<code>find / -name bz2.so</code>找一下文件，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@dvl-stun-002 GETDTS]# find / -name bz2.so</span><br><span class="line">/usr/local/aegis/PythonLoader/lib/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br><span class="line">/usr/local/aegis/SecureCheck/lib/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br><span class="line">/usr/lib64/python2<span class="number">.7</span>/lib-dynload/bz2.so</span><br></pre></td></tr></table></figure></p><p>然后<code>cd /usr/local/python/lib/python2.7/</code>，把<code>/usr/lib64/python2.7/lib-dynload/bz2.so</code>复制到这个文件夹里即可。<br><img src="/images/rubio3kill.gif" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      双python的蛋疼...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>在已经运行的docker容器里面使用中文</title>
    <link href="http://yoursite.com/2018/05/10/%E5%9C%A8%E5%B7%B2%E7%BB%8F%E8%BF%90%E8%A1%8C%E7%9A%84docker%E5%AE%B9%E5%99%A8%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87/"/>
    <id>http://yoursite.com/2018/05/10/在已经运行的docker容器里面使用中文/</id>
    <published>2018-05-10T14:52:57.000Z</published>
    <updated>2018-05-14T14:27:43.370Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="配置ldap">配置ldap</span></h2><p>公司搭建的gitlab现在需要开启ldap服务，也就是这样就可以用公司的域账号登陆gitlab，而不用开发一个一个去注册账号了。</p><p>开启ldap登陆的任务光荣了落到了我的身上，于是我就登陆到gitlab服务器一看，嚯，这还是在容器下启动的，如图：<br><img src="/images/gitlab2.png" alt="paradin"></p><p>于是我就<code>docker exec -it 容器ID号 /bin/bash</code>登陆到这个容器里，编辑<code>/opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml</code>，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ldap:    </span><br><span class="line">  enabled: <span class="literal">true</span></span><br><span class="line">  sync_time:</span><br><span class="line">  host: <span class="string">'公司域账号服务器IP地址'</span></span><br><span class="line">  port: <span class="number">389</span></span><br><span class="line">  uid: <span class="string">'sAMAccountName'</span></span><br><span class="line">  method: 'plain' # "tls" or "ssl" or "plain"</span><br><span class="line">  bind_dn: <span class="string">'dahuatech\Ldap_System'</span></span><br><span class="line">  password: <span class="string">'对应的密码'</span></span><br><span class="line">  active_directory:</span><br><span class="line">  allow_username_or_email_login:    </span><br><span class="line">  lowercase_usernames:</span><br><span class="line">  base: </span><br><span class="line">  user_filter:</span><br></pre></td></tr></table></figure></p><p>但是在填写到base的时候发现了一个问题，公司的base是中文的，是<code>&#39;OU=大数据研究院,OU=研发中心,OU=大华技术,DC=dahuatech,DC=com&#39;</code>，但是在文件里输入中文却是乱码，如图：<br><img src="/images/gitlab3.png" alt="paradin"></p><p>容器默认是不支持中文的，在容器里的命令行输入中文也是空白。那么面对一个已经运行的容器，如何正常的输入中文呢？</p><p>答案是：使用<code>docker exec -it 容器ID号 env LANG=C.UTF-8 /bin/bash</code>登陆，这样就能正常使用中文了，如图：<br><img src="/images/gitlab1.png" alt="paradin"></p><p><code>gitlab-ctl restart</code>之后，登陆到gitlab页面一看，已经添加ldap访问方式：<br><img src="/images/gitlab4.png" alt="paradin"></p><h2><span id="取消注册功能">取消“注册”功能</span></h2><p>修改好配置文件<code>gitlab.yml</code>之后，现在就要把“注册”功能去掉，这样以后都统一用公司的域账号登陆，避免一些乱七八糟的用户来注册乱七八糟的账号。</p><p>首先用root账号登陆到<code>gitlab</code>里，在网页里进入到<code>admin area</code>，如图：<br><img src="/images/gitlab8.png" alt="paradin"></p><p>然后再点击最下面的<code>settings</code>，选择<code>Sign-up restrictions</code>，然后把<code>Sign-up enabled</code>前面的勾点掉，如图：<br><img src="/images/gitlab9.png" alt="paradin"></p><p>保存改变之后，退出root账号，重新看一下，gitlab的注册功能就暂时被取消了，需要的时候再开即可。</p><h2><span id="配置域名">配置域名</span></h2><p>为了方便记忆，给gitlab服务配置一个域名，在阿里云的域名解析控制台给gitlab配置了域名之后，还要在<code>gitlab.yml</code>手动更改hostanme，把hostname改成域名的样子，如图：<br><img src="/images/gitlab5.jpg" alt="paradin"></p><p>这样没有结束，因为网页里的url还是显示外网IP而非域名,如下：<br><img src="/images/gitlab7.png" alt="paradin"></p><p>此时需要重启，重启的命令是<code>gitlab-ctl restart</code>，重启完了之后url也会发生变化。这样才算完整的配置了域名：<br><img src="/images/gitlab6.jpg" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      如果要是dockerfile里都直接使用中文就更好了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>通过阿里云服务器ID添加服务器资料到django的脚本</title>
    <link href="http://yoursite.com/2018/05/07/%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8ID%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%96%99%E5%88%B0django%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>http://yoursite.com/2018/05/07/通过阿里云服务器ID添加服务器资料到django的脚本/</id>
    <published>2018-05-07T13:48:29.000Z</published>
    <updated>2018-05-12T06:13:54.179Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>本文的环境是：<code>centos 7</code> + <code>django 2.0</code> + <code>python 3.6</code></p><p>先给django里的project创建了<code>models.py</code>，里面内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line">class ecs(models.Model):</span><br><span class="line">    name = models.CharField(verbose_name=<span class="string">'云服务器名称'</span>,max_length=<span class="number">30</span>)</span><br><span class="line">    ecsid = models.CharField(verbose_name=<span class="string">'云服务器ID'</span>,max_length=<span class="number">30</span>,<span class="keyword">default</span>=<span class="string">''</span>)</span><br><span class="line">    inIP = models.GenericIPAddressField(verbose_name=<span class="string">'云服务器内网地址'</span>)</span><br><span class="line">    outIP = models.GenericIPAddressField(verbose_name=<span class="string">'云服务器外网地址'</span>)</span><br><span class="line">    osname = models.CharField(verbose_name=<span class="string">'操作系统'</span>,max_length=<span class="number">50</span>,<span class="keyword">default</span>=<span class="string">''</span>)</span><br><span class="line">    networktype = models.CharField(verbose_name=<span class="string">'网络类型'</span>,max_length=<span class="number">20</span>)</span><br><span class="line">    CPU = models.IntegerField(verbose_name=<span class="string">'云服务器CPU'</span>,<span class="keyword">default</span>=<span class="string">'2'</span>)</span><br><span class="line">    memory = models.IntegerField(verbose_name=<span class="string">'云服务器内存'</span>,<span class="keyword">default</span>=<span class="string">'2048'</span>)</span><br><span class="line">    netwidth = models.IntegerField(verbose_name=<span class="string">'云服务器外网带宽'</span>,<span class="keyword">default</span>=<span class="string">'0M'</span>)</span><br><span class="line">    signtime = models.DateField(auto_now_add=True)</span><br><span class="line">    remark = models.CharField(verbose_name=<span class="string">'备注'</span>,max_length=<span class="number">255</span>,blank=True)</span><br></pre></td></tr></table></figure></p><p>可以看出这个就是一个很简单的云服务器的配置统计，但是要录入的阿里云服务器很多，一个一个手动输入实在太累，于是就要写一个脚本来达到django同步的效果！</p><p>脚本内容如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python</span></span><br><span class="line">#coding=utf-8</span><br><span class="line">#这个脚本通过查询阿里云服务器ID来达到同步django的目的</span><br><span class="line"><span class="keyword">import</span> json,pymysql</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore <span class="keyword">import</span> client</span><br><span class="line"><span class="keyword">from</span> aliyunsdkecs.request.v20140526 <span class="keyword">import</span> DescribeInstancesRequest</span><br><span class="line"></span><br><span class="line">clt = client.AcsClient(<span class="string">'这里是ak'</span>,<span class="string">'这里是sk'</span>,<span class="string">'这里是地域名'</span>)</span><br><span class="line"></span><br><span class="line"># 设置参数</span><br><span class="line">request = DescribeInstancesRequest.DescribeInstancesRequest()</span><br><span class="line">request.set_accept_format(<span class="string">'json'</span>)</span><br><span class="line"></span><br><span class="line">request.add_query_param(<span class="string">'RegionId'</span>, <span class="string">'cn-hangzhou'</span>)</span><br><span class="line">request.add_query_param('InstanceIds', ['这里是服务器ID'])#如果是多个服务器ID，可以继续往下写</span><br><span class="line"></span><br><span class="line"># 发起请求</span><br><span class="line">response = clt.do_action(request)</span><br><span class="line"></span><br><span class="line">#print(response)#这里可以看一下返回的response，但是它是byte格式的</span><br><span class="line">data=str(response, encoding = <span class="string">"utf-8"</span>)</span><br><span class="line">ecs = json.loads(data)#转换成str格式</span><br><span class="line">name = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceName'</span>])</span><br><span class="line">ecsid = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceId'</span>])</span><br><span class="line">inIP = str(ecs['Instances']['Instance'][0]['VpcAttributes']['PrivateIpAddress']['IpAddress'])[1:-1]#如果不加[1:-1]的话，得到的是一个IP外面还有中括号</span><br><span class="line">outIP = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'PublicIpAddress'</span>][<span class="string">'IpAddress'</span>])[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line">networktype = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'InstanceNetworkType'</span>])</span><br><span class="line">CPU = int(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'Cpu'</span>])</span><br><span class="line">memory = int(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'Memory'</span>])</span><br><span class="line">osname = str(ecs[<span class="string">'Instances'</span>][<span class="string">'Instance'</span>][<span class="number">0</span>][<span class="string">'OSName'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#创建数据库连接，注意这里我加入了charset和cursorclass参数</span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host = <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    user = <span class="string">"数据库账号"</span>,</span><br><span class="line">    password = <span class="string">"数据库密码"</span>,</span><br><span class="line">    database = <span class="string">"数据库名称"</span>,</span><br><span class="line">    charset = <span class="string">'utf8'</span>,</span><br><span class="line">    cursorclass = pymysql.cursors.DictCursor)</span><br><span class="line">#获取游标</span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line">#三个引号里如何加入变量</span><br><span class="line">sql = <span class="string">""</span><span class="string">"INSERT INTO ecs_ecs (name,ecsid,inIP,outIP,networktype,CPU,memory,netwidth,signtime,osname) VALUES (%(name)s,%(ecsid)s,%(inIP)s,%(outIP)s,%(networktype)s,%(CPU)d,%(memory)d,%(netwidth)d,NOW(),%(osname)s);"</span><span class="string">""</span> % dict(name=<span class="string">'\''</span>+name+<span class="string">'\''</span>,ecsid= <span class="string">'\''</span>+ecsid+<span class="string">'\''</span>,inIP=inIP,outIP=outIP,networktype=<span class="string">'\''</span>+networktype+<span class="string">'\''</span>,CPU=CPU,memory=memory,netwidth=<span class="number">1</span>,osname=<span class="string">'\''</span>+osname+<span class="string">'\''</span>)</span><br><span class="line"></span><br><span class="line">#print (sql)#在这里可以先看看sql输出的是否正确</span><br><span class="line">cursor.execute(sql)</span><br><span class="line"></span><br><span class="line"># 关闭数据库连接</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure></p><p>正常来说应该是先建立一个def来获取阿里云服务器配置，再来一个def来将各配置录入到数据库里，同时让阿里云服务器的id作为变量，而且还要加上如果sql执行失败就回滚的语句。而我由于是临时使用，所以这个脚本按照流水式写下来的，不过不影响阅读。</p><p>ps.进化之后的脚本在我的github里，地址是： <a href="https://github.com/RorschachChan/chenWORK/blob/master/通过阿里云ID号将服务器信息同步到django.py" target="_blank" rel="noopener">https://github.com/RorschachChan/chenWORK/blob/master/通过阿里云ID号将服务器信息同步到django.py</a></p><p>比如现在要添加一个服务器，这个服务器的id是：<code>i-bp12ego6x9srzsytxeqo</code>，如图：<br><img src="/images/django3.png" alt="akb48"></p><p>那么对应填写好脚本里的ak/sk之后，就把<code>i-bp12ego6x9srzsytxeqo</code>填写到“服务器ID”的位置 ，执行这个脚本，结果如下：<br><img src="/images/django5.png" alt="akb48"></p><p>不过这个脚本有两个缺点：<br>第一：如果阿里云服务器是中文名称，那么使用api查询出现的是十六进制的符号；<br>第二：如果服务器里没有外网IP或者是后开的临时带宽，那么在outIP的地方得到的值是空，sql语句会因为少一项而报错；<br>第三：这个api没有查询服务器带宽值的功能，还需要另外写一个脚本搭配。</p>]]></content>
    
    <summary type="html">
    
      最近我又把django捡起来了
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="python3" scheme="http://yoursite.com/tags/python3/"/>
    
      <category term="django2" scheme="http://yoursite.com/tags/django2/"/>
    
  </entry>
  
  <entry>
    <title>记一次nginx负载均衡配置问题</title>
    <link href="http://yoursite.com/2018/04/28/%E8%AE%B0%E4%B8%80%E6%AC%A1nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/28/记一次nginx负载均衡配置问题/</id>
    <published>2018-04-28T13:48:40.000Z</published>
    <updated>2018-04-28T14:00:42.648Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="故障背景">故障背景</span></h2><p>公司有三个实体服务器，内网IP分别是<code>10.1.82.83</code>、<code>10.1.82.84</code>、<code>10.1.82.113</code>，这三个作为源站使用专线连接到了阿里云的一台nginx服务器上，并且通过这个nginx做负载均衡展示这三个服务器里面的网页。负载均衡使用的是<code>nginx 1.12</code>版本，最外面在上一个CDN起到静态页面加速的作用。整个架构如图：<br><img src="/images/aliCDN2.png" alt="paradin"></p><p>CDN的配置界面如下：<br><img src="/images/aliCDN6.png" alt="paradin"></p><p>但是现在很奇怪的是，所有节点启动之后，外网用户通过负载后访问均指向了<code>10.1.82.84</code>这一台服务器，<code>nginx.conf</code>配置是<code>最小连接数</code>的配置，如下：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">upstream eln.dahuatech.com &#123;</span><br><span class="line">      #ip_hash;</span><br><span class="line">      #hash $http_x_forwarded_for;</span><br><span class="line">      #sticky;</span><br><span class="line">      least_conn;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.83</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.84</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">      server  <span class="number">10.1</span><span class="number">.82</span><span class="number">.113</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30</span>s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        server_name  eln.dahuatech.com;</span><br><span class="line">            listen     <span class="number">80</span>;</span><br><span class="line">            listen     <span class="number">443</span> ssl;</span><br><span class="line"></span><br><span class="line">        access_log logs/eln.dahuatech.com.access.log main;</span><br><span class="line">        error_log  logs/eln.dahuatech.com.error.log;</span><br><span class="line"></span><br><span class="line">        proxy_set_header Host $host:$server_port;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">            proxy_pass http:<span class="comment">//eln.dahuatech.com;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试的时候发现，即使绑定美国和香港的节点去<code>curl</code>，是能正常解析到其他机器上的。如下：<br><img src="/images/aliCDN3.png" alt="paradin"></p><p>然而源站过来的请求IP集中到了只有一个，这太奇怪了。</p><h2><span id="故障解决">故障解决</span></h2><p>后来发现ngnix后端会把http1.1转换成1.0变成短连接，这个连接存在的时间非常短，因为后端响应非常快。所以即使配上了<code>least_conn</code>，其实是没有任何效果的。这样负载均衡的nginx看到所有源站其实一直都是没有连接的，所以也就一直在给第一个转。</p><p>既然这样，就取消了<code>least_conn</code>改用轮询，nginx.conf也改成如下的样子：<br><img src="/images/aliCDN1.png" alt="paradin"></p><p>最后终于均衡了，大功告成！<br><img src="/images/aliCDN5.png" alt="paradin"></p><p>后来琢磨了一下，是用sticky其实也是OK的。</p><h2><span id="几个主流负载均衡软件配置cookie的方法">几个主流负载均衡软件配置cookie的方法</span></h2><p>1.Apache的话首先打开<code>httpd.conf</code>配置文件，确保如下配置没有被注释。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoadModule usertrack_module modules/mod_usertrack.so</span><br></pre></td></tr></table></figure></p><p>再在<code>virtual host</code>中添加以下配置。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CookieName name</span><br><span class="line">CookieExpires <span class="string">"1 days"</span></span><br><span class="line">CookieStyle Cookie</span><br><span class="line">CookieTracking on</span><br></pre></td></tr></table></figure></p><p>2.Nginx参考以下配置，设置Cookie。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">8080</span>;</span><br><span class="line">    server_name wqwq.example.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">      add_header <span class="built_in">Set</span>-Cookie name=xxxx;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.Lighttpd参考以下配置，设置Cookie。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.modules  = ( <span class="string">"mod_setenv"</span> )</span><br><span class="line">$HTTP[<span class="string">"host"</span>] == <span class="string">"test.example.com"</span> &#123;</span><br><span class="line">      server.document-root = <span class="string">"/var/www/html/"</span></span><br><span class="line">      setenv.add-response-header = ( <span class="string">"Set-Cookie"</span> =&gt; <span class="string">"name=XXXXXX"</span>      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2><span id="扩展阅读">扩展阅读</span></h2><p><a href="https://cloud.tencent.com/document/product/214/2736" target="_blank" rel="noopener">https://cloud.tencent.com/document/product/214/2736</a><br><a href="http://blog.text.wiki/2015/08/01/nginx-sticky-problem.html" target="_blank" rel="noopener">http://blog.text.wiki/2015/08/01/nginx-sticky-problem.html</a><br><a href="https://cloud.tencent.com/developer/article/1004547" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1004547</a></p>]]></content>
    
    <summary type="html">
    
      真正站在运维的层面讲nginx的书不多的...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="负载均衡" scheme="http://yoursite.com/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>记一次阿里云oss云存储删除失败的问题</title>
    <link href="http://yoursite.com/2018/04/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91oss%E4%BA%91%E5%AD%98%E5%82%A8%E5%88%A0%E9%99%A4%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/27/记一次阿里云oss云存储删除失败的问题/</id>
    <published>2018-04-27T14:24:58.000Z</published>
    <updated>2018-04-27T14:49:33.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>公司每天云存储都要删除过期的内容，工作细节是这样的：每天零点，采集模块开始收集应该删除掉的内容，然后把这个消息传给阿里云MQ，阿里云MQ又把消息传给删除模块，删除模块拿到名单之后，开始调用阿里云OSS的删除API进行删除。架构如图：<br><img src="/images/oss6.png" alt="paradin"></p><p>但是今天登陆监控平台发现，昨天oss没有删除，上涨了80多个T，如图：<br><img src="/images/oss1.png" alt="paradin"></p><p>老板一看，卧槽这怎么可以，80多个T的云存储费用可是不容小视的，于是责令追查一下为啥会发生这样的情况。</p><p>昨天我的手机又没有收到任何阿里云消息队列告警的信息，可见MQ应该是没问题的，查看一下是否有MQ的产生和消费情况，如下图：<br><img src="/images/oss2.png" alt="paradin" title="这个是消息产生情况"></p><p><img src="/images/oss3.png" alt="paradin" title="这个是消息消费情况"></p><p>产生的消息基本都消费掉了，由此推断之前的过程都应该是OK的。再查看一下会不会是删除模块外网带宽到期的问题，此时发现两天的流量有显著的不同：<br><img src="/images/oss7.png" alt="paradin" title="这个是正常的流量情况"></p><p><img src="/images/oss8.png" alt="paradin" title="这个是异常的流量情况"></p><p>流量明显减少，可以说是删除模块执行任务少了。于是到执行OSS删除API的模块上去抓了几个包，里面情况如下：<br><img src="/images/oss4.png" alt="paradin"></p><p>但是跑到阿里云对应的bucket里看一下文件情况，比如<code>https://lechangecloud.oss-cn-hangzhou.aliyuncs.com/lechange/4B01F1FPAGE4E9D_img/Alarm/20180427000913997_0_fa62bec6dee24cc0bee42e1ee3e75743_thumb_qcif.dav</code>这个文件，这个文件明明还在里面躺着好好的。如图：<br><img src="/images/oss5.png" alt="paradin"></p><p>文件00：27的时候就在了，但是2：53分的时候调用阿里云OSS的API去删除，明明返回了200，但是文件却没有真正的从OSS删除掉。</p><p>我觉得这样就拿去跟阿里云撕逼还是有点不太妥当，又回到刚刚的那个包里，我发现里面还有一些返回的内容是这样的：<br><img src="/images/oss9.png" alt="paradin"></p><p>这个图跟之前的图明显路径上不同，而这些文件在OSS上确认是被成功删除掉的，可见的确是文件路径的问题：失败的文件路径是完全路径，而成功的都是相对路径。于是就告诉开发赶快整改代码，把路径统一…</p><p><img src="/images/朝韩会面.png" alt="paradin" title="历史性的会面"></p>]]></content>
    
    <summary type="html">
    
      这一周六天班通宵了三次...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="阿里云" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>在安装docker私有仓库的时候遇到的openssl问题</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9C%A8%E5%AE%89%E8%A3%85docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84openssl%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/21/在安装docker私有仓库的时候遇到的openssl问题/</id>
    <published>2018-04-20T16:45:39.000Z</published>
    <updated>2018-04-26T15:30:53.852Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>按照<a href="http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/docker-technology-and-combat/local_repo.html</a> 的方法本地安装一个私有仓库，在执行<code>sudo pip install docker-registry</code>这一步的时候，出现了这样的一个错误：<br><img src="/images/openssl1.png" alt="paradin"></p><p>既然说我没有swig，于是我<code>yum install swig -y</code>，安装的是<code>2.0.10-5.el7</code>版本。然后再次<code>pip install docker-registry</code>，一顿噼里啪啦之后，这次成了这样：<br><img src="/images/openssl2.png" alt="paradin"></p><p>又说没有openssl的文件，那执行<code>yum install openssl-devel</code>，OK了之后再次<code>pip install docker-registry</code>，再一次噼里啪啦，如下：<br><img src="/images/openssl3.png" alt="paradin"></p><p>反馈我：<code>/usr/include/openssl/opensslconf.h:44: Error: CPP #error &quot;&quot;This openssl-devel package does not work your architecture?&quot;&quot;. Use the -cpperraswarn option to continue swig processing.</code>,这个提示大意是说openssl-devel版本不适合你的系统架构，也就是x86的去找x86的头文件，x86_64的去找x86_64文件，但现在是互相找不到对方。</p><p>既然说<code>/usr/include/openssl/opensslconf.h</code>这个第44行有错误，那我们就打开这个文件去看看第44行写的是啥：<br>    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include "opensslconf-x86_64.h"</span><br><span class="line">43 #else</span><br><span class="line">44 #error "This openssl-devel package does not work your architecture?"</span><br><span class="line">45 #endif</span><br><span class="line"><span class="number">46</span> </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p><p>这里我把第44行改成了这样：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">41 #elif defined(__x86_64__)</span><br><span class="line">42 #include &quot;opensslconf-x86_64.h&quot;</span><br><span class="line">43 #else</span><br><span class="line">44 #include &quot;opensslconf.h&quot;    #去掉了原来的error提示，改成了安装opensslconf.h文件。</span><br><span class="line">45 #endif</span><br><span class="line">46 </span><br><span class="line">47 #undef openssl_opensslconf_multilib_redirection_h</span><br></pre></td></tr></table></figure></p><p>这一次重新执行<code>sudo pip install docker-registry</code>，终于成功…<br><img src="/images/openssl4.png" alt="paradin"></p><p><img src="/images/agirl.gif" alt="akb48"></p>]]></content>
    
    <summary type="html">
    
      这破玩意查了半天...
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="容器技术" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在国王杯前夕评巴萨</title>
    <link href="http://yoursite.com/2018/04/21/%E5%9C%A8%E5%9B%BD%E7%8E%8B%E6%9D%AF%E5%89%8D%E5%A4%95%E8%AF%84%E5%B7%B4%E8%90%A8/"/>
    <id>http://yoursite.com/2018/04/21/在国王杯前夕评巴萨/</id>
    <published>2018-04-20T16:44:17.000Z</published>
    <updated>2018-04-20T17:40:54.008Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>今天凌晨的马竞在西甲意外输给了皇家社会，巴萨的积分优势扩大到了12分。这个周末巴萨要跟塞维利亚打国王杯决赛，4月30号对拉科鲁尼亚的西甲联赛巴萨只要获胜，就会拿到今年的西甲联赛冠军，从而以冠军姿态在诺坎普迎接本赛季第二场国家德比。</p><h2><span id="巴尔韦德的困境">巴尔韦德的困境</span></h2><p>巴萨今年可以说是低姿态开始：从内马尔突然的离开到西超杯被皇马灌了5个，不可为说不惨。但是巴尔韦德在联赛却目前保持不败，这个成绩单可以说是相当不错的，这中间还有在伯纳乌的三球胜利。</p><p>赛季中前段，巴萨三线顺风顺水，前有塞梅多惊艳开场，后有大祭司维尔马伦扎实顶上，主教练巴尔韦德也给了阿奈斯这样小将出场机会，哪怕登贝莱那时候养伤，报纸媒体一片其乐融融。如果保利尼奥再有进球，更是一片狂欢。</p><p>然后巴尔韦德的保守开始慢慢让人所诟病，他是一个重视防守的教练，这很好，但是他有了库迪尼奥也有了归来的登贝莱，结果反而不敢搞轮换，甚至坚持让布教授打封闭出场，虽然不少人抱怨，但是由于球队整体战绩还算平稳，所以没有大规模的重视。可是巴萨欧冠的结果跟恩里克的第二个赛季一样，倒在了与罗马的第二回合比赛里，连续三年没有闯入欧冠四强。</p><p>其实对战罗马的第一回合，巴萨的4：1已经是靠意志拼下来的比赛，球员难免在第二回合的心态上有所轻敌，这种心态上的轻敌难免会影响到身体，但是巴尔韦德的临场指挥也让人严重不满。落下这耻辱一战，媒体和球迷之前的“忍气吞声”一并爆发，狂轰滥炸，直到现在依旧有人说“哪怕真的赛季双冠，也会因为欧冠的失利而让那两冠索然无味”。<br><img src="/images/fcb4.png" alt="paradin"></p><p>所以，巴尔韦德要在这个周日的国王杯决赛和对阵拉科鲁尼亚的西甲联赛里稳扎稳打，把国王杯和西甲冠军彻底拿到手里，这样整个人也能轻松一些。可是说来说去罗马一役这一个跟头摔得太疼了，在那么重大的比赛里失败，肯定需要在一个同样重大的比赛里胜利以挽回颜面，第二回合的国家德比无疑就是一个好的机会，如果巴尔韦德成功捍卫了诺坎普，“联赛双杀皇马+国内双冠”也能成为一个功劳。但是如果那场比赛，一心要打破巴萨不败金身的皇马真的成功了，那巴尔韦德势必在巴萨主帅的位置上也是飘摇。</p><p>所以巴帅，请务必要拿下国王杯冠军+西甲冠军！在第二个国家德比里也请拼尽全力！这样才能多少挽回一点“罗马之耻”的颜面。<br><img src="/images/fcb1.png" alt="paradin"></p><h2><span id="夏季转会展望">夏季转会展望</span></h2><p>我个人认为，巴萨很有可能在今年夏天卖掉如下几个人：西莱森、戈麦斯、小苏亚雷斯、艾尔卡塞尔、比达尔，自由走人的可能会是小白。这些人能套现7000万应该就满足了。</p><p>巴萨后卫现在四个人皮克和维尔马伦属于潜藏的伤员病号，米纳技术还是太糙，稍微让人放心的就是乌姆蒂蒂，他的续约问题肯定是休赛期的一个大事。不过我觉得米纳其实可以再留一年看看，他身体素质很好，而且人还年轻没伤病，只要心态练得沉稳，当一个合格的中后卫不难。</p><p>至于中场，个人希望小白再踢一年，现在我也觉得一个满血的小白应付普通的联赛、欧冠小组赛和杯赛都不是什么难事。但是目前的媒体趋势是小白赛季结束会来中超重庆队，即使这样巴萨也需要一个山寨的坎特和一个山寨的埃里克森，而罗贝托集这两个属性于一身，所以他就是一个“奉献的砖”，但是这样如果比达尔真的不留下来的话，巴萨还需要补进一个右后卫跟塞梅多良性竞争，这个右后卫的人选就比较挠头了。贝莱林？或许是一个选择，但是这个选择跟当年小法一样—要是双输就不好了。</p><p>前场如果能拿下格里兹曼肯定是好的，艾尔卡塞尔这种“躲着后卫”的踢法，虽然进球效率可以，但是没有真正起到轮换苏亚雷斯的作用。这样巴萨还需要在板凳上补充一个中锋（不用多能进球，哪怕搅屎棍也可以），同时也做好登贝莱/苏亚雷斯/梅西/格里兹曼（假设他真的来）的轮换。</p><p>总而言之，现在巴萨还是回归433比较好，配合442和4312的变化。那么休赛期最重要的补强就是格里兹曼+能抗中卫的前锋+一个中场+一个优秀的边后卫。</p><p>我个人希望的引援名单如下：<br>中场是魏格尔和B队的阿莱尼亚，埃里克森、博格巴和维拉蒂这三个不算是好的选择，要么太贵，要么节奏太慢。至于伊斯科、大卫席尔瓦、皮亚尼奇，那想都别想了，母队不会放人的。至于格雷茨卡，拜仁不是善茬；<br>边后卫可以考虑贝莱林，这个要看一下阿森纳的新教练是谁，摩纳哥的法比尼奥也可以，我知道他现在改中场了，也不耽误来一下跟罗贝托交叉换位…<br>前锋的话，我个人推荐B队阿奈斯试试看，其他的人选估计就是在西甲联赛内部找了；<br>这几个位置，最重要就是中场！梅西当初在哈白布的配合下威力无穷，一旦巴萨的中场重新掌握了控制力，不用频繁回撤的梅西依旧会进球如麻，这一点毋庸置疑。<br><img src="/images/fcb3.png" alt="paradin"></p><h2><span id="温格会来">温格会来？</span></h2><p>我个人首先不希望巴尔韦德下课，毕竟现在巴萨联赛冠军十拿九稳，国王杯如果也揽入怀中，这样一个成绩单也是一个80分，如果这个分数都炒掉主教练，那么继任者的压力势必很大，所以我个人倾向巴尔韦德留任，好好想一下，等阿图尔以及可能会来的格里兹曼到位了，巴萨应该怎么打。</p><p>不过如果温格真的来了，我个人也是赞成的，因为阿森纳的球风本来跟巴萨相似，相信温格跟梅西等人也会无缝接入，到时候教授或许真的可以在巴萨圆了欧冠梦想，不过这个想法成真的可能性低于5%，想想就得了。</p><h2><span id="下赛季的任务">下赛季的任务</span></h2><p>1.进攻体系依旧围绕梅西建队，让梅西继续火力全开的同时保证休息，欧冠要他有大用；<br>2.新球员（包括库蒂尼奥和登贝莱）适应巴萨的风格和体系，让皮克和布教授也能轮换得到休息；<br>3.欧冠一定要进入四强；<br>4.欧冠四强的基础上，西甲联赛冠军和国王杯能拿还是要拿，同时最好也能阻击皇马；<br><img src="/images/fcb2.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这几天的巴萨真是风雨飘摇，操碎我的心
    
    </summary>
    
      <category term="追乱花天" scheme="http://yoursite.com/categories/%E8%BF%BD%E4%B9%B1%E8%8A%B1%E5%A4%A9/"/>
    
    
      <category term="国际足坛" scheme="http://yoursite.com/tags/%E5%9B%BD%E9%99%85%E8%B6%B3%E5%9D%9B/"/>
    
      <category term="巴塞罗那" scheme="http://yoursite.com/tags/%E5%B7%B4%E5%A1%9E%E7%BD%97%E9%82%A3/"/>
    
  </entry>
  
  <entry>
    <title>国内Docker的加速方法</title>
    <link href="http://yoursite.com/2018/04/20/%E5%9B%BD%E5%86%85Docker%E7%9A%84%E5%8A%A0%E9%80%9F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/20/国内Docker的加速方法/</id>
    <published>2018-04-19T16:00:04.000Z</published>
    <updated>2018-04-19T16:17:09.102Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>由于大陆政府的特殊政策，国内想访问一些国外的资源是非常的曲折和痛苦，比较有代表性的就是亚马逊的云存储以及docker，尤其在<code>docker pull</code>一些镜像的时候，更是心惊胆战，祈求不要出现timout，然而现实往往很骨感。如下图：<br><img src="/images/jiasu.png" alt="paradin"></p><p>那么应该如何达到加速的效果呢？</p><p>在<code>CentOS 7</code>里，对于使用<code>systemd</code>的系统，请在<code>/etc/docker/daemon.json</code>中写入如下内容：（如果文件不存在请新建该文件）<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p><p>之后重新启动服务。<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>注意：如果您之前查看旧教程，修改了<code>docker.service</code>文件内容，请去掉您添加的内容（–registry-mirror=<a href="https://registry.docker-cn.com）。" target="_blank" rel="noopener">https://registry.docker-cn.com）。</a></p><p>配置加速之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行<code>docker info |grep &#39;Registry Mirrors&#39; -A</code>，如果从结果中看到了如下内容，说明配置成功。<br><img src="/images/jiasu2.png" alt="paradin"></p><p>现在再重新尝试一下<code>docker pull training/webapp</code>，看看效果：<br><img src="/images/jiasu3.png" alt="paradin"></p><p>仅用17秒就pull了几乎400MB的镜像，高下立判！</p>]]></content>
    
    <summary type="html">
    
      墙内想干点事的确挺费劲
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>在Grafana里添加worldping插件</title>
    <link href="http://yoursite.com/2018/04/19/%E5%9C%A8Grafana%E9%87%8C%E6%B7%BB%E5%8A%A0worldping%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/04/19/在Grafana里添加worldping插件/</id>
    <published>2018-04-19T02:41:18.000Z</published>
    <updated>2018-04-19T03:53:34.284Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="安装插件">安装插件</span></h2><p>worldping是一个监控网站的dns、ping、http响应、https响应的插件，要安装它很简单，在granafa服务器里执行如下命令：<br>    <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grafana-cli plugins install raintank-worldping-app</span><br><span class="line">systemctl restart grafana-server.service</span><br></pre></td></tr></table></figure></p><p>执行完毕之后在grafana的界面里选择<code>Plugins</code>，然后在<code>APP</code>里找到<code>worldping</code>，启动它，但是此时发现需要一个api，如图：<br><img src="/images/worldping.png" alt="paradin"></p><p>此时你需要登录grafana的官网，然后点击<code>api keys</code>和<code>ADD API KEY</code>，就可以生成一个<code>API KEY</code>，名字可以随便起，如下：<br><img src="/images/worldping2.png" alt="paradin"></p><p>将生成的api key保存好，并且填回到grafana的api key里，这样worldping插件就可以使用了，如图：<br><img src="/images/worldping3.png" alt="paradin"></p><h2><span id="监控网站节点">监控网站节点</span></h2><p>此时点击黄色旋涡，发现多了worldping的选项，点击<code>worldping Home</code>，如图：<br><img src="/images/worldping4.png" alt="paradin"></p><p>然后点击<code>+ New Endpoint</code>，这里我输入我公司的官网域名，然后<code>begin auto-discovery</code>，如图：<br><img src="/images/worldping5.png" alt="paradin"></p><p>生成了结果之后，点击add，此时开始检查几个大城市，如芝加哥、东京、纽约、巴黎等大城市连接到刚刚输入的域名的情况，如图：<br><img src="/images/worldping6.png" alt="paradin"></p><p>大约需要1~2分钟后，数据检查完成，可以点击<code>GO to Summary Dashboard</code>，就会看到图像了：<br><img src="/images/worldping7.png" alt="paradin"></p><p>为什么我这个图里没有http?因为在nginx里我们做了http强制rewrite跳转到https，所以是读不到值的。</p><h2><span id="删除网站节点">删除网站节点</span></h2><p>如果要删除网站节点，还是在worldping里点击要删除网站后面的齿轮图标，如图：<br><img src="/images/worldping8.png" alt="paradin"></p><p>然后选择<code>configuration</code>，这里可以修改网站域名，要删除的话，选择最下面的<code>destory</code>，输入DELETE确认，然后就可以点击<code>DELETE</code>删除了，如图：<br><img src="/images/worldping9.png" alt="paradin"></p>]]></content>
    
    <summary type="html">
    
      这个搭配zabbix的网站监控，双重check!
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="grafana" scheme="http://yoursite.com/tags/grafana/"/>
    
      <category term="图像监控" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>用非root启动进程以及启动docker</title>
    <link href="http://yoursite.com/2018/04/18/%E7%94%A8%E9%9D%9Eroot%E5%90%AF%E5%8A%A8%E8%BF%9B%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%90%AF%E5%8A%A8docker/"/>
    <id>http://yoursite.com/2018/04/18/用非root启动进程以及启动docker/</id>
    <published>2018-04-18T14:19:34.000Z</published>
    <updated>2018-05-15T06:28:45.869Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2><span id="使用非root用户启动普通进程">使用非root用户启动普通进程</span></h2><p>使用非root用户启动进程是运维安全的一个主要环节，拿tomcat进程来说，如果是使用root用户去启动了tomcat，那么有一个严重的问题，那就是tomcat具有root权限。这意味着你的任何一个jsp脚本都具有root权限，所以那些不怀好意的人可以轻易地用jsp脚本去搞破坏，甚至删除你整个硬盘里的东西！所以为了活着，我们要极力避免这种现象。</p><p>很多的软件都自带的用户/用户组，比如nginx、zabbix、elasticsearch，但是也有更多的软件没有这么贴心的服务，这就需要我们手动的更改了。</p><h2><span id="docker不应该使用root启动">docker不应该使用root启动</span></h2><p>1.8版本之前的docker是不支持<code>user namespace</code>的，所以那样的话，如果在docker容器内部使用root运行app，那么不可否认，这个root和宿主机的root是同一个UID。但是，需要特别注意的是，容器内的root与宿主机上的root权限并不一定是相等的。</p><p>但是为了绝对的安全，还是推荐把docker升级到1.8以上，然后彻底避免用root去启动容器，在<a href="http://www.projectatomic.io/docs/docker-image-author-guidance/里最下面一段也明文说了---" target="_blank" rel="noopener">http://www.projectatomic.io/docs/docker-image-author-guidance/里最下面一段也明文说了---</a><font color="red">生产环境里不要用root用户去启动docker!!!</font><br><img src="/images/noroot.png" alt="paradin"></p><p>使用非root用户启动docker的办法如下：<br>创建docker组：<code>sudo groupadd docker</code><br>将当前用户加入docker组：<code>sudo gpasswd -a ${USER} docker</code><br>重新启动docker服务：<code>sudo service docker restart</code>或<code>sudo systemctl restart docker</code><br>当前用户退出系统再重新登陆。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://www.zhihu.com/question/25580965" target="_blank" rel="noopener">https://www.zhihu.com/question/25580965</a></p>]]></content>
    
    <summary type="html">
    
      root尽可能的不要出现在服务器里
    
    </summary>
    
      <category term="工作与技术" scheme="http://yoursite.com/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
